From: <Saved by Blink>
Snapshot-Content-Location: https://users.cs.utah.edu/~aburtsev/238P/hw/hw4-boot-into-c/hw4-boot-into-c.html
Subject: HW4 - 238P Operating Systems
Date: Sat, 26 Aug 2023 05:55:18 -0000
MIME-Version: 1.0
Content-Type: multipart/related;
	type="text/html";
	boundary="----MultipartBoundary--X7AbJLMYIFTKHp8K9yEpurltyGfwpKdpPJjJNyVzsn----"


------MultipartBoundary--X7AbJLMYIFTKHp8K9yEpurltyGfwpKdpPJjJNyVzsn----
Content-Type: text/html
Content-ID: <frame-EA9A9DB7F1BDB6168AF0E8D542C3660E@mhtml.blink>
Content-Transfer-Encoding: quoted-printable
Content-Location: https://users.cs.utah.edu/~aburtsev/238P/hw/hw4-boot-into-c/hw4-boot-into-c.html

<!DOCTYPE html><html lang=3D"en"><head><meta http-equiv=3D"Content-Type" co=
ntent=3D"text/html; charset=3DUTF-8">
        <title>HW4 - 238P Operating Systems</title>
        <meta name=3D"Description" content=3D"Homework 238P, Anton Burtsev.=
">
        <meta name=3D"Keywords" content=3D"Anton Burtsev, Burtsev, Anton, c=
s238p">
       =20
        <meta name=3D"viewport" content=3D"width=3Ddevice-width, initial-sc=
ale=3D1, maximum-scale=3D1.8, minimum-scale=3D1">
        <link href=3D"https://users.cs.utah.edu/~aburtsev/238P/style/simple=
.css" type=3D"text/css" rel=3D"stylesheet">
        <link href=3D"https://users.cs.utah.edu/~aburtsev/238P/style/favico=
n.png" type=3D"image/jpg" rel=3D"shortcut icon">
    </head>

   =20
    <body class=3D"default-theme">
	    <header id=3D"top">
            <div class=3D"content">
                <nav class=3D"navigation">
                    <ul>
                        <li><a href=3D"https://users.cs.utah.edu/~aburtsev/=
238P/index.html">Home</a></li>
                    </ul>
                </nav>
                <div class=3D"title">
                    <span class=3D"pre">Homework 4:</span>
                    <h1>Booting into C</h1>
                </div>
            <nav class=3D"inner-nav"><ul><li><a href=3D"https://users.cs.ut=
ah.edu/~aburtsev/238P/hw/hw4-boot-into-c/hw4-boot-into-c.html#0">Boot Overv=
iew</a></li><li><a href=3D"https://users.cs.utah.edu/~aburtsev/238P/hw/hw4-=
boot-into-c/hw4-boot-into-c.html#1">Multiboot Headers</a></li><li><a href=
=3D"https://users.cs.utah.edu/~aburtsev/238P/hw/hw4-boot-into-c/hw4-boot-in=
to-c.html#2">Firmware &amp; BIOS</a></li><li><a href=3D"https://users.cs.ut=
ah.edu/~aburtsev/238P/hw/hw4-boot-into-c/hw4-boot-into-c.html#3">Bootloader=
</a></li><li><a href=3D"https://users.cs.utah.edu/~aburtsev/238P/hw/hw4-boo=
t-into-c/hw4-boot-into-c.html#4">Hello, World!</a></li><li><a href=3D"https=
://users.cs.utah.edu/~aburtsev/238P/hw/hw4-boot-into-c/hw4-boot-into-c.html=
#5">Linking</a></li><li><a href=3D"https://users.cs.utah.edu/~aburtsev/238P=
/hw/hw4-boot-into-c/hw4-boot-into-c.html#6">Making an ISO</a></li><li><a hr=
ef=3D"https://users.cs.utah.edu/~aburtsev/238P/hw/hw4-boot-into-c/hw4-boot-=
into-c.html#7">Running in QEMU</a></li><li><a href=3D"https://users.cs.utah=
.edu/~aburtsev/238P/hw/hw4-boot-into-c/hw4-boot-into-c.html#8">Automation w=
ith Make</a></li><li><a href=3D"https://users.cs.utah.edu/~aburtsev/238P/hw=
/hw4-boot-into-c/hw4-boot-into-c.html#9">Paging</a></li><li><a href=3D"http=
s://users.cs.utah.edu/~aburtsev/238P/hw/hw4-boot-into-c/hw4-boot-into-c.htm=
l#10">Setting up a GDT</a></li><li><a href=3D"https://users.cs.utah.edu/~ab=
urtsev/238P/hw/hw4-boot-into-c/hw4-boot-into-c.html#11">Calling main()</a><=
/li><li><a href=3D"https://users.cs.utah.edu/~aburtsev/238P/hw/hw4-boot-int=
o-c/hw4-boot-into-c.html#12">Serial Line Driver</a></li><li><a href=3D"http=
s://users.cs.utah.edu/~aburtsev/238P/hw/hw4-boot-into-c/hw4-boot-into-c.htm=
l#13">Booting into C</a></li><li><a href=3D"https://users.cs.utah.edu/~abur=
tsev/238P/hw/hw4-boot-into-c/hw4-boot-into-c.html#14">Debugging with GDB</a=
></li><li><a href=3D"https://users.cs.utah.edu/~aburtsev/238P/hw/hw4-boot-i=
nto-c/hw4-boot-into-c.html#15">QEMU's monitor</a></li><li><a href=3D"https:=
//users.cs.utah.edu/~aburtsev/238P/hw/hw4-boot-into-c/hw4-boot-into-c.html#=
16">Your Assignment</a></li><li><a href=3D"https://users.cs.utah.edu/~aburt=
sev/238P/hw/hw4-boot-into-c/hw4-boot-into-c.html#17">Submit your Work</a></=
li></ul></nav></div>
        </header>

        <article>
            <section class=3D"page">
                <div class=3D"content">
                    <section class=3D"subsection">
                        <p>This assignment will teach you to build a minima=
l bootable code that boots on real hardware into C. Technically, you can do=
 this assignment on any operating system that supports the Unix API and can=
 run Qemu (Linux Openlab machines, your laptop that runs Linux or Linux VM,=
 and even MacOS, etc.). <b>You don't need to set up xv6 for this assignment=
</b>, but <b>if you're running on Openlab you'll have to install QEMU</b>, =
see <a href=3D"https://users.cs.utah.edu/~aburtsev/238P/doc/xv6-setup.html"=
>QEMU setup instructions</a>.</p>
                        <p>For <b>Mac / OSX</b> users: the support of 32 bi=
t applications is deprecated in the latest version of your system. So if yo=
u already updated your system to MacOS Catalina or have updated your XCode =
then we recommend you to do the homework at the Openlab machines.</p>
                        <p>This assignment explains how to create a minimal=
 x86 operating system kernel using the Multiboot standard. In fact, it will=
 just boot and print "Hello, world!" on the screen, and then print "Hello f=
rom C!" on the serial line from the C <tt>main()</tt> function.</p>
                        <p>Most of this assignment is based on <a href=3D"h=
ttps://intermezzos.github.io/book/first-edition/multiboot-headers.html">int=
ermezzOS project</a>.</p>
                    </section><!-- end subsection -->
                </div><!-- end content -->
            </section><!-- end page -->
           =20
            <section class=3D"page">
                <div class=3D"div-title-wrapper"><span class=3D"go-top"><a =
href=3D"https://users.cs.utah.edu/~aburtsev/238P/hw/hw4-boot-into-c/hw4-boo=
t-into-c.html#top">Top</a></span><h2 class=3D"title" toc=3D"Boot Overview" =
id=3D"0" style=3D"display: inline; border-style: none;">Boot Overview</h2><=
/div>
                <div class=3D"content">
                    <section class=3D"subsection">
                        <p>When you turn on a computer, it loads the BIOS f=
rom some special flash memory. The BIOS runs self test and initialization r=
outines of the hardware, then it looks for bootable devices. If it finds on=
e, the control is transferred to its bootloader, which is a small portion o=
f executable code stored at the device's beginning. The bootloader has to d=
etermine the location of the kernel image on the device and load it into me=
mory. It also needs to switch the CPU to the so-called protected mode becau=
se x86 CPUs start in the very limited real mode by default (to be compatibl=
e to programs from 1978).</p>
                        <p>We won't write a bootloader because that would b=
e a complex project on its own (we partially covered this in class since xv=
6 implements a simple boot loader  with two files: <tt>bootasm.S</tt> and <=
tt>bootmain.c</tt>). Instead we will use one of the many well-tested bootlo=
aders out there to boot our kernel from a CD-ROM or USB drive</p>
                    </section><!-- end subsection -->
                </div><!-- end content -->
            </section><!-- end page -->
           =20
            <section class=3D"page">
                <div class=3D"div-title-wrapper"><span class=3D"go-top"><a =
href=3D"https://users.cs.utah.edu/~aburtsev/238P/hw/hw4-boot-into-c/hw4-boo=
t-into-c.html#top">Top</a></span><h2 class=3D"title" toc=3D"Multiboot Heade=
rs" id=3D"1" style=3D"display: inline; border-style: none;">Multiboot Heade=
rs</h2></div>
                <div class=3D"content">
                    <section class=3D"subsection">
                        <p>Let's get going! The very first thing we're goin=
g to do is create a 'multiboot header'. What's that, you ask? Well, to expl=
ain it, let's take a small step back and talk about how a computer boots up=
.</p>
                        <p>One of the amazing and terrible things about the=
 x86 architecture is that it's maintained backwards compatibility throughou=
t the years. This has been a competitive advantage, but it's also meant tha=
t the boot process is largely a pile of hacks. Each time a new iteration co=
mes out, a new step gets added to the process. That's right, when your fanc=
y new computer starts up, it thinks it's an 8086 from 1976. And then, throu=
gh a succession of steps, we transition through more and more modern archit=
ectures until we end at the latest and greatest.</p>
                        <p>The first mode is called 'real mode'. This is a =
16 bit mode that the original x86 chips used. The second is 'protected mode=
'. This 32 bit mode adds new things on top of real mode. It's called 'prote=
cted' because real mode sort of let you do whatever you wanted, even if it =
was a bad idea. Protected mode was the first time that the hardware enabled=
 certain kinds of protections that allow us to exercise more control around=
 such things as RAM. We'll talk more about those details later.</p>

                        <p>The final mode is called 'long mode', and it's 6=
4 bits. Since our OS will only enter 32bit mode we'll not touch 64bit 'long=
 mode'.</p>
                        <!--=20
                             <blockquote>
                             <p><strong>By the way...</strong></p>
                             <p>Well, that's actually a lie: there are two.=
 Initially, you're not in long mode, you're in 'compatibility mode'. You se=
e, when the industry was undergoing the transition from 32 to 64 bits, ther=
e were two options: the first was Intel's Itanium 64-bit architecture. It d=
id away with all of the stuff I just told you about. But that meant that pr=
ograms had to be completely recompiled from scratch for the new chips. Inte=
l's big competitor, AMD, saw an opportunity here, and released a new set of=
 chips called amd64. These chips were backwards compatible, and so you coul=
d run both 32 and 64 bit programs on them. Itanium wasn't compelling enough=
 to make the pain worth it, and so Intel released new chips that were compa=
tible with amd64. The resulting architecture was then called x86_64, the on=
e we're using today. The moral of the story? Intel tried to save you from a=
ll of the stuff we're about to do, but they failed. So we have to do it.</p=
>
                             </blockquote>
                        -->
                        <p>So that's the task ahead of us: make the jump up=
 the ladder and get to 32bit mode. We can do it! Let's talk more details.</=
p>
                    </section><!-- end subsection -->
                </div><!-- end content -->
            </section><!-- end page -->
           =20
            <section class=3D"page">
                <div class=3D"div-title-wrapper"><span class=3D"go-top"><a =
href=3D"https://users.cs.utah.edu/~aburtsev/238P/hw/hw4-boot-into-c/hw4-boo=
t-into-c.html#top">Top</a></span><h2 class=3D"title" toc=3D"Firmware &amp; =
BIOS" id=3D"2" style=3D"display: inline; border-style: none;">Firmware and =
the BIOS</h2></div>
                <div class=3D"content">
                    <section class=3D"subsection">
                        <p>So let's begin by turning the power to our compu=
ter on. When we press the power button, a bunch of low-level initialization=
 protocols  are executed: Management Engine, BIOS, etc.</p>
                        <p>With the BIOS we're already in the land of softw=
are, but unlike software that you may be used to writing, the BIOS comes bu=
ndled with its computer and is located in <b>R</b>ead-<b>O</b>nly <b>M</b>e=
mory (ROM).</p>
                        <p>One of the first things the BIOS does is run a '=
POST' or <b>P</b>ower-<b>O</b>n <b>S</b>elf-<b>T</b>est which checks for th=
e availability and integrity of all the pieces of hardware that the compute=
r needs including the BIOS itself, CPU registers, RAM, etc. If you've ever =
heard a computer beeping at you as it boots up, that's the POST reporting i=
ts findings.</p>
                        <p>Assuming no problems are found, the BIOS starts =
the real booting process.</p>
                        <div class=3D"msg note">
                            <h3>by the way...</h3>
                            <div class=3D"body">
                                <p>For a while now most commercial computer=
 manufacturers have hidden their BIOS booting process behind some sort of s=
plash screen. It's usually possible to see the BIOS' logs by pressing some =
collection of keys when your computer is starting up.</p>
                                <p>The BIOS also has a menu where you can s=
ee information about the computer like CPU and memory specs and all the har=
dware the BIOS detected like hard drives and CD and DVD drives. Typically t=
his menu is accessed by pressing some other weird collection of keyboard ke=
ys while the computer is attempting to boot.</p>
                            </div>
                        </div><!-- end msg -->
                        <p>The BIOS automatically finds a 'bootable drive' =
by looking in certain pre-determined places like the computer's hard drive =
and CD-DVD drives, and USB sticks. A drive is 'bootable' if it contains sof=
tware that can finish the booting process. In the BIOS menu you can usually=
 change in what order the BIOS looks for bootable drives or tell it to boot=
 from a specific drive.</p>
                        <p>The BIOS knows it's found a bootable drive by lo=
oking at the first few kilobytes of the drive and looking for some magical =
numbers set in that drive's memory. This won't be the last time some magica=
l numbers or hacky sounding things are used on our way to building an OS. S=
uch is life at such a low level...</p>
                        <p>When the BIOS has found its bootable drive, it l=
oads part of the drive into memory and transfers execution to it. With this=
 process, we move away from what comes dictated by the computer manufacture=
r and move ever closer to getting our OS running.</p>
                    </section><!-- end subsection -->
                </div><!-- end content -->
            </section><!-- end page -->
           =20
            <section class=3D"page">
                <div class=3D"div-title-wrapper"><span class=3D"go-top"><a =
href=3D"https://users.cs.utah.edu/~aburtsev/238P/hw/hw4-boot-into-c/hw4-boo=
t-into-c.html#top">Top</a></span><h2 class=3D"title" toc=3D"Bootloader" id=
=3D"3" style=3D"display: inline; border-style: none;">The Bootloader</h2></=
div>
                <div class=3D"content">
                    <section class=3D"subsection">
                        <p>The part of our bootable drive that gets execute=
d is called a <b>bootloader</b>, since it loads things at boot time. <b>The=
 bootloader's job is to take our kernel, put it into memory, and then trans=
ition control to it.</b></p>
                        <p>Some people start their operating systems journe=
y by writing a bootloader. For example,  in class we started by looking at =
the xv6 bootloader that is loaded by the BIOS at the <tt>0x7c00</tt> addres=
s. In this assignment we will not be doing that.</p>
                        <p>In the interest of actually getting around to im=
plementing a kernel, instead, we'll use an existing bootloader: GRUB.</p>
                    </section><!-- end subsection -->
                    <section class=3D"subsection">
                        <h3>GRUB and Multiboot</h3>
                        <p>GRUB stands for '<b>GR</b>and <b>U</b>nified <b>=
B</b>ootloader', and it's a common one for GNU/Linux systems. GRUB implemen=
ts a specification called Multiboot, which is a set of conventions for how =
a kernel should get loaded into memory. By following the Multiboot specific=
ation, we can let GRUB load our kernel.</p>
                        <p>The way that we do this is through a 'header'. W=
e'll put some information in a format that multiboot specifies right at the=
 start of our kernel. GRUB will read this information, and follow it to do =
the right thing.</p>
                        <p>One other advantage of using GRUB: it will handl=
e the transition from real mode to protected mode for us, skipping the firs=
t step. We don't even need to know anything about all of that old stuff. If=
 you're curious about the kinds of things you would have needed to know, pu=
t "A20 line" into your favorite search engine, and get ready to cry yoursel=
f to sleep.</p>
                    </section><!-- end subsection -->
                    <section class=3D"subsection">
                        <h3>Writing our own Multiboot header</h3>
                        <p>I said we were gonna get to the code, and then I=
 went on about more history. Sorry about that! It's code time for real! You=
 can download a zipped folder that contains skeletons for the homework file=
s <a href=3D"https://users.cs.utah.edu/~aburtsev/238P/hw/hw4-boot-into-c/bo=
ot-into-c-src.zip" download=3D"">boot-into-c-src.zip</a>.</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">boot-into-c-src.zip</span>
<span class=3D"code-line even">=E2=94=9C=E2=94=80=E2=94=80 boot.asm</span>
<span class=3D"code-line odd">=E2=94=9C=E2=94=80=E2=94=80 console.c</span>
<span class=3D"code-line even">=E2=94=9C=E2=94=80=E2=94=80 console.h</span>
<span class=3D"code-line odd">=E2=94=9C=E2=94=80=E2=94=80 .gdbinit</span>
<span class=3D"code-line even">=E2=94=9C=E2=94=80=E2=94=80 grub.cfg</span>
<span class=3D"code-line odd">=E2=94=9C=E2=94=80=E2=94=80 linker.ld</span>
<span class=3D"code-line even">=E2=94=9C=E2=94=80=E2=94=80 main.c</span>
<span class=3D"code-line odd">=E2=94=9C=E2=94=80=E2=94=80 Makefile</span>
<span class=3D"code-line even">=E2=94=94=E2=94=80=E2=94=80 multiboot_header=
.asm</span></div><!-- end code -->
                       =20
                        <p>Inside your homework folder there is a file call=
ed <tt>multiboot_header.asm</tt>. Open it in your favorite editor. I use <t=
t>vim</tt>, but you should feel free to use any great editor like eamcs.</p=
>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd entry">$ vim multiboot_header.asm</span></div><!-- end code -->
                        <p>This is a <tt>.asm</tt> file, which is short for=
 'assembly'. That's right, we're going to write some assembly code here. Do=
n't worry! It's not super hard.</p>
                        <div class=3D"msg info">
                            <h3>An aside about assembly</h3>
                            <div class=3D"body">
                                <p>Have you ever watched Rich Hickey's talk=
 "Simple vs. Easy"? It's a wonderful talk. In it, he draws a distinction be=
tween these two words, which are commonly used as synonyms.</p>
                                <p>Assembly coding is simple, but that does=
n't mean that it's easy. We'll be doing a little bit of assembly programmin=
g to build our operating system, but we don't need to know <b>that much</b>=
. It is completely learnable, even for someone coming from a high-level lan=
guage. You might need to practice a bit, and take it slow, but I believe in=
 you. You've got this. A good manual on NASM assembler  is <a href=3D"https=
://nasm.us/doc/nasmdoc3.html">here</a>.</p> =20
                            </div>
                        </div><!-- end msg -->
                    </section><!-- end subsection -->
                    <section class=3D"subsection">
                        <h3>The Magic Number</h3>
                        <p>Our first assembly file will be almost entirely =
<b>data</b>, not code. Here's the first line:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd"><span class=3D"warning">dd 0xe85250d6</span> <span class=3D"comment">;=
 magic number</span></span></div><!-- end code -->
                        <p>Ugh! Gibberish! Let's start with the semicolon (=
<tt>;</tt>). It's a comment, that lasts until the end of the line. This par=
ticular comment says 'magic number'. As we said, you'll be seeing a lot of =
magic numbers in your operating system work. The idea of a magic number is =
that it's completely and utterly arbitrary. It doesn't mean anything. It's =
just magic. The very first thing that the multiboot specification requires =
is that we have the magic number <tt>0xe85250d6</tt> right at the start.</p=
>
                        <div class=3D"msg note">
                            <h3>by the way...</h3>
                            <div class=3D"body">
                                <p>Wondering how a number can have letters =
inside of it? <tt>0xe85250d6</tt> is written in hexadecimal notation. Hexad=
ecimal is an example of a "numeral system" which is a fancy term for a "sys=
tem for conveying numbers". The numeral system you're probably most familia=
r with is the decimal system which conveys numbers using a combination of t=
he symbols <tt>0-9</tt>. Hexadecimal on the other hand uses a combination o=
f 16 symbols: <tt>0-9</tt> and <tt>a-f</tt> (or <tt>A-F</tt>, case does not=
 matter). Along with its fellow numeral system, binary, hexadecimal is used=
 <b>a lot</b> in low level programming. In order to tell if a number is wri=
tten in hexadecimal, you may be tempted to look for the use of letters in t=
he number, but a more surefire way is to look for a leading <tt>0x</tt>. Wh=
ile <tt>100</tt> isn't a hexadecimal number, <tt>0x100</tt> is.</p>
                            </div>
                        </div><!-- end msg -->
                        <p>What's the value in having an arbitrary number t=
here? Well, it's a kind of safeguard against bad things happening. This is =
one of the ways in which we can check that we actually have a real multiboo=
t header. If it doesn't have the magic number, something has gone wrong, an=
d we can throw an error.</p>
                        <p>I have no idea why it's <tt>0xe85250d6</tt>, and=
 I don't need to care. It just is.</p>
                        <p>Finally, the <tt>dd</tt>. It's short for 'define=
 double word'. It declares that we're going to stick some 32-bit data at th=
is location. Remember, when x86 first started, it was a 16-bit architecture=
 set. That meant that the amount of data that could be held in a CPU regist=
er (or one 'word' as it's commonly known) was 16 bits. To transition to a 3=
2-bit architecture without losing backwards compatibility, x86 got the conc=
ept of a 'double word' or double 16 bits.</p>
                    </section><!-- end subsection -->
                    <section class=3D"subsection">
                        <h3>The mode code</h3>
                        <p>Okay, time to add a second line:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">dd 0xe85250d6 <span class=3D"comment">; magic number</span></span>
<span class=3D"code-line even"><span class=3D"warning">dd 0</span>         =
 <span class=3D"comment">; protected mode code</span></span></div><!-- end =
code -->
                        <p>This is another form of magic number. We want to=
 boot into protected mode, and so we put a zero here, using <tt>dd</tt> aga=
in. If we wanted GRUB to do something else, we could look up another code, =
but this is the one that we want.</p>
                    </section><!-- end subsection -->
                    <section class=3D"subsection">
                        <h3>Header length</h3>
                        <p>The next thing that's required is a header lengt=
h. We could use <tt>dd</tt> and count out exactly how many bytes that our h=
eader is, but there's two reasons why we're not doing that:</p>
                        <ol>
                            <li>Computers should do math, not people.</li>
                            <li>We're going to add more stuff, and we'd hav=
e to recalculate this number each time. Or wait until the end and come back=
. See #1.</li>
                        </ol>
                        <p>Here's what this looks like:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd"><span class=3D"warning">header_start:</span></span>
<span class=3D"code-line even">    dd 0xe85250d6                <span class=
=3D"comment">; magic number</span></span>
<span class=3D"code-line odd">    dd 0                         <span class=
=3D"comment">; protected mode code</span></span>
<span class=3D"code-line even">    dd <span class=3D"warning">header_end - =
header_start</span> <span class=3D"comment">; header length</span></span>
<span class=3D"code-line odd"><span class=3D"warning">header_end:</span></s=
pan></div><!-- end code -->
                        <p>You don't have to align the comments if you don'=
t want to. I usually don't, but it looks nice and after we're done with thi=
s file, we're not going to mess with it again, so we won't be constantly re=
-aligning them in the future.</p>
                        <p>The <tt>header_start:</tt> and <tt>header_end:</=
tt> things are called <b>labels</b>. Labels let us use a name to refer to a=
 particular part of our code. Labels also refer to the memory occupied by t=
he data and code which directly follows it. So in our code above the label =
<tt>header_start</tt> points directly to the memory at the very beginning o=
f our magic number and thus to the very beginning of our header.</p>
                        <p>Our third <tt>dd</tt> line uses those two labels=
 to do some math: the header length is the value of <tt>header_end</tt> min=
us the value of <tt>header_start</tt>. Because <tt>header_start</tt> and <t=
t>header_end</tt> are just the addresses of places in memory, we can simply=
 subtract to get the distance between those two addresses. When we compile =
this assembly code, the assembler will do this calculation for us (so at ru=
ntime there is only a number in there). No need to figure out how many byte=
s there are by hand. Awesome.</p>
                        <p>You'll also notice that I indented the <tt>dd</t=
t> statements. Usually, labels go in the first column, and you indent actua=
l instructions. How much you indent is up to you; it's a pretty flexible fo=
rmat.</p>
                    </section><!-- end subsection -->
                    <section class=3D"subsection">
                        <h3>The Checksum</h3>
                        <p>The fourth field multiboot requires is a 'checks=
um'. The idea is that we sum up some numbers, and then use that number to c=
heck that they're all what we expected things to be. It's similar to a (ver=
y simple) hash, in this sense: it lets GRUB double-check that everything is=
 accurate. Here's the checksum:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd entry">header_start:</span>
<span class=3D"code-line even">    dd 0xe85250d6                <span class=
=3D"comment">; magic number</span></span>
<span class=3D"code-line odd">    dd 0                         <span class=
=3D"comment">; protected mode code</span></span>
<span class=3D"code-line even">    dd header_end - header_start <span class=
=3D"comment">; header length</span></span>
<span class=3D"code-line odd"></span>
<span class=3D"code-line even">    <span class=3D"comment">; checksum</span=
></span>
<span class=3D"code-line odd">    <span class=3D"warning">dd 0x100000000 - =
(0xe85250d6 + 0 + (header_end - header_start))</span></span>
<span class=3D"code-line even entry">header_end:</span></div><!-- end code =
-->
                        <p>Again, we'll use math to let the computer calcul=
ate the sum for us at compile time. We add up the magic number, the mode co=
de, and the header length, and then subtract it from a big number. <tt>dd</=
tt> then puts that value into this spot in our file.</p>
                        <div class=3D"msg note">
                            <h3>by the way...</h3>
                            <div class=3D"body">
                                <p>You might wonder why we're subtracting t=
hese values from 0x100000000. To answer this we can look at what <a href=3D=
"http://nongnu.askapache.com/grub/phcoder/multiboot.pdf">the multiboot spec=
</a> says about the checksum value in the header:</p>
                                <p><i>The field <tt>checksum</tt> is a 32-b=
it <a href=3D"http://intermezzos.github.io/book/appendix/signed-and-unsigne=
d.html">unsigned value</a> which, when added to the other magic fields (i.e=
. <tt>magic</tt>, <tt>architecture</tt> and <tt>header_length</tt>), must h=
ave a 32-bit unsigned sum of zero.</i></p>
                                <p>In other words, <tt>checksum</tt> + <tt>=
magic_number</tt> + <tt>architecture</tt> + <tt>header_length</tt> =3D 0</p=
>
                                <p>We could try and "solve for" <tt>checksu=
m</tt> like so:</p>
                                <p><tt>checksum</tt> =3D  -(<tt>magic_numbe=
r</tt> + <tt>architecture</tt> + <tt>header_length</tt>)</p>
                                <p>But here's where it gets weird. Computer=
s don't have an innate concept of negative numbers. Normally we get around =
this by using "signed integers", which is something covered in this <a href=
=3D"http://intermezzos.github.io/book/appendix/signed-and-unsigned.html">ap=
pendix</a>. The point is we have an unsigned integer here, which means we'r=
e limited to representing only positive numbers. This means we can't litera=
lly represent -(<tt>magic_number</tt> + <tt>architecture</tt> + <tt>header_=
length</tt>) in our field.</p>
                                <p>If you look closely at the spec you'll n=
otice it's strangely worded: it's asking for a value that when added to oth=
er values has a sum of zero. It's worded this way because integers have a l=
imit to the size of numbers they can represent, and when you go over that s=
ize, the values wrap back around to zero. So 0xFFFFFFFF + 1 is.... 0x000000=
00. This is a hardware limitation: technically it's doing the addition corr=
ectly, giving us the 33-bit value 0x100000000, but we only have 32 bits to =
store things in so it can't actually tell us about that <tt>1</tt> in the m=
ost significant digit position! We're left with the rest of the digits, whi=
ch spell out zero.</p>
                                <p>So what we can do here is "trick" the co=
mputer into giving us zero when we do the addition. Imagine for the sake of=
 argument that <tt>magic_number</tt> + <tt>architecture</tt> + <tt>header_l=
ength</tt> somehow works out to be 0xFFFFFFFE. The number we'd add to that =
in order to make 0 would be 0x00000002. This is 0x100000000-0xFFFFFFFE, bec=
ause 0x100000000 technically maps to 0 when we wrap around. So we replace 0=
xFFFFFFFE in our contrived example here with <tt>magic_number</tt> + <tt>ar=
chitecture</tt> + <tt>header_length</tt>. This gives us: <tt>dd 0x100000000=
 - (0xe85250d6 + 0 + (header_end - header_start))</tt></p>
                            </div>
                        </div><!-- end msg -->
                    </section><!-- end subsection -->
                    <section class=3D"subsection">
                        <h3>Ending tag</h3>
                        <p>After the checksum you can list a series of "tag=
s", which is a way for the OS to tell the bootloader to do some extra thing=
s before handing control over to the OS, or to give the OS some extra infor=
mation once started. We don't need any of that yet, though, so we just need=
 to include the required "end tag", which looks like this:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd entry">header_start:</span>
<span class=3D"code-line even">    dd 0xe85250d6                <span class=
=3D"comment">; magic number</span></span>
<span class=3D"code-line odd">    dd 0                         <span class=
=3D"comment">; protected mode code</span></span>
<span class=3D"code-line even">    dd header_end - header_start <span class=
=3D"comment">; header length</span></span>
<span class=3D"code-line odd"></span>
<span class=3D"code-line even">    <span class=3D"comment">; checksum</span=
></span>
<span class=3D"code-line odd">    dd 0x100000000 - (0xe85250d6 + 0 + (heade=
r_end - header_start))</span>
<span class=3D"code-line even"></span>
<span class=3D"code-line odd">    <span class=3D"comment">; required end ta=
g</span></span>
<span class=3D"code-line even">    <span class=3D"warning">dw 0</span>    <=
span class=3D"comment">; type</span></span>
<span class=3D"code-line odd">    <span class=3D"warning">dw 0</span>    <s=
pan class=3D"comment">; flags</span></span>
<span class=3D"code-line even">    <span class=3D"warning">dd 8</span>    <=
span class=3D"comment">; size</span></span>
<span class=3D"code-line odd entry">header_end:</span></div><!-- end code -=
->
                        <p>Here we use <tt>dw</tt> to define a 'word' inste=
ad of just data. Remember a 'word' is 16 bits or 2 bytes on the x86_64 arch=
itecture. The multiboot specification demands that this be exactly a word. =
You'll find that this is super common in operating systems: the exact size =
and amount of everything matters. It's just a side-effect of working at a l=
ow level.</p>
                    </section><!-- end subsection -->
                    <section class=3D"subsection">
                        <h3>The Section</h3>
                        <p>We have one last thing to do: add a 'section' an=
notation. We'll talk more about sections later, so for now, just put what I=
 tell you at the top of the file. Here's the final file:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd"><span class=3D"warning">section .multiboot_header</span></span>
<span class=3D"code-line even entry">header_start:</span>
<span class=3D"code-line odd">    dd 0xe85250d6                <span class=
=3D"comment">; magic number</span></span>
<span class=3D"code-line even">    dd 0                         <span class=
=3D"comment">; protected mode code</span></span>
<span class=3D"code-line odd">    dd header_end - header_start <span class=
=3D"comment">; header length</span></span>
<span class=3D"code-line even"></span>
<span class=3D"code-line odd">    <span class=3D"comment">; checksum</span>=
</span>
<span class=3D"code-line even">    dd 0x100000000 - (0xe85250d6 + 0 + (head=
er_end - header_start))</span>
<span class=3D"code-line odd"></span>
<span class=3D"code-line even">    <span class=3D"comment">; required end t=
ag</span></span>
<span class=3D"code-line odd">    dw 0    <span class=3D"comment">; type</s=
pan></span>
<span class=3D"code-line even">    dw 0    <span class=3D"comment">; flags<=
/span></span>
<span class=3D"code-line odd">    dd 8    <span class=3D"comment">; size</s=
pan></span>
<span class=3D"code-line even entry">header_end:</span></div><!-- end code =
-->
                        <p>We have just written a multiboot compliant heade=
r. It's a lot of esoterica, but it's pretty straightforward once you've see=
n it a few times.</p>
                    </section><!-- end subsection -->
                    <section class=3D"subsection">
                        <h3>Assembling with <tt>nasm</tt></h3>
                        <p>We can't use this file directly, we need to turn=
 it into binary. We can use a program called an 'assembler' to 'assemble' o=
ur assembly code into binary code. It's very similar to using a 'compiler' =
to 'compile' our source code into binary. But when it's assembly, people of=
ten use the more specific name.</p>
                        <p>We will be using an assembler called <tt>nasm</t=
t> to do this. You should invoke <tt>nasm</tt> like this:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd entry">$ nasm -f elf32 -g -F dwarf multiboot_header.asm</span></div><!-=
- end code -->
                        <p>The <tt>-f elf32</tt> says that we want to outpu=
t a file as 32bit ELF. The <tt>-g -F dwarf</tt> flag says that we want to i=
nclude debugging information in <a href=3D"http://wiki.dwarfstd.org/index.p=
hp?title=3DDwarf_FAQ" target=3D"_blank" rel=3D"noopener noreferrer">dwarf f=
ormat</a>. After you run this command, you should see a <tt>multiboot_heade=
r.o</tt> file in the same directory. This is our 'object file', hence the <=
tt>.o</tt>. Don't let the word 'object' confuse you. It has nothing to do w=
ith anything object oriented. 'Object files' are just binary code with some=
 metadata in a particular format, in our case ELF. Later, we'll take this f=
ile and use it to build our OS.</p>
                        <p>You can inspect the bytes of the header with <tt=
>hexdump</tt>:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd entry">$ hexdump -x multiboot_header.o</span>
<span class=3D"code-line even">0000000    50d6    e852    0000    0000    0=
018    0000    af12    17ad</span>
<span class=3D"code-line odd">0000010    0000    0000    0008    0000</span=
>
<span class=3D"code-line even">0000018</span></div><!-- end code -->
                    </section><!-- end subsection -->
                    <section class=3D"subsection">
                        <h3>Summary</h3>
                        <p>Congratulations! This is the first step towards =
building an operating system. We learned about the boot process, the GRUB b=
ootloader, and the Multiboot specification. We wrote a Multiboot-compliant =
header file in assembly code, and used <tt>nasm</tt> to create an object fi=
le from it.</p>
                        <p>Next, we'll write the actual code that prints "H=
ello world" to the screen. Let's go!</p>
                    </section><!-- end subsection -->
                </div><!-- end content -->
            </section><!-- end page -->
           =20
            <section class=3D"page">
                <div class=3D"div-title-wrapper"><span class=3D"go-top"><a =
href=3D"https://users.cs.utah.edu/~aburtsev/238P/hw/hw4-boot-into-c/hw4-boo=
t-into-c.html#top">Top</a></span><h2 class=3D"title" toc=3D"Hello, World!" =
id=3D"4" style=3D"display: inline; border-style: none;">Hello, World!</h2><=
/div>
                <div class=3D"content">
                    <section class=3D"subsection">
                        <p>Now that we've got the headers out of the way, l=
et's do the traditional first program: Hello, world!</p>
                        <h3>The smallest kernel</h3>
                        <p>Our hello world will be just <b>20</b> lines of =
assembly code. But let's begin with something even shorter. Open a file cal=
led <tt>boot.asm</tt> and put this in it:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd entry">start:</span>
<span class=3D"code-line even">    hlt</span></div><!-- end code -->
                        <p>As you know already, <tt>start:</tt> is a label.=
 GRUB uses this conventional label to know where to begin.</p>
                        <p>The <tt>hlt</tt> statement is our first bit of '=
real' assembly. So far, we had just been declaring data. This is actual, ex=
ecutable code. It's short for 'halt'. In other words, it ends the program.<=
/p>
                        <p>By giving this line a label, we can call it, sor=
t of like a function. That's what GRUB does: "Call the function named <tt>s=
tart</tt>." This function has just one line: stop.</p>
                        <p>Unlike many other languages, you'll notice that =
there's no way to say if this 'function' takes any arguments or not. We'll =
talk more about that later.</p>
                        <p>This code won't quite work on its own though. We=
 need to do a little bit more bookkeeping first. Here's the next few lines:=
</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">global start</span>
<span class=3D"code-line even"></span>
<span class=3D"code-line odd">section .text</span>
<span class=3D"code-line even">bits 32</span>
<span class=3D"code-line odd entry">start:</span>
<span class=3D"code-line even">    hlt</span></div><!-- end code -->
                        <p>Three new bits of information. The first, <tt>gl=
obal start</tt>, says "I'm going to define a label <tt>start</tt>, and I wa=
nt it to be available outside of this file." If we don't say this, GRUB won=
't know where to find its definition. You can kind of think of it like a 'p=
ublic' annotation in other languages.</p>
                        <p>Then we have <tt>section .text</tt>. We saw <tt>=
section</tt> briefly, but I told you we'd get to it later. The place where =
we get to it is at the end of this chapter. For the moment, all you need to=
 know is this: code goes into a section named <tt>.text</tt>. Everything th=
at comes after the <tt>section</tt> line is "inside that section", until an=
other <tt>section</tt> line appears.</p>
                        <p>Following, we have <tt>bits 32</tt>. GRUB will b=
oot us into protected mode, aka 32-bit mode (similar to how xv6 bootloader =
starts in 16-bit real mode GRUB will be loaded by the BIOS and will switch =
into protected 32-bit  mode for us). But we have to specify directly that a=
ssembler has to generate 32bit code. Our Hello World will only be in 32 bit=
s.</p>
                    </section><!-- end subsection -->
                    <section class=3D"subsection">
                        <h3>Finally Printing</h3>
                        <p>We could theoretically stop here, but instead, l=
et's actually print the "Hello world" text to the screen. We'll start off w=
ith an 'H':</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">global start </span>
<span class=3D"code-line even">section .text</span>
<span class=3D"code-line odd">bits 32</span>
<span class=3D"code-line even entry">start:</span>
<span class=3D"code-line odd">    <span class=3D"warning">mov word [0xb8000=
], 0x0248</span> <span class=3D"comment">; H</span></span>
<span class=3D"code-line even">    hlt</span></div><!-- end code -->
                        <p>This new line is the most complicated bit of ass=
embly we've seen yet. There's a lot packed into this little line.</p>
                        <p>The first important bit is <tt>mov</tt>. This is=
 short for <tt>move</tt>, and it sorta looks like this:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">mov size place, thing</span></div><!-- end code -->
                        <p>Oh, and <tt>;</tt> starts a comment, remember? S=
o the <tt>; H</tt> is just for us. I put this comment here because this lin=
e prints an <tt>H</tt> to the screen!</p>
                        <p>Yup, it does. Okay, so here's why: <tt>mov</tt> =
copies <tt>thing</tt> into <tt>place</tt>. The amount of stuff it copies is=
 determined by <tt>size</tt>.</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd"><span class=3D"comment">;   size place      thing</span></span>
<span class=3D"code-line even"><span class=3D"comment">;   |    |          =
|</span></span>
<span class=3D"code-line odd"><span class=3D"comment">;   V    V          V=
</span></span>
<span class=3D"code-line even">mov word [0xb8000], 0x0248 <span class=3D"co=
mment">; H</span></span></div><!-- end code -->
                        <p>Then, the previous instruction is saying: "Copy =
one word: the number <tt>0x0248</tt> to some place".</p>
                        <p>The <tt>place</tt> looks like a number just like=
 <tt>0x0248</tt>, but it has square  brackets <tt>[]</tt> around it. Those =
brackets are special. They mean "the address  in memory located by this num=
ber." In other words, we're copying the number <tt>0x0248</tt> into the spe=
cific memory location <tt>0xb8000</tt>. That's what this line does.</p>
                        <p>Why? Well, we're using the screen as a "memory m=
apped" device. Specific positions in memory correspond to certain positions=
 on the screen. And the position <tt>0xb8000</tt> is one of those positions=
: the upper-left corner of the screen.</p>
                        <div class=3D"msg note">
                            <h3>by the way...</h3>
                            <div class=3D"body">
                                <p>"Memory mapping" is one of the fundament=
al techniques used in computer engineering to help the CPU know how to talk=
 to all the different physical components of a computer. The CPU itself is =
just a weird little machine that moves numbers around. It's not of any use =
to humans on its own: it needs to be connected to devices like RAM, hard dr=
ives, a monitor, and a keyboard.</p>
                                <p>The way the CPU does this is through a <=
b>bus</b>, which is a huge amount of wires connecting the CPU to every sing=
le device that might have data the CPU needs. There's one wire per bit (sin=
ce a wire can carry a 1 or a 0 at any given time). A 32-bit bus is literall=
y 32 wires in parallel that run from the CPU to a bunch of devices like a w=
eird Christmas lights around a house.</p>
                                <p>There are two buses that we really care =
about in a computer: the address bus and the data bus. There's also a third=
 signal that lets all the devices know whether the CPU is requesting data f=
rom an input (reading, like from the keyboard) or sending data to an output=
 (writing, like to the monitor via the video card). The address bus is for =
the CPU to send location information, and the data bus is for the CPU to ei=
ther write data to or read data from that location.</p>
                                <p>Every device on the computer has a uniqu=
e hard coded numerical location, or "address", literally determined by how =
the thing is wired up at the factory. In the case of an input/read operatio=
n, when the CPU sends <tt>0x1001A003</tt> out on the address bus and the co=
ntrol signal notifies every device that it's a read operation, it's asking,=
 <b>What is the data currently stored at location <tt>0x1001A003</tt>?</b> =
If the keyboard happens to be identified by that particular address, and th=
e user is pressing SPACE at this time, the keyboard says, <b>Oh, you're tal=
king to me!</b> and sends back the SPACE ASCII code <tt>0x00000020</tt> on =
the data bus.</p>
                                <p>What this means is that memory on a comp=
uter isn't just representing things like RAM and your hard drive. Actual hu=
man-scale devices like the keyboard and mouse and video card have their own=
 memory locations too. But instead of writing a byte to a hard drive for st=
orage, the CPU might write a byte representing some color and symbol to the=
 monitor for display. There's an industry standard somewhere that says vide=
o memory must live in the address range beginning <tt>0xb8000</tt>. In orde=
r for computers to be able to work out of the box, this means that the BIOS=
 needs to be manufactured to assume video lives at that location, and the m=
otherboard (which is where the bus is all wired up) has to be manufactured =
to route a <tt>0xb8000</tt> request to the video card.  It's kind of amazin=
g that this stuff works at all! Anyway, "memory mapped hardware", or "memor=
y mapping" for short, is the name of this technique.</p>
                            </div>
                        </div><!-- end msg -->
                        <p>Now, we are copying <tt>0x0248</tt>. Why this nu=
mber? Well, it's in three parts:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">=E2=94=8C=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=80=E2=94=
=80background color</span>
<span class=3D"code-line even">=E2=94=82 =E2=94=8C=E2=94=80=E2=94=80=E2=94=
=80=E2=94=80=E2=94=80foreground color</span>
<span class=3D"code-line odd">=E2=94=82 =E2=94=82 =E2=94=8C=E2=94=80=E2=94=
=AC=E2=94=80=E2=94=80letter, in ASCII</span>
<span class=3D"code-line even">=E2=94=82 =E2=94=82 =E2=94=82 =E2=94=82</spa=
n>
<span class=3D"code-line odd">0 2 4 8</span></div><!-- end code -->
                        <p>Let's start at the right. The last, two numbers =
are the letter, in ASCII. <tt>H</tt> is 72 in ASCII, and 48 is 72 in hexade=
cimal: <tt>(4 * 16) + 8 =3D 72</tt>. So this will write <tt>H</tt>.</p>
                        <p>The other two numbers are colors. There are 16 c=
olors available, each with a number. Here's the table:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">| Value | Color          |</span>
<span class=3D"code-line even">|-------|----------------|</span>
<span class=3D"code-line odd">| 0x0   | black          |</span>
<span class=3D"code-line even">| 0x1   | blue           |</span>
<span class=3D"code-line odd">| 0x2   | green          |</span>
<span class=3D"code-line even">| 0x3   | cyan           |</span>
<span class=3D"code-line odd">| 0x4   | red            |</span>
<span class=3D"code-line even">| 0x5   | magenta        |</span>
<span class=3D"code-line odd">| 0x6   | brown          |</span>
<span class=3D"code-line even">| 0x7   | gray           |</span>
<span class=3D"code-line odd">| 0x8   | dark gray      |</span>
<span class=3D"code-line even">| 0x9   | bright blue    |</span>
<span class=3D"code-line odd">| 0xA   | bright green   |</span>
<span class=3D"code-line even">| 0xB   | bright cyan    |</span>
<span class=3D"code-line odd">| 0xC   | bright red     |</span>
<span class=3D"code-line even">| 0xD   | bright magenta |</span>
<span class=3D"code-line odd">| 0xE   | yellow         |</span>
<span class=3D"code-line even">| 0xF   | white          |</span></div><!-- =
end code -->
                        <p>So, <tt>02</tt> is a black background with a gre=
en foreground. Classic. Feel free to change this up, use whatever combinati=
on of colors you want!</p>
                        <p>So this gives us a <tt>H</tt> in green, over bla=
ck. Next letter: <tt>e</tt>.</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">global start </span>
<span class=3D"code-line even">section .text</span>
<span class=3D"code-line odd">bits 32</span>
<span class=3D"code-line even entry">start:</span>
<span class=3D"code-line odd">    mov word [0xb8000], 0x0248 <span class=3D=
"comment">; H</span></span>
<span class=3D"code-line even">    mov word [0xb8002], 0x0265 <span class=
=3D"comment">; e</span></span>
<span class=3D"code-line odd">    hlt</span></div><!-- end code -->
                        <p>Lower case <tt>e</tt> is <tt>65</tt> in ASCII, a=
t least, in hexadecimal. And <tt>02</tt> is our same color code. But you'll=
 notice that the memory location is different.</p>
                        <p>Okay, so we copied four hexadecimal digits into =
memory, right? For our <tt>H</tt>. <tt>0248</tt>. A hexadecimal digit has s=
ixteen values, which is 4 bits (for example, <tt>0xf</tt> would be represen=
ted in bits as <tt>1111</tt>). Two of them make 8 bits, i.e. one byte. Sinc=
e we need half a word for the colors (<tt>02</tt>), and half a word for the=
 <tt>H</tt> (<tt>48</tt>), that's one word in total (or two bytes). Each pl=
ace that the memory address points to can hold one byte (a.k.a. 8 bits or h=
alf a word). Hence, if our first memory position is at <tt>0</tt>, the seco=
nd letter will start at <tt>2</tt>.</p>
                        <div class=3D"msg note">
                            <div class=3D"body">
                                <p>You might be wondering, "If we're in 32 =
bit mode, isn't a word 32 bits?" since sometimes 'word' is used to talk abo=
ut native CPU register size. Well, the 'word' keyword in the context of x86=
_64 assembly specifically refers to 2 bytes, or 16 bits of data.  This is f=
or reasons of backwards compatibility.</p>
                            </div>
                        </div><!-- end msg -->
                        <p>This math gets easier the more often you do it. =
And we won't be doing <b>that</b> much more of it. There is a lot of workin=
g with hex numbers in operating systems work, so you'll get better as we pr=
actice.</p>
                        <p>With this, you should be able to get the rest of=
 Hello, World. Go ahead and try if you want: each letter needs to bump the =
location twice, and you need to look up the letter's number in hex.</p>
                        <p>If you don't want to bother with all that, here'=
s the final code:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">global start </span>
<span class=3D"code-line even">section .text</span>
<span class=3D"code-line odd">bits 32</span>
<span class=3D"code-line even entry">start:</span>
<span class=3D"code-line odd">    mov word [0xb8000], 0x0248 <span class=3D=
"comment">; H</span></span>
<span class=3D"code-line even">    mov word [0xb8002], 0x0265 <span class=
=3D"comment">; e</span></span>
<span class=3D"code-line odd">    mov word [0xb8004], 0x026c <span class=3D=
"comment">; l</span></span>
<span class=3D"code-line even">    mov word [0xb8006], 0x026c <span class=
=3D"comment">; l</span></span>
<span class=3D"code-line odd">    mov word [0xb8008], 0x026f <span class=3D=
"comment">; o</span></span>
<span class=3D"code-line even">    mov word [0xb800a], 0x022c <span class=
=3D"comment">; ,</span></span>
<span class=3D"code-line odd">    mov word [0xb800c], 0x0220 <span class=3D=
"comment">;</span></span>
<span class=3D"code-line even">    mov word [0xb800e], 0x0277 <span class=
=3D"comment">; w</span></span>
<span class=3D"code-line odd">    mov word [0xb8010], 0x026f <span class=3D=
"comment">; o</span></span>
<span class=3D"code-line even">    mov word [0xb8012], 0x0272 <span class=
=3D"comment">; r</span></span>
<span class=3D"code-line odd">    mov word [0xb8014], 0x026c <span class=3D=
"comment">; l</span></span>
<span class=3D"code-line even">    mov word [0xb8016], 0x0264 <span class=
=3D"comment">; d</span></span>
<span class=3D"code-line odd">    mov word [0xb8018], 0x0221 <span class=3D=
"comment">; !</span></span>
<span class=3D"code-line even">    hlt</span></div><!-- end code -->
                        <p>Finally, now that we've got all of the code work=
ing, we can assemble our <tt>boot.asm</tt> file with <tt>nasm</tt>, just li=
ke we did with the <tt>multiboot_header.asm</tt> file:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd entry">$ nasm -f elf32 -g -F dwarf boot.asm</span></div><!-- end code -=
->
                        <p>This will produce a <tt>boot.o</tt> file. We're =
almost ready to go!</p>
                    </section><!-- end subsection -->
                </div><!-- end content -->
            </section><!-- end page -->
           =20
            <section class=3D"page">
                <div class=3D"div-title-wrapper"><span class=3D"go-top"><a =
href=3D"https://users.cs.utah.edu/~aburtsev/238P/hw/hw4-boot-into-c/hw4-boo=
t-into-c.html#top">Top</a></span><h2 class=3D"title" toc=3D"Linking" id=3D"=
5" style=3D"display: inline; border-style: none;">Linking it Together</h2><=
/div>
                <div class=3D"content">
                    <section class=3D"subsection">
                        <p>Okay! So we have two different <tt>.o</tt> files=
: <tt>multiboot_header.o</tt> and <tt>boot.o</tt>. But what we need is <b>o=
ne</b> file with both of them. Our OS doesn't have the ability to do anythi=
ng yet, let alone load itself in two parts somehow. We just want one big bi=
nary file. Linking is how we'll turn these two files into a single output: =
by linking them together.</p>
                        <p>Open up a file called <tt>linker.ld</tt>and put =
this in it:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">ENTRY(start)</span>
<span class=3D"code-line even entry"></span>
<span class=3D"code-line odd">SECTIONS {</span>
<span class=3D"code-line even">    /* Tells GRUB to load the kernel startin=
g at the 1MB mark */</span>
<span class=3D"code-line odd">    . =3D 0x100000;</span>
<span class=3D"code-line even entry"></span>
<span class=3D"code-line odd">    .rodata :</span>
<span class=3D"code-line even">    {</span>
<span class=3D"code-line odd">        /* ensure that the multiboot header i=
s at the beginning */</span>
<span class=3D"code-line even">        KEEP(*(.multiboot_header))</span>
<span class=3D"code-line odd">        *(.rodata .rodata.*) </span>
<span class=3D"code-line even">        . =3D ALIGN(4K);</span>
<span class=3D"code-line odd">    }</span>
<span class=3D"code-line even entry"></span>
<span class=3D"code-line odd">    .text :</span>
<span class=3D"code-line even">    { </span>
<span class=3D"code-line odd">        *(.text .text.*)</span>
<span class=3D"code-line even">        . =3D ALIGN(4K);</span>
<span class=3D"code-line odd">    } </span>
<span class=3D"code-line even entry"></span>
<span class=3D"code-line odd">    .data :</span>
<span class=3D"code-line even">    { </span>
<span class=3D"code-line odd">        *(.data .data.*)</span>
<span class=3D"code-line even">        . =3D ALIGN(4K);</span>
<span class=3D"code-line odd">    }   </span>
<span class=3D"code-line even entry"></span>
<span class=3D"code-line odd">    .bss :</span>
<span class=3D"code-line even">    {   </span>
<span class=3D"code-line odd">        *(.bss .bss.*)</span>
<span class=3D"code-line even">        . =3D ALIGN(4K);</span>
<span class=3D"code-line odd">    }     </span>
<span class=3D"code-line even">}</span></div><!-- end code -->
                        <p>This is a 'linker script'. It controls how our l=
inker will combine these files into the final output. Let's take it bit-by-=
bit:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">ENTRY(start)</span></div><!-- end code -->
                        <p>This line sets the 'entry point' for this execut=
able. In our case, we called our entry point by the name people use: <tt>st=
art</tt>. Remember? In <tt>boot.asm</tt>? Same name here.</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">SECTIONS {</span>
<span class=3D"code-line even">  ...</span>
<span class=3D"code-line odd">}</span></div><!-- end code -->
                        <p>Okay! I've been promising you that we'd talk abo=
ut sections. Everything inside of these curly braces is a section. We annot=
ated parts of our code with sections earlier, and here, in this part of the=
 linker script, we will describe each section by name and where it goes in =
the resulting output.</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">. =3D 0x100000;</span></div><!-- end code -->
                        <p>This line means that we will start putting secti=
ons at the one megabyte mark. This is the conventional place to put a kerne=
l, at least to start. Below one megabyte is all kinds of memory-mapped stuf=
f. Remember the VGA stuff? It wouldn't work if we mapped our kernel's code =
to that part of memory... garbage on the screen!</p>
                       =20
                        <!-- <div class=3D"code" lang=3D"text"> -->
                        <!--      .boot : -->
                        <!--      </div><\!-- end code -\-> -->
                        <!-- <p>This will create a section named <tt>boot</=
tt>. And inside of it...</p> -->
                        <!-- <div class=3D"code" lang=3D"text"> -->
                        <!--     *(.multiboot_header) -->
                        <!-- </div><\!-- end code -\-> -->
                       =20
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">.rodata :</span></div><!-- end code -->
                        <p>This will create a "read only" section named <tt=
>rodata</tt>. And inside of it...</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">*(.multiboot_header)</span></div><!-- end code -->
                        <p>... goes every section named <tt>multiboot_heade=
r</tt>. Remember how we defined that section in <tt>multiboot_header.asm</t=
t>? It'll be here, at the start of the <tt>rodata</tt> section. That's what=
 we need for GRUB to see it.</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">.text :</span></div><!-- end code -->
                        <p>Next, we define a <tt>text</tt> section. The <tt=
>text</tt> section is where you put code. And inside of it...</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">*(.text)</span></div><!-- end code -->
                        <p>... goes every section named <tt>text</tt>. See =
how this is working? The syntax is a bit weird, but it's not too bad. We do=
 the same for the <tt>code</tt> and <tt>bss</tt> section. That's it for our=
 script! We can then use the tool <tt>ld</tt> to link all of this stuff tog=
ether:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd entry">$ ld -m elf_i386 -T linker.ld -o kernel.bin multiboot_header.o b=
oot.o</span></div><!-- end code -->
                        <p>By running this command, we do a few things: <tt=
>-m elf_i386</tt> ask the linker to generate the 32bit. <tt>-T linker.ld</t=
t> tells the linker to use the script we just made. <tt>-o kernel.bin</tt> =
sets the name of our output file. In our case, that's <tt>kernel.bin</tt>. =
We'll be using this file in the next step. It's our whole kernel!. Finally,=
 <tt>multiboot_header.o boot.o</tt> are the object files that we want to li=
nk together.</p>
                        <p>That's it! We've now got our kernel in the <tt>k=
ernel.bin</tt> file. Next, we're going to make an ISO out of it, so that we=
 can load it up in QEMU.</p>
                    </section><!-- end subsection -->
                </div><!-- end content -->
            </section><!-- end page -->
           =20
            <section class=3D"page">
                <div class=3D"div-title-wrapper"><span class=3D"go-top"><a =
href=3D"https://users.cs.utah.edu/~aburtsev/238P/hw/hw4-boot-into-c/hw4-boo=
t-into-c.html#top">Top</a></span><h2 class=3D"title" toc=3D"Making an ISO" =
id=3D"6" style=3D"display: inline; border-style: none;">Making an ISO</h2><=
/div>
                <div class=3D"content">
                    <section class=3D"subsection">
                        <p>Now that we have our <tt>kernel.bin</tt>, the ne=
xt step is to make an ISO. Remember compact discs? Well, by making an ISO f=
ile, we can both test our Hello World kernel in QEMU, as well as running it=
 on actual hardware!</p>
                        <p>To do this, we're going to use a GRUB tool calle=
d <tt>grub2-mkrescue</tt>. We have to create a certain structure of files o=
n disk, run the tool, and we'll get an <tt>hello.iso</tt> file at the end.<=
/p>
                        <p>Doing so is not very much work, but we need to p=
ut the files in the right places. First, we need to make several directorie=
s and copy the provided <tt>grub.cfg</tt> file:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd entry">$ mkdir -p build/isofiles/boot/grub</span>
<span class=3D"code-line even entry">$ cp grub.cfg build/isofiles/boot/grub=
/</span></div><!-- end code -->
                        <p>The <tt>-p</tt> flag to <tt>mkdir</tt> will make=
 the directory we specify, as well as any 'parent' directories, hence the <=
tt>p</tt>. In other words, this will make an <tt>build</tt> directory with =
a <tt>isofiles</tt> directory inside that has <tt>boot</tt> inside, and fin=
ally the <tt>grub</tt> directory inside of that. Then we copy the <tt>grub.=
cfg</tt> file. It should look like this:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">set timeout=3D0</span>
<span class=3D"code-line even">set default=3D0</span>
<span class=3D"code-line odd entry"></span>
<span class=3D"code-line even">menuentry "cs238pOS" {</span>
<span class=3D"code-line odd">    multiboot2 /boot/kernel.bin</span>
<span class=3D"code-line even">    boot</span>
<span class=3D"code-line odd">}</span></div><!-- end code -->
                        <p>This file configures GRUB. Let's talk about the =
<tt>menuentry</tt> block first. GRUB lets us load up multiple different ope=
rating systems, and it usually does this by displaying a menu of OS choices=
 to the user when the machine boots. Each <tt>menuentry</tt> section corres=
ponds to one of these. We give it a name, in this case, <tt>cs238pOS</tt>, =
and then a little script to tell it what to do. First, we use the <tt>multi=
boot2</tt> command to point at our kernel file. In this case, that location=
 is <tt>/boot/kernel.bin</tt>. Remember how we made a <tt>boot</tt> directo=
ry inside of <tt>isofiles</tt>? Since we're making the ISO out of the <tt>i=
sofiles</tt> directory, everything inside of it is at the root of our ISO. =
Hence <tt>/boot</tt>.</p>
                        <p>Let's copy our <tt>kernel.bin</tt> file there no=
w:</p>

                        <div class=3D"code fancy"><span class=3D"code-line =
odd entry">$ cp kernel.bin build/isofiles/boot/</span></div><!-- end code -=
->

                        <p>Finally, the <tt>boot</tt> command says "that's =
all the configuration we need to do,
                            boot it up."</p>

                        <p>But what about those <tt>timeout</tt> and <tt>de=
fault</tt> settings? Well, the <tt>default</tt> setting controls which <tt>=
menuentry</tt> we want to be the default. The numbers start at zero, and si=
nce we only have that one, we set it as the default. When GRUB starts, it w=
ill wait for <tt>timeout</tt> seconds, and then choose the <tt>default</tt>=
 option if the user didn't pick a different one. Since we only have one opt=
ion here, we just set it to zero, so it will start up right away.</p>=20
                        <p>The final layout should look like this:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">build/</span>
<span class=3D"code-line even">=E2=94=94=E2=94=80isofiles/</span>
<span class=3D"code-line odd">  =E2=94=9C=E2=94=80boot</span>
<span class=3D"code-line even">  =E2=94=82 =E2=94=94=E2=94=80grub</span>
<span class=3D"code-line odd">  =E2=94=82   =E2=94=94=E2=94=80grub.cfg</spa=
n>
<span class=3D"code-line even">  =E2=94=94=E2=94=80kernel.bin</span></div><=
!-- end code -->
                        <p>Using <tt>grub2-mkrescue</tt> is easy. We run th=
is command:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd entry">$ grub2-mkrescue -o hello.iso build/isofiles</span></div><!-- en=
d code -->
                        <p>The <tt>-o</tt> flag controls the <b>o</b>utput =
filename, which we choose to be <tt>hello.iso</tt>. And then we pass it the=
 directory to make the ISO out of, which is the <tt>build/isofiles</tt> dir=
ectory we just set up. If you get an error like <tt>grub2-mkrescue: error: =
xorriso not found.</tt>, that means your system does not have the package <=
tt>xorriso</tt> installed.</p>
                        <p>After this, if everything went well, we will hav=
e a <tt>hello.iso</tt> file with our teeny kernel on it. You could put this=
 on a USB stick, or burn it on a CD and run it on an actual computer if you=
 wanted to! But doing so would be really annoying during development. So in=
 the next section, we'll use an emulator, QEMU, to run the ISO file on our =
development machine.</p>
                    </section><!-- end subsection -->
                </div><!-- end content -->
            </section><!-- end page -->
           =20
            <section class=3D"page">
                <div class=3D"div-title-wrapper"><span class=3D"go-top"><a =
href=3D"https://users.cs.utah.edu/~aburtsev/238P/hw/hw4-boot-into-c/hw4-boo=
t-into-c.html#top">Top</a></span><h2 class=3D"title" toc=3D"Running in QEMU=
" id=3D"7" style=3D"display: inline; border-style: none;">Running in QEMU</=
h2></div>
                <div class=3D"content">
                    <section class=3D"subsection">
                        <p>Let's actually run our kernel! To do this, we'll=
 use <a href=3D"http://www.qemu.org/">QEMU</a>, a full-system emulator. Usi=
ng QEMU is fairly straightfoward. If you're running on openlab you can't re=
ally connect to  the GUI application, so we'll use <tt>-curses</tt>:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd entry">$ qemu-system-x86_64 <span class=3D"warning">-curses</span> -cdr=
om hello.iso</span></div><!-- end code -->
                        <p>To exit, type <tt class=3D"key">Alt</tt> + <tt c=
lass=3D"key">2</tt> (or <tt class=3D"key">Esc</tt> + <tt class=3D"key">2</t=
t>), type <tt>q</tt> (or <tt>quit</tt>) in the console; and then <tt class=
=3D"key">Enter</tt></p>
                        <p>If you're running on your own machine you can si=
mply run:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd entry">$ qemu-system-x86_64 -cdrom hello.iso</span></div><!-- end code =
-->
                        <p>To exit in Linux (maybe Windows too); type <tt c=
lass=3D"key">Ctrl</tt> + <tt class=3D"key">Alt</tt> + <tt class=3D"key">q</=
tt> in the window that popped out.</p>
                        <p>If everything went well, congrats! you should se=
e <tt>Hello, world!</tt>. If not, something may have gone wrong. Double che=
ck that you followed the examples <b>exactly</b>. Maybe you missed somethin=
g, or made a mistake while copying things down.</p>
                        <p>Note that you may see other stuff behind the Hel=
lo World message, this part may vary based on your version of GRUB, and als=
o since we didn't clear the screen, everything from GRUB just stays as it i=
s. We'll write a function to do that eventually...</p>
                        <p>Let's talk about the command <tt>qemu-system-x86=
_64</tt> before we move on. We're running the <tt>x86_64</tt> variant of QE=
MU. While we have a 32-bit kernel  the QEMU emulates x86 64bit architecture=
. And since 32bit code is part of it everything works. We're going to start=
 QEMU with a CD-ROM drive, <tt>-cdrom</tt>, and its contents are the <tt>he=
llo.iso</tt> file we made.</p>
                        <p>That's it! Here's the thing, though: while that =
wasn't <b>too</b> complicated, it was a lot of steps. Each time we make a c=
hange, we have to go through all these steps over again. In the next sectio=
n, we'll use Make to do all these steps for us.</p>
                    </section><!-- end subsection -->
                </div><!-- end content -->
            </section><!-- end page -->
           =20
            <section class=3D"page">
                <div class=3D"div-title-wrapper"><span class=3D"go-top"><a =
href=3D"https://users.cs.utah.edu/~aburtsev/238P/hw/hw4-boot-into-c/hw4-boo=
t-into-c.html#top">Top</a></span><h2 class=3D"title" toc=3D"Automation with=
 Make" id=3D"8" style=3D"display: inline; border-style: none;">Automation w=
ith Make</h2></div>
                <div class=3D"content">
                    <section class=3D"subsection">
                        <p>Typing all of these commands out every time we w=
ant to build the project is tiring and error-prone. It's nice to be able to=
 have a single command that builds our entire project. To do this, we'll us=
e the tool <tt>make</tt> and our downloaded <tt>Makefile</tt>.</p>
                        <p>To make this Makefile working move create boot f=
older in the same directory as Makefile and put previously created grub.cfg=
 into boot folder.</p>
                        <p>The makefile starts by defining several variable=
s <tt>kernel</tt>, <tt>iso</tt>, <tt>linker_script</tt>, and <tt>grub_cfg</=
tt> that define names of the output files we want to make. <tt>CFLAGS</tt> =
is a variable that defines all flags to the GCC compiler. <tt>QEMU_...</tt>=
 are variables that define different flags passed to calls to qemu.</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">kernel :=3D build/kernel.bin</span>
<span class=3D"code-line even">iso :=3D build/hello.iso</span>
<span class=3D"code-line odd">linker_script :=3D linker.ld</span>
<span class=3D"code-line even">grub_cfg :=3D grub.cfg</span>
<span class=3D"code-line odd"></span>
<span class=3D"code-line even">CFLAGS =3D -fno-pic -static -fno-builtin -fn=
o-strict-aliasing -O1 -Wall -MD -ggdb -m32 -fno-omit-frame-pointer -Werror =
-nostdlib</span>
<span class=3D"code-line odd"></span>
<span class=3D"code-line even">QEMU_FLAGS  =3D -cdrom $(iso) -vga std -seri=
al file:serial.log</span>
<span class=3D"code-line odd">QEMU_GDB    =3D -gdb tcp::1234 -S -m 128 -no-=
reboot -no-shutdown -d int,cpu_reset</span>
<span class=3D"code-line even">QEMU_CURSES =3D -curses</span>
<span class=3D"code-line odd"><span class=3D"comment"># QEMU_NOX    =3D -no=
graphic</span></span></div><!-- end code -->
                        <p>We then create two lists: a list of assembly fil=
es in the variable <tt>assembly_source_files</tt> and a list of C source fi=
les, <tt>c_source_files</tt>. We then use the <tt>patsubst</tt> command to =
generate another two lists that are the same file names but in the folder <=
tt>build</tt>, and with <tt>.o</tt> as extension:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">assembly_source_files :=3D $(wildcard *.asm)</span>
<span class=3D"code-line even">c_source_files :=3D $(wildcard *.c)</span>
<span class=3D"code-line odd">assembly_object_files :=3D $(patsubst %.asm, =
build/%.o, $(assembly_source_files))</span>
<span class=3D"code-line even">c_object_files :=3D $(patsubst %.c, build/%.=
o, $(c_source_files))</span></div><!-- end code -->
                        <p>Then whe add all the targets:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd"><span class=3D"comment"># regardless of the state of files, make will =
always run these targets</span></span>
<span class=3D"code-line even"><span class=3D"entry">.PHONY</span>: all cle=
an qemu qemu-gdb qemu-nox qemu-gdb-nox iso kernel</span>
<span class=3D"code-line odd"></span>
<span class=3D"code-line even"><span class=3D"comment">#default target (the=
 first one in the Makefile)</span></span>
<span class=3D"code-line odd"><span class=3D"entry">all</span>: $(iso)</spa=
n>
<span class=3D"code-line even"></span>
<span class=3D"code-line odd"><span class=3D"comment"># remove all "compile=
-time-generated" files.</span></span>
<span class=3D"code-line even"><span class=3D"entry">clean:</span></span>
<span class=3D"code-line odd">    rm -r build</span>
<span class=3D"code-line even"></span>
<span class=3D"code-line odd"><span class=3D"comment"># CONVENIENT TARGETS =
TO RUN QEMU WITH DIFFERENT OPTIONS</span></span>
<span class=3D"code-line even"><span class=3D"comment"># basic run</span></=
span>
<span class=3D"code-line odd"><span class=3D"entry">qemu</span>: $(iso)</sp=
an>
<span class=3D"code-line even">    qemu-system-x86_64 $(QEMU_FLAGS) $(QEMU_=
CURSES) $(QEMU_NOX)</span>
<span class=3D"code-line odd"></span>
<span class=3D"code-line even"><span class=3D"comment"># run with debug opt=
ions</span></span>
<span class=3D"code-line odd"><span class=3D"entry">qemu-gdb</span>: $(iso)=
</span>
<span class=3D"code-line even">    qemu-system-x86_64 $(QEMU_FLAGS) $(QEMU_=
CURSES) $(QEMU_NOX) $(QEMU_GDB)</span>
<span class=3D"code-line odd"></span>
<span class=3D"code-line even"></span>
<span class=3D"code-line odd"><span class=3D"comment"># TARGETS THAT ACTUAL=
LY BUILD NEW FILES</span></span>
<span class=3D"code-line even"><span class=3D"comment"># target "iso" will =
print "Done" once the prerequisites are fulfilled</span></span>
<span class=3D"code-line odd"><span class=3D"entry">iso</span>: $(iso)</spa=
n>
<span class=3D"code-line even">    @echo "Done"</span>
<span class=3D"code-line odd"></span>
<span class=3D"code-line even"><span class=3D"comment"># create file define=
d in variable "iso"</span></span>
<span class=3D"code-line odd"><span class=3D"entry">$(iso)</span>: $(kernel=
) $(grub_cfg)</span>
<span class=3D"code-line even">    @mkdir -p build/isofiles/boot/grub</span=
>
<span class=3D"code-line odd">    cp $(kernel) build/isofiles/boot/kernel.b=
in</span>
<span class=3D"code-line even">    cp $(grub_cfg) build/isofiles/boot/grub<=
/span>
<span class=3D"code-line odd">    grub2-mkrescue -o $(iso) build/isofiles <=
span class=3D"comment">#2&gt; /dev/null</span></span>
<span class=3D"code-line even">    @rm -r build/isofiles</span>
<span class=3D"code-line odd"></span>
<span class=3D"code-line even"><span class=3D"comment"># create file define=
d in variable "kernel"</span></span>
<span class=3D"code-line odd"><span class=3D"entry">$(kernel)</span>: $(c_o=
bject_files) $(assembly_object_files) $(linker_script)</span>
<span class=3D"code-line even">    ld -m elf_i386  -T $(linker_script) -o $=
(kernel) $(assembly_object_files) $(c_object_files)</span>
<span class=3D"code-line odd"></span>
<span class=3D"code-line even"><span class=3D"comment"># compile any C file=
</span></span>
<span class=3D"code-line odd"><span class=3D"entry">build/%.o</span>: %.c</=
span>
<span class=3D"code-line even">    @mkdir -p $(shell dirname $@)</span>
<span class=3D"code-line odd">    gcc $(CFLAGS) -c $&lt; -o $@</span>
<span class=3D"code-line even"></span>
<span class=3D"code-line odd"><span class=3D"comment"># compile any assembl=
y file</span></span>
<span class=3D"code-line even"><span class=3D"entry">build/%.o</span>: %.as=
m</span>
<span class=3D"code-line odd">    @mkdir -p $(shell dirname $@)</span>
<span class=3D"code-line even">    nasm -felf32 -g -F dwarf $&lt; -o $@</sp=
an></div><!-- end code -->
                        <p>First, the notation <tt>$(var)</tt> expands to t=
he content of the variable <tt>var</tt>. For example, in our Makefile, <tt>=
$(iso)</tt> expands to <tt>build/hello.iso</tt>.</p>
                        <p>Makefiles are mainly a collection of <b>rules</b=
> to "make a target" or to "do an action". When we call <tt>make</tt> we ei=
ther specify a target, an action, or just take the default one (which is th=
e first defined in the file).</p>
                        <p>Targets are files that we want to create, the na=
me of the target is the actual name of the file. Actions are things that we=
 want to do that doesn't necesarely produce a file. The "rules" I just ment=
ioned have the following shape (note that before each command there must be=
 a tab <tt>\t</tt> character):</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd"><span class=3D"comment"># you can add some comment about the rule</spa=
n></span>
<span class=3D"code-line even"><span class=3D"entry">target/action</span> :=
 dependencies ...</span>
<span class=3D"code-line odd">    command</span>
<span class=3D"code-line even">    ...</span>
<span class=3D"code-line odd">    ...</span></div><!-- end code -->
                        <p>At the right side of the <tt>:</tt> symbol, we h=
ave the <b>dependencies</b> of this target, they are "what has to be presen=
t and updated" <b>before</b> running the <b>command</b>s associated with th=
e rule. If a dependency is <b>not</b> updated, then <tt>make</tt> searches =
for some other rule in the Makefile that could create/update the outdated d=
ependency. Only when all dependencies are updated, <tt>make</tt> runs the c=
ommands associated with the rule. For example, in our Makefile, the action =
<tt>iso</tt> requires the file <tt>build/hello.iso</tt> to be presest and u=
pdated.</p>
                        <p>This "search and update the dependency" behavior=
 is recursive, so if a dependency has a rule with an outdated dependency, <=
tt>make</tt> will go deeper and deeper until it gets to the source files th=
at you are editing. Therefore, if you make a change in a source file, <tt>m=
ake</tt> detects it, and when called, it will update all the dependencies t=
hat were affected by your editions. Neat!</p>
                        <p>On the other hand, if nothing has changed in the=
 dependencies since the last time <tt>make</tt> ran, <tt>make</tt> knows th=
at there is nothing new to do and does not run the <b>command</b>s because =
everythitg is up to date. That is great, because we will not recompile code=
 that did not change. On big projects that can save many hours!.</p>
                        <p>It's convenient to define actions to automatize =
some tasks: to run our kernel in qemu, we added the rules <tt>qemu</tt> and=
 <tt>qemu-gdb</tt>. To clean all the "compile-time-generated" files, we add=
ed the rule <tt>clean</tt>. This is useful when you want to prepare to make=
 a full re-build from scratch, what we will do when grading your work.</p>
                        <p>One last thing, given the smart "run-the-rule-on=
ly-when-needed" behavior of <tt>make</tt>, there is one little problem: the=
re are some <b>actions</b> that we want to perform every time we request it=
 to <tt>make</tt>, no matter if files have changed or not. You can list tho=
se "always-run" targets/actions on the special target <tt>.PHONY</tt>.</p>
                    </section><!-- end subsection -->
                </div><!-- end content -->
            </section><!-- end page -->
           =20
            <section class=3D"page">
                <div class=3D"div-title-wrapper"><span class=3D"go-top"><a =
href=3D"https://users.cs.utah.edu/~aburtsev/238P/hw/hw4-boot-into-c/hw4-boo=
t-into-c.html#top">Top</a></span><h2 class=3D"title" toc=3D"Paging" id=3D"9=
" style=3D"display: inline; border-style: none;">Paging</h2></div>
                <div class=3D"content">
                    <section class=3D"subsection">
                        <p>Up until now we did a lot of work that wasn't ac=
tually writing kernel code. So let's review what we're up to:</p>
                        <ol>
                            <li>GRUB loaded our kernel, and started running=
 it.</li>
                            <li>We're currently running in 'protected mode'=
, a 32-bit environment.</li>
                            <li>We want to enable paging.</li>
                            <li>We want to create a stack and jump into <tt=
>main</tt>.</li>
                        </ol>
                        <p>We're on step three. More specifically, here's w=
hat we have to do:</p>
                        <ol>
                            <li>Set up something called 'paging'.</li>
                            <li>Set up something called a 'GDT'.</li>
                            <li>Call into main.</li>
                        </ol>
                        <p>Paging is actually implemented by a part of the =
CPU called an 'MMU', for 'memory management unit'. The MMU will translate v=
irtual addresses into their respective physical addresses automatically; we=
 can write all of our software with virtual addresses only. The MMU does th=
is with a data structure called a 'page table'. As an operating system, we =
load up the page table with a certain data structure, and then tell the CPU=
 to enable paging. This is the task ahead of us; it's required to set up pa=
ging before we transition to long mode.</p>
                        <p>How should we do our mapping of physical to virt=
ual addresses? You can make this easy, or complex, and it depends on exactl=
y what you want your OS to be good at. Some strategies are better than othe=
rs, depending on the kinds of programs you expect to be running. We're goin=
g to keep it simple, and use a strategy called 'identity mapping'. This mea=
ns that every virtual address will map to a physical address of the same nu=
mber. Nothing fancy.</p>
                        <p>Let's talk more about the page table. In 32bit m=
ode, the page table is two levels deep, and each page is 4096 bytes in size=
. What do I mean by levels? Here are the official names:</p>
                        <ul>
                            <li>Page-Directory Table (PD)</li>
                            <li>Page Table (PT)</li>
                        </ul>
                        <p>So here's the strategy to accomplish that: creat=
e a single entry of each of these tables, then point them at each other in =
the correct way, then tell the CPU that paging should be enabled.</p>
                    </section><!-- end subsection -->
                    <section class=3D"subsection">
                        <h3>Creating the page table entries</h3>
                        <p>To create space for these page table entries, op=
en up <tt>boot.asm</tt> and add these lines at the bottom:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">section .bss</span>
<span class=3D"code-line even"></span>
<span class=3D"code-line odd">align 4096</span>
<span class=3D"code-line even"></span>
<span class=3D"code-line odd entry">pt_table:</span>
<span class=3D"code-line even">    resb 4096</span>
<span class=3D"code-line odd entry">ptd_table:</span>
<span class=3D"code-line even">    resb 4096</span></div><!-- end code -->
                        <p>We introduce a new section, 'bss'. It stands for=
 'block started by symbol', and was introduced in the 1950s. The name doesn=
't make much sense anymore, but the reason we use it is because of its beha=
vior: entries in the bss section are automatically set to zero by the linke=
r. This is useful, as we only want certain bits set to 1, and most of them =
set to zero.</p>
                        <p>The <tt>resb</tt> directive reserves bytes; we w=
ant to reserve space for each entry.</p>
                        <p>The <tt>align</tt> directive makes sure that we'=
ve aligned our tables properly. We haven't talked much about alignment yet:=
 the idea is that the addresses here will be set to a multiple of 4096, hen=
ce 'aligned' to 4096 byte chunks. We'll eventually talk more about alignmen=
t and why it's important, but it doesn't matter a ton right now.</p>
                        <p>After this has been added, we have a single vali=
d entry for each level. However, because they are all zeroes, we have no va=
lid pages. That's not super useful. Let's set things up properly.</p>
                       =20
                        <h3>Pointing the entries at each other</h3>
                        <p>In order to do this setup, we need to write some=
 more assembly code! Open up <tt>boot.asm</tt>. You can either leave in pri=
nting code, or remove it. If you do leave it in, add this code before it: t=
hat way, if you see your message print out, you know it ran successfully.</=
p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">global start</span>
<span class=3D"code-line even"></span>
<span class=3D"code-line odd">section .text</span>
<span class=3D"code-line even">bits 32</span>
<span class=3D"code-line odd entry">start:</span>
<span class=3D"code-line even">    <span class=3D"comment">; map first PTD =
entry to PT table</span></span>
<span class=3D"code-line odd">    mov eax, pt_table</span>
<span class=3D"code-line even">    or eax, 0b11 <span class=3D"comment">; p=
resent + writable</span></span>
<span class=3D"code-line odd">    mov [ptd_table], eax</span></div><!-- end=
 code -->
                        <p>If you recall, <tt>;</tt> are comments. Leaving =
yourself excessive comments in assembly files is a good idea. Let's go over=
 each of these lines:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">    mov eax, pt_table</span></div><!-- end code -->
                        <p>This copies the contents of the first page table=
 entry into the <tt>eax</tt> register. We need to do this because of the ne=
xt line:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">    or eax, 0b11</span></div><!-- end code -->
                        <p>We take the contents of <tt>eax</tt> and <tt>or<=
/tt> it with the number <tt>0b11</tt>, the result is written in <tt>eax</tt=
>. Each entry in a page table contains an address, but it also contains met=
adata about that page. The first two bits are the 'present bit' and the 'wr=
itable bit'. By setting the first bit, we say "this page is currently in me=
mory," and by setting the second, we say "this page is allowed to be writte=
n to." There are a number of other settings we can change this way, but the=
y're not important for now.</p>
                        <div class=3D"msg note">
                            <h3>by the way...</h3>
                            <div class=3D"body">
                                <p>You might be wondering, if the entry in =
the page table is an address, how can we use some of the bits of that addre=
ss to store metadata without messing up the address? Remember that we used =
the <tt>align</tt> directive to make sure that the page tables all have add=
resses that are multiples of 4096. That means that the CPU can assume that =
the first 12 bits of all the addresses are zero. If they're always implicit=
ly zero, we can use them to store metadata without changing the address.</p=
>
                            </div>
                        </div><!-- end msg -->
                        <p>Now that we have an entry set up properly, the n=
ext line is of interest:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">    mov dword [ptd_table + 0], eax</span></div><!-- end code -->
                        <p>Another <tt>mov</tt> instruction, but this time,=
 copying <tt>eax</tt>, where we've been setting things up, into... somethin=
g in brackets. <tt>[]</tt> means, "I will be giving you an address between =
the brackets. Please do something at the place this address points." In oth=
er words, <tt>[]</tt> is like a dereference operator.</p>
                        <p>Now, the address we've put is kind of funny look=
ing: <tt>ptd_table + 0</tt>. What's up with that <tt>+ 0</tt>? It's not str=
ictly needed: adding zero to something keeps it the same. However, it's int=
ended to convey to the reader that we're accessing the zeroth entry in the =
page table. We're about to see some more code later where we will do someth=
ing other than add zero, and so putting it here makes our code look more sy=
mmetric overall. If you don't like this style, you don't have to put the ze=
ro.</p>
                        <p>These few lines form the core of how we're setti=
ng up these page tables. We're going to do the same thing over again, with =
slight variations.</p>
                        <p>Here's the full thing again:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">    <span class=3D"comment">; map first PTD entry to PT table</span></=
span>
<span class=3D"code-line even">    mov eax, pt_table</span>
<span class=3D"code-line odd">    or eax, 0b11 <span class=3D"comment">; pr=
esent + writable</span></span>
<span class=3D"code-line even">    mov [ptd_table], eax</span></div><!-- en=
d code -->

                        <p>We have one last thing to do: set up the level t=
wo page table to have valid references to pages. We're going to do somethin=
g we haven't done yet in assembly: write a loop!</p>
                        <p>Here's the basic outline of loop in assembly:</p=
>
                        <ul>
                            <li>Create a counter variable to track how many=
 times we've looped</li>
                            <li>make a label to define where the loop start=
s</li>
                            <li>do the body of the loop</li>
                            <li>add one to our counter</li>
                            <li>check to see if our counter is equal to the=
 number of times we want to loop</li>
                            <li>if it's not, jump back to the top of the lo=
op</li>
                            <li>if it is, we're done</li>
                        </ul>

                        <p>It's a little more detail-oriented than loops in=
 other languages. Usually, you have curly braces or indentation to indicate=
 that the body of the loop is separate, but we don't have any of those thin=
gs here. We also have to write the code to increment the counter, and check=
 if we're done. Lots of little fiddly bits. But that's the nature of what w=
e're doing! Let's get to it!</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">    <span class=3D"comment">; map each P1 entry to a 4KB page</span></=
span>
<span class=3D"code-line even">    mov ecx, 0         <span class=3D"commen=
t">; counter variable</span></span>
<span class=3D"code-line odd"></span>
<span class=3D"code-line even">.map_pt_table:</span>
<span class=3D"code-line odd">    <span class=3D"comment">; map ecx-th PT e=
ntry to a huge page that starts at address 4KB*ecx</span></span>
<span class=3D"code-line even">    mov eax, 0x1000    <span class=3D"commen=
t">; 4KB</span></span>
<span class=3D"code-line odd">    mul ecx            <span class=3D"comment=
">; start address of ecx-th page</span></span>
<span class=3D"code-line even">    or eax, 0b00000011 <span class=3D"commen=
t">; present + writable</span></span>
<span class=3D"code-line odd">    mov [pt_table + ecx * 4], eax <span class=
=3D"comment">; map ecx-th entry</span></span>
<span class=3D"code-line even"></span>
<span class=3D"code-line odd">    inc ecx            <span class=3D"comment=
">; increase counter</span></span>
<span class=3D"code-line even">    cmp ecx, 1024      <span class=3D"commen=
t">; if counter =3D=3D 1024, the whole P1 table is mapped</span></span>
<span class=3D"code-line odd">    jne .map_pt_table  <span class=3D"comment=
">; else map the next entry</span></span></div><!-- end code -->
                        <p>In order to write a loop, we need a counter. <tt=
>ecx</tt> is the usual loop counter register, that's what the <tt>c</tt> st=
ands for: counter. We also have a comment indicating what we're doing in th=
is part of the code.</p>
                        <p>Next, we need to make a new label:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">.map_pt_table:</span></div><!-- end code -->
                        <p>As we mentioned above, this is where we will loo=
p back to when the loop continues.</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">    mov eax, 0x1000</span></div><!-- end code -->
                        <p>We're going to store 0x1000 in <tt>eax</tt>, or =
4096 which is 4KB.   Here's the reason: each page is 4KB in size. So in ord=
er to get the  right memory location, we will multiply the number of the lo=
op counter by 0x1000</p>
                        <p>Here's that multiplication! <tt>mul</tt> takes j=
ust one argument, which in this case is our <tt>ecx</tt> counter, and multi=
plies that by <tt>eax</tt>, storing the result in <tt>eax</tt>. This will b=
e the location of the next page.</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">    or eax, 0b00000011</span></div><!-- end code -->
                        <p>Next up, our friend <tt>or</tt>. Here, we again =
set present and writable bits <tt>0b11</tt>.</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">    mov [pt_table + ecx * 4], eax</span></div><!-- end code -->
                        <p>Just like before, we are now writing the value i=
n <tt>eax</tt> to a location. But instead of it being just <tt>pt_table + 0=
</tt>, we're adding <tt>ecx * 4</tt>. Remember, <tt>ecx</tt> is our loop co=
unter. Each entry is four bytes in size, so we need to multiply the counter=
 by four, and then add it to <tt>pt_table</tt>.</p>
                        <p>That's the body of the loop! Now we need to see =
if we need to keep looping or not:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">    inc ecx</span>
<span class=3D"code-line even">    cmp ecx, 1024</span>
<span class=3D"code-line odd">    jne .map_pt_table</span></div><!-- end co=
de -->
                        <p>The <tt>inc</tt> instruction increments the regi=
ster it's given by one. <tt>ecx</tt> is our loop counter, so we're adding t=
o it. Then, we 'compare' with <tt>cmp</tt>. We're comparing <tt>ecx</tt> wi=
th 1024: we want to map 1024 page entries overall. The page table is 4096 b=
ytes, each entry is 4 bytes, so that means there are 1024 entries. This wil=
l give us 1024 * 4KB: four megabytes of memory. It's also why we wrote the =
loop: writing out 1024 entries by hand is possible, theoretically, but is n=
ot fun. Let's make the computer do the math for us.</p>
                        <p>The <tt>jne</tt> instruction is short for 'jump =
if not equal'. It checks the result of the <tt>cmp</tt>, and if the compari=
son says 'not equal', it will jump to the label we've defined. <tt>map_pt_t=
able</tt> points to the top of the loop.</p>
                        <p>That's it! We've written our loop and mapped our=
 second-level page table. Here's the full code, all in one place:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">    <span class=3D"comment">; map first PTD entry to PT table</span></=
span>
<span class=3D"code-line even">    mov eax, pt_table</span>
<span class=3D"code-line odd">    or eax, 0b11 <span class=3D"comment">; pr=
esent + writable</span></span>
<span class=3D"code-line even">    mov [ptd_table + 0], eax</span>
<span class=3D"code-line odd"></span>
<span class=3D"code-line even">    <span class=3D"comment">; map each P1 en=
try to a 4KB page</span></span>
<span class=3D"code-line odd">    mov ecx, 0         <span class=3D"comment=
">; counter variable</span></span>
<span class=3D"code-line even"></span>
<span class=3D"code-line odd">.map_pt_table:</span>
<span class=3D"code-line even">    <span class=3D"comment">; map ecx-th PT =
entry to a huge page that starts at address 4KB*ecx</span></span>
<span class=3D"code-line odd">    mov eax, 0x1000    <span class=3D"comment=
">; 4KB</span></span>
<span class=3D"code-line even">    mul ecx            <span class=3D"commen=
t">; start address of ecx-th page</span></span>
<span class=3D"code-line odd">    or eax, 0b00000011 <span class=3D"comment=
">; present + writable</span></span>
<span class=3D"code-line even">    mov [pt_table + ecx * 4], eax <span clas=
s=3D"comment">; map ecx-th entry</span></span>
<span class=3D"code-line odd"></span>
<span class=3D"code-line even">    inc ecx            <span class=3D"commen=
t">; increase counter</span></span>
<span class=3D"code-line odd">    cmp ecx, 1024      <span class=3D"comment=
">; if counter =3D=3D 1024, the whole P1 table is mapped</span></span>
<span class=3D"code-line even">    jne .map_pt_table  <span class=3D"commen=
t">; else map the next entry</span></span></div><!-- end code -->
                        <p>Now that we've done this, we have a valid initia=
l page table. Time to enable paging!</p>
                    </section><!-- end subsection -->
                    <section class=3D"subsection">
                        <h3>Enable paging</h3>
                        <p>Now that we have a valid page table, we need to =
inform the hardware about it. Here's the steps we need to take:</p>
                        <ul>
                            <li>We have to put the address of the page tabl=
e directory in a special register</li>
                            <li>enable paging</li>
                        </ul>
                        <p>These steps are not particularly interesting, bu=
t we have to do them. First, let's do the first step:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">    <span class=3D"comment">; move page table address to cr3</span></s=
pan>
<span class=3D"code-line even">    mov eax, ptd_table</span>
<span class=3D"code-line odd">    mov cr3, eax</span></div><!-- end code --=
>
                        <p>So, this might seem a bit redundant: if we put <=
tt>ptd_table</tt> into <tt>eax</tt>, and then put <tt>eax</tt> into <tt>cr3=
</tt>, why not just put <tt>ptd_table</tt> into <tt>cr3</tt>? As it turns o=
ut, <tt>cr3</tt> is a special register, called a 'control register', hence =
the <tt>cr</tt>. The <tt>cr</tt> registers are special: they control how th=
e CPU actually works. In our case, the <tt>cr3</tt> register needs to hold =
the location of the page table.</p>
                        <p>Because it's a special register, it has some res=
trictions, and one of those is that when you <tt>mov</tt> to <tt>cr3</tt>, =
it has to be from another register. So we need the first <tt>mov</tt> to se=
t <tt>p4_table</tt> in a register before we can set <tt>cr3</tt>.</p>
                        <p>Step one: done!</p>
                        <p>Finally we are all ready to enable paging!</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">    <span class=3D"comment">; enable paging</span></span>
<span class=3D"code-line even">    mov eax, cr0</span>
<span class=3D"code-line odd">    or eax, 1 &lt;&lt; 31</span>
<span class=3D"code-line even">    mov cr0, eax</span></div><!-- end code -=
->
                        <p><tt>cr0</tt> is the register we need to modify. =
We do the usual "move to <tt>eax</tt>, set some bits, move back to the regi=
ster" pattern. In this case, we set bit 31.</p>
                        <p>Once we've set these bits, we're done! Here's th=
e full code listing:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">    <span class=3D"comment">; move page table address to cr3</span></s=
pan>
<span class=3D"code-line even">    mov eax, ptd_table</span>
<span class=3D"code-line odd">    mov cr3, eax</span>
<span class=3D"code-line even">    </span>
<span class=3D"code-line odd">    <span class=3D"comment">; enable paging</=
span></span>
<span class=3D"code-line even">    mov eax, cr0</span>
<span class=3D"code-line odd">    or eax, 1 &lt;&lt; 31</span>
<span class=3D"code-line even">    mov cr0, eax</span></div><!-- end code -=
->
                    </section><!-- end subsection -->
                </div><!-- end content -->
            </section><!-- end page -->
           =20
            <section class=3D"page">
                <div class=3D"div-title-wrapper"><span class=3D"go-top"><a =
href=3D"https://users.cs.utah.edu/~aburtsev/238P/hw/hw4-boot-into-c/hw4-boo=
t-into-c.html#top">Top</a></span><h2 class=3D"title" toc=3D"Setting up a GD=
T" id=3D"10" style=3D"display: inline; border-style: none;">Setting up a GD=
T</h2></div>
                <div class=3D"content">
                    <section class=3D"subsection">
                        <p>The GDT is used for a style of memory handling c=
alled 'segmentation', which is in contrast to the paging model that we just=
 set up. Even though we're not using segmentation, however, we're still req=
uired to have a valid GDT. Such is life.</p>
                        <p>So let's set up a minimal GDT. Our GDT will have=
 three entries:</p>
                        <ul>
                        <li>a 'zero entry'</li>
                        <li>a 'code segment'</li>
                        <li>a 'data segment'</li>
                        </ul>
                        <p>If we were going to be using the GDT for real st=
uff, it could have a number of code and data segment entries. But we need a=
t least one of each to have a minimum viable table, so let's get to it!</p>
                    </section><!-- end subsection -->
                    <section class=3D"subsection">
                        <h3>The Zero entry</h3>
                        <p>The first entry in the GDT is special: it needs =
to be a zero value. Add this to the bottom of <tt>boot.asm</tt>:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">section .rodata</span>
<span class=3D"code-line even entry">gdt_start: <span class=3D"comment">; d=
on't remove the labels, they're needed to compute sizes and jumps</span></s=
pan>
<span class=3D"code-line odd">    <span class=3D"comment">; the GDT starts =
with a null 8-byte</span></span>
<span class=3D"code-line even">    dd 0x0 <span class=3D"comment">; 4 byte<=
/span></span>
<span class=3D"code-line odd">    dd 0x0 <span class=3D"comment">; 4 byte</=
span></span></div><!-- end code -->
                        <p>We have a new section: <tt>rodata</tt>. This sta=
nds for 'read only data', and since we're not going to modify our GDT, havi=
ng it be read-only is a good idea.</p>
                        <p>Next, we have a label: <tt>gdt_start</tt>. We'll=
 use this label later, to tell the hardware where our GDT is located.</p>
                        <p>Finally, <tt>dd 0</tt>. This defines a  'doublew=
ord' value, in other words, a 32-bit value. Given that it's a zero entry, i=
t shouldn't be too surprising that the value of this entry is zero!</p>
                        <p>That's all there is to it.</p>
                    </section><!-- end subsection -->
                    <section class=3D"subsection">
                        <h3>Setting up code and data segments</h3>
                        <p>Next, we need a code segment. Add this below the=
 zero entry that you created above.</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd"><span class=3D"comment">; GDT for code segment. base =3D 0x00000000, l=
ength =3D 0xfffff</span></span>
<span class=3D"code-line even"><span class=3D"comment">; for flags, refer t=
o os-dev.pdf document, page 36</span></span>
<span class=3D"code-line odd entry">gdt_code:</span>
<span class=3D"code-line even">    dw 0xffff    <span class=3D"comment">; s=
egment length, bits 0-15</span></span>
<span class=3D"code-line odd">    dw 0x0       <span class=3D"comment">; se=
gment base, bits 0-15</span></span>
<span class=3D"code-line even">    db 0x0       <span class=3D"comment">; s=
egment base, bits 16-23</span></span>
<span class=3D"code-line odd">    db 10011010b <span class=3D"comment">; fl=
ags (8 bits)</span></span>
<span class=3D"code-line even">    db 11001111b <span class=3D"comment">; f=
lags (4 bits) + segment length, bits 16-19</span></span>
<span class=3D"code-line odd">    db 0x0       <span class=3D"comment">; se=
gment base, bits 24-31</span></span></div><!-- end code -->
                        <p>Here we carefully follow the layout of the segme=
nt descriptor to make  sure that all flags are set correctly (the exact lay=
out can be found in the  Intel Developer's Manual, 3.4.5). It would be nice=
 to use a human-friendly macro  like xv6 does, but I'm not good with macros=
 in NASM.</p>=20
                        <p>Similar, we define the data segment.</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd"><span class=3D"comment">; GDT for data segment. base and length identi=
cal to code segment</span></span>
<span class=3D"code-line even"><span class=3D"comment">; some flags changed=
, again, refer to os-dev.pdf</span></span>
<span class=3D"code-line odd entry">gdt_data:</span>
<span class=3D"code-line even">    dw 0xffff</span>
<span class=3D"code-line odd">    dw 0x0</span>
<span class=3D"code-line even">    db 0x0</span>
<span class=3D"code-line odd">    db 10010010b</span>
<span class=3D"code-line even">    db 11001111b</span>
<span class=3D"code-line odd">    db 0x0</span>
<span class=3D"code-line even"></span>
<span class=3D"code-line odd entry">gdt_end:</span></div><!-- end code -->
                        <p>Finally, we have to define the GDT descriptor, t=
he special data structure that  defines the size of the GDT and has a point=
er to it in memory. We compute the  size as the difference between two labe=
ls: <tt>gdt_end</tt> and <tt>gdt_start</tt>. The pointer itself is the valu=
e of the label where GDT starts, i.e., <tt>gdt_start</tt>.</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd"><span class=3D"comment">; GDT descriptor</span></span>
<span class=3D"code-line even entry">gdt_descriptor:</span>
<span class=3D"code-line odd">    dw gdt_end - gdt_start - 1 <span class=3D=
"comment">; size (16 bit), always one less of its true size</span></span>
<span class=3D"code-line even">    dd gdt_start <span class=3D"comment">; a=
ddress (32 bit)</span></span></div><!-- end code -->

                        <p>Finally, lets define two constants for the code =
and data segments that we can load in registers</p>

                        <div class=3D"code fancy"><span class=3D"code-line =
odd"><span class=3D"comment">; define some constants for later use</span></=
span>
<span class=3D"code-line even">CODE_SEG equ gdt_code - gdt_start</span>
<span class=3D"code-line odd">DATA_SEG equ gdt_data - gdt_start</span></div=
><!-- end code -->

                        <p>Note that here since each descriptor was 8 bytes=
 long the code segment is defined as 0x8 and  the data segment is 0x16. Thi=
s is exactly what we want since the first 3 bits of the  segment selector (=
3.4.2 in the Intel SDM) are used for flags.</p>
                        <p>Now we can add this code somewhere at the top to=
 make sure that all segment registers  are initialized correctly.</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd"><span class=3D"comment">; load 0 into all data segment registers</span=
></span>
<span class=3D"code-line even">mov ax, DATA_SEG</span>
<span class=3D"code-line odd">mov ss, ax</span>
<span class=3D"code-line even">mov ds, ax</span>
<span class=3D"code-line odd">mov es, ax</span>
<span class=3D"code-line even">mov fs, ax</span>
<span class=3D"code-line odd">mov gs, ax</span></div><!-- end code -->
                    </section><!-- end subsection -->
                    <section class=3D"subsection">
                        <h3>Load the GDT</h3>
                        <p>So! We're finally ready to tell the hardware abo=
ut our GDT. Add this line right <b>above</b> the code that initializes the =
data segment registers:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">    lgdt [gdt_descriptor]</span></div><!-- end code -->
                        <p>We pass <tt>lgdt</tt> the value of our <tt>gdt_d=
escriptor</tt> label. <tt>lgdt</tt> stands for 'load global descriptor tabl=
e'. That's it!</p>
                        <p>We have all of the prerequisites done! In the ne=
xt section, we will complete our boot sequence by entering <tt>main()</tt>.=
</p>
                    </section><!-- end subsection -->
                </div><!-- end content -->
            </section><!-- end page -->
           =20
            <section class=3D"page">
                <div class=3D"div-title-wrapper"><span class=3D"go-top"><a =
href=3D"https://users.cs.utah.edu/~aburtsev/238P/hw/hw4-boot-into-c/hw4-boo=
t-into-c.html#top">Top</a></span><h2 class=3D"title" toc=3D"Calling main()"=
 id=3D"11" style=3D"display: inline; border-style: none;">Setting the Stack=
 and calling <tt>main()</tt></h2></div>
                <div class=3D"content">
                    <section class=3D"subsection">
                        <p>Now we're one step away from calling the <tt>mai=
n</tt> function. We need to set up  the stack. First, lets reserve 4096 byt=
es (one page) for the stack in the BSS section of  the <tt>boot.asm</tt> fi=
le:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd entry">stack_bottom:</span>
<span class=3D"code-line even">    resb 4096 * 4 <span class=3D"comment">; =
Reserve this many bytes</span></span>
<span class=3D"code-line odd entry">stack_top:</span></div><!-- end code --=
>
                        <p>Now we can load the address of the stack into th=
e <tt>esp</tt> register and call the main function:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">    mov esp, stack_top</span>
<span class=3D"code-line even">    call main</span></div><!-- end code -->
                        <p>We need to let the assembler know that <tt>main<=
/tt> will be defined in a different object file (we'll compile it from <tt>=
main.c</tt>). For that we need to add this line right at the top of <tt>boo=
t.asm</tt></p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">extern main</span></div><!-- end code -->
                    </section><!-- end subsection -->
                    <section class=3D"subsection">
                        <h3>Compiling main()</h3>
                        <p>Use the skeletons that you already downloaded: <=
tt>main.c</tt>, <tt>console.c</tt>, and <tt>console.h</tt>. A minimal <tt>m=
ain()</tt> function can look something like this:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">#include "console.h"</span>
<span class=3D"code-line even">int main(void){</span>
<span class=3D"code-line odd">    <span class=3D"comment">// Initialize the=
 console</span></span>
<span class=3D"code-line even">    uartinit(); </span>
<span class=3D"code-line odd">    printk("Hello from C\n");</span>
<span class=3D"code-line even">    return 0; </span>
<span class=3D"code-line odd">}</span></div><!-- end code -->
                        <p>It calls the <tt>uartinit()</tt> function to ini=
tialize the serial line and then prints "Hello from C" on the serial line. =
Serial ports are a legacy communications port common on IBM-PC compatible c=
omputers. Use of serial ports for connecting peripherals has largely been d=
eprecated in favor of USB and other modern peripheral interfaces, however i=
t is still commonly used in certain industries for interfacing with industr=
ial hardware such as CNC machines or commercial devices such as POS termina=
ls. Historically it was common for many dial-up modems to be connected via =
a computer's serial port, and the design of the underlying UART hardware it=
self reflects this. </p>
                        <p>Serial ports are typically controlled by UART ha=
rdware. This is the hardware chip responsible for encoding and decoding the=
 data sent over the serial interface. Modern serial ports typically impleme=
nt the RS-232 standard, and can use a variety of different connector interf=
aces. The DE-9 interface is the one most commonly used connector for serial=
 ports in modern systems.</p>
                        <p>Serial ports are of particular interest to opera=
ting-system developers since they are much easier to implement drivers for =
than USB, and are still commonly found in many x86 systems. It is common fo=
r operating-system developers to use a system's serial ports for debugging =
purposes, since they do not require sophisticated hardware setups and are u=
seful for transmitting information in the early stages of an operating-syst=
em's initialization. Many emulators such as QEMU and Bochs allow the redire=
ction of serial output to either stdio or a file on the host computer.</p>
                        <div class=3D"msg note">
                            <h3>by the way...</h3>
                            <div class=3D"body">
                                <p>Why Use a Serial Port? During the early =
stages of kernel development, you might wonder why you would bother writing=
 a serial driver. There are several reasons why you might:</p>
                                <ul>
                                    <li><b>GDB debugging</b> You can use th=
e serial port to connect to a host computer, and use the GDB debugger to de=
bug your operating system. This involves writing a stub for GDB within your=
 OS.</li>
                                    <li><b>Headless console</b> You can ope=
rate the computer without a monitor, keyboard or mouse and instead use the =
serial port as a console using a protocol such as TTY or VT100.</li>
                                    <li><b>External logging</b> When the sy=
stem itself is in danger of potentially crashing at times, it's nice to get=
 debugging outputs safe to another computer before the test system triple-f=
aults.</li>
                                    <li><b>Networking and File transfers</b=
> Serial ports are useful for transferring information between systems when=
 other more traditional methods are unavailable.</li>
                                </ul>
                            </div>
                        </div><!-- end msg -->
                    </section><!-- end subsection -->
                </div><!-- end content -->
            </section><!-- end page -->
           =20
            <section class=3D"page">
                <div class=3D"div-title-wrapper"><span class=3D"go-top"><a =
href=3D"https://users.cs.utah.edu/~aburtsev/238P/hw/hw4-boot-into-c/hw4-boo=
t-into-c.html#top">Top</a></span><h2 class=3D"title" toc=3D"Serial Line Dri=
ver" id=3D"12" style=3D"display: inline; border-style: none;">Serial Line D=
river</h2></div>
                <div class=3D"content">
                    <section class=3D"subsection">
                        <p>To print something on the serial line we need to=
 implement a minimal serial line driver. In this homework assignment we pro=
vide you a simple serial driver in <tt>console.c</tt>. It still makes sense=
 for you to look over the page that describes the details of the serial lin=
e protocol in <a href=3D"https://wiki.osdev.org/Serial_Ports">osdev.org</a>=
.</p>
                        <p> At a high level we define which I/O port serial=
 line is connected to:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">#define COM1    0x3f8</span></div><!-- end code -->
                        <p>We then use a couple of helper functions that pr=
ovide the interface to assembly <tt>in</tt> and <tt>out</tt> instructions.<=
/p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">static inline unsigned char inb(unsigned short port){</span>
<span class=3D"code-line even">    unsigned char data;</span>
<span class=3D"code-line odd">    asm volatile("in %1,%0" : "=3Da" (data) :=
 "d" (port));</span>
<span class=3D"code-line even">    return data;</span>
<span class=3D"code-line odd">}</span>
<span class=3D"code-line even entry"></span>
<span class=3D"code-line odd">static inline void outb(unsigned short port, =
unsigned char data){</span>
<span class=3D"code-line even">    asm volatile("out %0,%1" : : "a" (data),=
 "d" (port));</span>
<span class=3D"code-line odd">}</span></div><!-- end code -->

                        <p>We then use the <tt>uartinit()</tt> function to =
initialize the serial line interface</p>

                        <div class=3D"code fancy"><span class=3D"code-line =
odd">void uartinit(void){</span>
<span class=3D"code-line even entry"></span>
<span class=3D"code-line odd">    <span class=3D"comment">// Turn off the F=
IFO</span></span>
<span class=3D"code-line even">    outb(COM1+2, 0);</span>
<span class=3D"code-line odd entry"></span>
<span class=3D"code-line even">    <span class=3D"comment">// 9600 baud, 8 =
data bits, 1 stop bit, parity off.</span></span>
<span class=3D"code-line odd">    outb(COM1+3, 0x80);    <span class=3D"com=
ment">// Unlock divisor</span></span>
<span class=3D"code-line even">    outb(COM1+0, 115200/115200);</span>
<span class=3D"code-line odd">    outb(COM1+1, 0); </span>
<span class=3D"code-line even">    outb(COM1+3, 0x03);    <span class=3D"co=
mment">// Lock divisor, 8 data bits.</span></span>
<span class=3D"code-line odd">    outb(COM1+4, 0);</span>
<span class=3D"code-line even">    outb(COM1+1, 0x01);    <span class=3D"co=
mment">// Enable receive interrupts.</span></span>
<span class=3D"code-line odd">    </span>
<span class=3D"code-line even">    <span class=3D"comment">// If status is =
0xFF, no serial port.</span></span>
<span class=3D"code-line odd">    if(inb(COM1+5) =3D=3D 0xFF)</span>
<span class=3D"code-line even">        return;</span>
<span class=3D"code-line odd">    </span>
<span class=3D"code-line even">    uart =3D 1;</span>
<span class=3D"code-line odd entry"></span>
<span class=3D"code-line even">    <span class=3D"comment">// Acknowledge p=
re-existing interrupt conditions;</span></span>
<span class=3D"code-line odd">    <span class=3D"comment">// enable interru=
pts.</span></span>
<span class=3D"code-line even">    inb(COM1+2);</span>
<span class=3D"code-line odd">    inb(COM1+0);</span>
<span class=3D"code-line even">}</span></div><!-- end code -->
                        <p>The <tt>uartputc()</tt> displays an individual c=
haracter on the screen</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">void uartputc(int c){</span>
<span class=3D"code-line even">    int i;</span>
<span class=3D"code-line odd">    if(!uart)</span>
<span class=3D"code-line even">        return;</span>
<span class=3D"code-line odd">    for(i =3D 0; i &lt; 128 &amp;&amp; !(inb(=
COM1+5) &amp; 0x20); i++)</span>
<span class=3D"code-line even">        microdelay(10);</span>
<span class=3D"code-line odd">    outb(COM1+0, c);</span>
<span class=3D"code-line even">}</span></div><!-- end code -->
                        <p>And finally the <tt>printk()</tt> function print=
s a string on the screen</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">void printk(char *str){</span>
<span class=3D"code-line even">    int i, c;</span>
<span class=3D"code-line odd">    for(i =3D 0; (c =3D str[i]) !=3D 0; i++){=
</span>
<span class=3D"code-line even">        uartputc(c);</span>
<span class=3D"code-line odd">    }</span>
<span class=3D"code-line even">}</span></div><!-- end code -->
                    </section><!-- end subsection -->
                </div><!-- end content -->
            </section><!-- end page -->
           =20
            <section class=3D"page">
                <div class=3D"div-title-wrapper"><span class=3D"go-top"><a =
href=3D"https://users.cs.utah.edu/~aburtsev/238P/hw/hw4-boot-into-c/hw4-boo=
t-into-c.html#top">Top</a></span><h2 class=3D"title" toc=3D"Booting into C"=
 id=3D"13" style=3D"display: inline; border-style: none;">Booting into C</h=
2></div>
                <div class=3D"content">
                    <section class=3D"subsection">
                        <p>Now we're finally ready to boot into C. There ar=
e three outputs produced by qemu that we care about:</p>
                        <ol class=3D"spaced">
                            <li>The serial line output</li>
                            <li>The VGA output</li>
                            <li>The qemu debugging console (do not confuse =
with the gdb console)</li>
                        </ol>
                        <p>The first one is already setup in the makefile t=
o be written in the <tt>serial.log</tt> file. The second one is a bit more =
complex, you see, this is a graphical output; there is a couple of alternat=
ives that we can control with the <tt>qemu</tt> flags <tt>-curses</tt> and =
<tt>-nographic</tt>. Let's review these two lines of our Makefile:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">QEMU_CURSES =3D -curses</span>
<span class=3D"code-line even"><span class=3D"comment"># QEMU_NOX    =3D -n=
ographic</span></span></div><!-- end code -->
                        <p>By un-commenting these variables, you will be ac=
tivating that flag for qemu (check the rules that use these variables). So,=
 activating:</p>
                        <ol class=3D"spaced">
                            <li><b>none</b> In your machine, it will pop ou=
t a window with the VGA output. In an environment without GUI (such as open=
lab) you will get an error.</li>
                            <li><b>only curses</b> The default config in th=
e Makefile. The VGA output is simulated using the <tt>curses</tt> interface=
, and printed in the screen.</li>
                            <li><b>curses and nox</b> The screen will only =
show the qemu debugging console. The curses-simulated output will be writte=
n in the <tt>serial.log</tt> file, along with the serial line output.</li>
                            <li><b>only nox</b> Exactly the same as <b>curs=
es and nox</b>.</li>
                        </ol>
                        <p>So, comment/uncomment these variables to your pr=
eferences, and if you put all the files in the correct places, you can run =
<tt>make qemu</tt> and get "Hello from C" in the <tt>serial.log</tt> file.<=
/p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd entry">$ make qemu</span></div><!-- end code -->
                    </section><!-- end subsection -->
                </div><!-- end content -->
            </section><!-- end page -->
           =20
            <section class=3D"page">
                <div class=3D"div-title-wrapper"><span class=3D"go-top"><a =
href=3D"https://users.cs.utah.edu/~aburtsev/238P/hw/hw4-boot-into-c/hw4-boo=
t-into-c.html#top">Top</a></span><h2 class=3D"title" toc=3D"Debugging with =
GDB" id=3D"14" style=3D"display: inline; border-style: none;">Debugging wit=
h GDB</h2></div>
                <div class=3D"content">
                    <section class=3D"subsection">
                        <p>Another intersting skill to learn while working =
on this homework is debugging kernels with GDB. To do this we will be using=
 GDB's <i>remote debugging</i> feature and QEMU's remote GDB debugging stub=
. Remote debugging is a very important technique for kernel development in =
general: the basic idea is that the main debugger (GDB in this case) runs s=
eparately from the program being debugged (the xv6 kernel atop QEMU) - they=
 could be on completely separate machines, in fact.</p>
                    </section><!-- end subsection -->
                    <section class=3D"subsection">
                        <h3>Finding and breaking at an address</h3>
                        For example, if you want to break at the very first=
 instruction of your kernel you can use <tt>readelf</tt> tool to see where =
this address is (remember the kernel is the same ELF file that you loaded i=
n your previous homework):
                        <div class=3D"code fancy"><span class=3D"code-line =
odd entry">$ readelf -h build/kernel.bin</span>
<span class=3D"code-line even">ELF Header:</span>
<span class=3D"code-line odd">  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 0=
0 00 00 00 00 </span>
<span class=3D"code-line even">  Class:                             ELF32</=
span>
<span class=3D"code-line odd">  Data:                              2's comp=
lement, little endian</span>
<span class=3D"code-line even">  Version:                           1 (curr=
ent)</span>
<span class=3D"code-line odd">  OS/ABI:                            UNIX - S=
ystem V</span>
<span class=3D"code-line even">  ABI Version:                       0</span=
>
<span class=3D"code-line odd">  Type:                              EXEC (Ex=
ecutable file)</span>
<span class=3D"code-line even">  Machine:                           Intel 8=
0386</span>
<span class=3D"code-line odd">  Version:                           0x1</spa=
n>
<span class=3D"code-line even">  <span class=3D"warning">Entry point addres=
s:               0x1010f0</span></span></div><!-- end code -->
                        <p>In this case, the entry point is <tt>0x1010f0</t=
t>. Now we can start QEMU with GDB and break at this address. Open two term=
inals, either using a terminal multiplexer like <a href=3D"https://linuxize=
.com/post/getting-started-with-tmux/"> tmux </a> or logging in to openlab i=
n another teminal. Run <tt> make qemu-gdb </tt> in the first terminal. This=
 will run the <tt>qemu-gdb</tt> target in the Makefile:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">QEMU_FLAGS  =3D -cdrom $(iso) -vga std -serial file:serial.log</span>
<span class=3D"code-line even">QEMU_GDB    =3D -gdb tcp::1234 -S -m 128 -no=
-reboot -no-shutdown -d int,cpu_reset</span>
<span class=3D"code-line odd">...</span>
<span class=3D"code-line even"><span class=3D"comment"># run with debug opt=
ions</span></span>
<span class=3D"code-line odd"><span class=3D"entry">qemu-gdb</span>: $(iso)=
</span>
<span class=3D"code-line even">    qemu-system-x86_64 $(QEMU_FLAGS) $(QEMU_=
CURSES) $(QEMU_NOX) $(QEMU_GDB)</span></div><!-- end code -->
                        <p>In the other terminal, change directory, and sta=
rt <tt>gdb</tt>.</p>
                        <div class=3D"side-by-side-code">
                            <div class=3D"code fancy"><span class=3D"code-l=
ine odd entry">$ cd <span class=3D"fg-blue">&lt;path_to_hw4&gt;</span></spa=
n>
<span class=3D"code-line even entry">$ make qemu-gdb</span></div><!-- end c=
ode -->
                            <div class=3D"code fancy"><span class=3D"code-l=
ine odd entry">$ cd <span class=3D"fg-blue">&lt;path_to_hw4&gt;</span></spa=
n>
<span class=3D"code-line even entry">$ gdb</span>
<span class=3D"code-line odd">GNU gdb (Ubuntu 8.1-0ubuntu3.2) 8.1.0.2018040=
9-git</span>
<span class=3D"code-line even">(...)</span>
<span class=3D"code-line odd">+ target remote localhost:1234</span>
<span class=3D"code-line even">warning: No executable has been specified an=
d target does not support</span>
<span class=3D"code-line odd">determining executable automatically.  Try us=
ing the "file" command.</span>
<span class=3D"code-line even"><span class=3D"warning"> 0x000000000000fff0 =
in ?? ()</span></span>
<span class=3D"code-line odd">+ symbol-file kernel</span>
<span class=3D"code-line even"><span class=3D"entry">(gdb)</span></span></d=
iv><!-- end code -->
                        </div>
                        <p>What you see on the screen is the assembly code =
of the BIOS that QEMU executes as part of the platform initialization. The =
BIOS starts at address <tt>0xfff0</tt> (you can read more about it in the <=
a href=3D"https://binarydebt.wordpress.com/2018/10/06/how-does-an-x86-proce=
ssor-boot/">How Does an Intel Processor Boot?</a> blog post. You can single=
 step through the BIOS machine code with the <tt>si</tt> (single instructio=
n) GDB command if you like, but it's hard to make sense of what is going on=
 so lets skip it for now and get to the point when QEMU starts executing ou=
r kernel.</p>
                        <p>Set a breakpoint at the address of the entry poi=
nt, e.g.</p>
                        <div class=3D"side-by-side-code">
                            <div class=3D"code fancy"><span class=3D"code-l=
ine odd"><b>VGA Blank mode</b></span></div><!-- end code -->
                            <div class=3D"code fancy"><span class=3D"code-l=
ine odd">GNU gdb (Ubuntu 8.1-0ubuntu3.2) 8.1.0.20180409-git</span>
<span class=3D"code-line even">(...)</span>
<span class=3D"code-line odd">0x000000000000fff0 in ?? ()</span>
<span class=3D"code-line even">+ symbol-file kernel</span>
<span class=3D"code-line odd entry">(gdb) br *0x001010f0 </span>
<span class=3D"code-line even">Breakpoint 1 at 0x001010f0</span>
<span class=3D"code-line odd"><span class=3D"entry">(gdb)</span></span></di=
v><!-- end code -->
                        </div>
                        <!--(gdb) c Continuing.  The target
                             architecture is assumed to be i386 =3D> 0x1000=
0c:	mov    %cr4,%eax
                             Breakpoint 1, 0x0010000c in ?? ()
                             (gdb)-->
                        <p>The details of what you see may differ slightly =
from the above output.</p>
                    </section><!-- end subsection -->
                    <section class=3D"subsection">
                        <h3>Troubleshooting GDB issues</h3>
                        <p>It might be possible that you get the following =
error on gdb.</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">warning: File "<span class=3D"fg-blue">&lt;path_to_hw4&gt;</span>/.gdb=
init" auto-loading has been </span>
<span class=3D"code-line even">declined by your 'auto-load safe-path' set t=
o "$debugdir:$datadir/auto-load:/usr/bin/mono-gdb.py".</span>
<span class=3D"code-line odd"><span class=3D"warning">To enable execution o=
f this file add</span></span>
<span class=3D"code-line even"><span class=3D"warning">    add-auto-load-sa=
fe-path <span class=3D"fg-blue">&lt;path_to_hw4&gt;</span>/.gdbinit</span><=
/span>
<span class=3D"code-line odd"><span class=3D"warning">line to your configur=
ation file "/home/<span class=3D"fg-cyan">&lt;username&gt;</span>/.gdbinit"=
.</span></span>
<span class=3D"code-line even">To completely disable this security protecti=
on add</span>
<span class=3D"code-line odd">    set auto-load safe-path /</span>
<span class=3D"code-line even">line to your configuration file "/home/<span=
 class=3D"fg-cyan">&lt;username&gt;</span>/.gdbinit".</span>
<span class=3D"code-line odd">For more information about this security prot=
ection see the</span>
<span class=3D"code-line even">"Auto-loading safe path" section in the GDB =
manual.  E.g., run from the shell:</span>
<span class=3D"code-line odd">    info "(gdb)Auto-loading safe path"</span>=
</div><!-- end code -->
                        <p>GDB uses a file called <tt>.gdbinit</tt> to init=
ialize things. We provide you with a .gdbinit file with the required setup.=
 However, to allow this local <tt>.gdbinit</tt> file to be used, we have to=
 add the a line to the global <tt>.gdbinit</tt> file. Add this line to <tt>=
/home/<span class=3D"fg-cyan">&lt;username&gt;</span>/.gdbinit.</tt></p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">add-auto-load-safe-path <span class=3D"fg-blue">&lt;path_to_hw4&gt;</s=
pan>/.gdbinit</span></div><!-- end code -->
                        <p>Try to examine the <tt>.gdbinit</tt> file that w=
e provide you (in unix systems files starting with <tt>.</tt> are hidden, y=
ou can list them with <tt>ls -a</tt>).</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">echo + target remote localhost:1234\n</span>
<span class=3D"code-line even">target remote localhost:1234</span>
<span class=3D"code-line odd entry"></span>
<span class=3D"code-line even">echo + symbol-file kernel\n</span>
<span class=3D"code-line odd">symbol-file build/kernel.bin</span></div><!--=
 end code -->
                        <p>It tells gdb that the file to read symbols from =
while debugging is in <tt>build/kernel.bin</tt>. Since we are using remote-=
debugging, gdb and the target environment communicate through a network soc=
ket (this matches with what is setup in the <tt>QEMU_GDB</tt> variable in t=
he Makefile). The other lines in the <tt>.gdbinit</tt> file setup the commu=
nication.</p>
                    </section><!-- end subsection -->
                    <section class=3D"subsection">
                        <h3>Making yourself familiar with GDB</h3>
                        <p>This part of the homework teaches you how to use=
 GDB. If your OS and GDB are still running exit them.</p>
                        <p>To exit gdb, just type <tt class=3D"key">Ctrl</t=
t> + <tt class=3D"key">C</tt>, and type <tt>quit</tt>. Depending on how you=
 started qemu, you can exit with different commands:</p>
                        <ul class=3D"spaced">
                            <li>If using <tt>-curses</tt>, type <tt class=
=3D"key">Alt</tt> + <tt class=3D"key">2</tt> (or <tt class=3D"key">Esc</tt>=
 + <tt class=3D"key">2</tt>), type <tt>q</tt> (or <tt>quit</tt>) in the con=
sole; and then <tt class=3D"key">Enter</tt></li>
                            <li>If using <tt>-nographic</tt>, and see somet=
hing like this in the first terminal:
                                <div class=3D"code fancy"><span class=3D"co=
de-line odd">...</span>
<span class=3D"code-line even">XMM02=3D00000000000000000000000000000000 XMM=
03=3D00000000000000000000000000000000</span>
<span class=3D"code-line odd">XMM04=3D00000000000000000000000000000000 XMM0=
5=3D00000000000000000000000000000000</span>
<span class=3D"code-line even">XMM06=3D00000000000000000000000000000000 XMM=
07=3D00000000000000000000000000000000</span>
<span class=3D"code-line odd">_</span></div><!-- end code -->
                                Then just press <tt class=3D"key">Enter</tt=
> to reveal the qemu console, type <tt>quit</tt>, and <tt class=3D"key">Ent=
er</tt> again.</li>
                            <li>You can also exit QEMU by it with <tt class=
=3D"key">Ctrl</tt> + <tt class=3D"key">A</tt>, <tt class=3D"key">X</tt>.</l=
i>
                        </ul>
                        <p>Start your OS and gdb again as you did before. U=
se two terminals: one to start the OS in QEMU (<tt>make qemu-gdb</tt>) and =
one to start GDB (<tt>gdb</tt>)</p>
                        <p>Now we explore the other ways of setting breakpo=
ints. Instead of <tt>br *0x001010f0 </tt>, you can use the name of the func=
tion or an assembly label, e.g., to set the breakpoint at the beginning of =
the <tt>start</tt> label you can use:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd entry">(gdb) br start</span></div><!-- end code -->
                        <p>BTW, autocomplete works inside GDB, so you can j=
ust type "s" and hit Tab. Similarly, you can set the breakpoint on the <tt>=
main()</tt> function.</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd entry">(gdb) br main</span></div><!-- end code -->
                        <p>If you need help with GDB commands, GDB can show=
 you a list of all commands with:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd entry">(gdb) help all</span></div><!-- end code -->
                        <p>Now since you set two breakpoints you can contin=
ue execution of the system until one of them gets hit. In gdb enter the "c"=
 (continue) command to run xv6 until it hits the first breakpoint (<tt>_sta=
rt</tt>).</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd entry">(gdb) c</span></div><!-- end code -->
                        <p>Just in case it is disabled, you can instruct gd=
b to, after advancing a single machine instruction, print the next one. You=
 can also switch between ATT and Intel disassembly syntax. Now use the <tt>=
si</tt> (step instruction) command to single step your execution (execute o=
ne machine instruction at a time). Remember that the <tt>_start</tt> label =
is defined in the assembly file, <tt>entry.S</tt> to be the entry point for=
 the kernel. Enter <tt>si</tt> a couple of times. Note, you don't have to e=
nter <tt>si</tt> every time, if you just press "enter" the GDB will execute=
 the last command.</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd entry">(gdb) set disassemble-next-line on</span>
<span class=3D"code-line even entry">(gdb) set disassembly-flavor att</span=
>
<span class=3D"code-line odd entry">(gdb) set disassembly-flavor intel</spa=
n>
<span class=3D"code-line even entry">(gdb) si</span>
<span class=3D"code-line odd">0x00000000001010e5 in start ()</span>
<span class=3D"code-line even">=3D&gt; 0x00000000001010e5 &lt;start+5&gt;: =
   83 c8 03	or     $0x3,%eax</span>
<span class=3D"code-line odd entry">(gdb) si</span>
<span class=3D"code-line even">0x00000000001010e8 in start ()</span>
<span class=3D"code-line odd">=3D&gt; 0x00000000001010e8 &lt;start+8&gt;:	a=
3 00 30 10 00 b9 00 00 00	movabs %eax,0xb900103000</span>
<span class=3D"code-line even entry">(gdb)</span>
<span class=3D"code-line odd">0x00000000001010ed in start ()</span>
<span class=3D"code-line even">=3D&gt; 0x00000000001010ed &lt;start+13&gt;:=
	b9 00 00 00 00	mov    $0x0,%ecx</span>
<span class=3D"code-line odd entry">(gdb)</span></div><!-- end code -->
                        <p>You can either continue single stepping until yo=
u reach your code or the <tt>main()</tt> function, or you can enter "c" to =
continue execution until the next breakpoint.</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd entry">(gdb) c</span>
<span class=3D"code-line even">Continuing.</span>
<span class=3D"code-line odd">Breakpoint 1, 0x00000000001010f0 in start ()<=
/span></div><!-- end code -->
                        <p> The moment you reach the C code, you should be =
able to view the C source alongside using the <tt>l</tt> (list) command. Si=
nce we compiled the kernel with the "-g" flag that includes the symbol info=
rmation into the ELF file we can see the C source code that we're executing=
.</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">Breakpoint 2, main () at main.c:14</span>
<span class=3D"code-line even"><span class=3D"comment">14    {</span></span=
>
<span class=3D"code-line odd entry">(gdb) l</span>
<span class=3D"code-line even"><span class=3D"comment">9	{</span></span>
<span class=3D"code-line odd"><span class=3D"comment">10	    asm volatile("=
hlt" : : );</span></span>
<span class=3D"code-line even"><span class=3D"comment">11	}</span></span>
<span class=3D"code-line odd"><span class=3D"comment">12	</span></span>
<span class=3D"code-line even"><span class=3D"comment">13	int main(void)</s=
pan></span>
<span class=3D"code-line odd"><span class=3D"comment">14	{</span></span>
<span class=3D"code-line even"><span class=3D"comment">15	    int i; </span=
></span>
<span class=3D"code-line odd"><span class=3D"comment">16	    int sum =3D 0;=
</span></span>
<span class=3D"code-line even entry">(gdb)</span></div><!-- end code -->
                        <p>Remember that when you hit the <tt>main</tt> bre=
akpoint GDB showed you that you're at line 14 in the main.c file (<tt>main.=
c:14</tt>). You can either step into the functions with the <tt>s</tt> (ste=
p) command (note, in contrast to the <tt>si</tt> step instruction command, =
this one will execute <b>one C line at a time</b>), or step over the functi=
ons with the <tt>n</tt> (next) command which will not enter the function, b=
ut instead will execute it till completion.</p>
                        <p>Try stepping into one of the functions you built=
. Once gdb has stopped at the line where you invoke a function, type <tt> s=
 </tt> for <tt>step</tt>.</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd entry">(gdb) s</span></div><!-- end code -->
                        <p>The whole listing of the source code seems a bit=
 inconvenient (entering <tt>l</tt> every time you want to see the source li=
ne is a bit annoying). GDB provides a more conventional way of following th=
e program execution with the TUI mechanism. Enable it with the following GD=
B command</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd entry">(gdb) tui enable</span></div><!-- end code -->
                        <p>Now you see the source code window and the machi=
ne instructions at the bottom. You can use the same commands to walk throug=
h your program. You can scroll the source with arrow keys, PgUp, and PgDown=
.</p>
                        <p>TUI can show you the state of the registers and =
how they are changing as you execute your code</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd entry">(gdb) tui reg general</span></div><!-- end code -->
                        <p>TUI is a very cute part of GDB and hence it make=
s sense to read more about its various capabilities: <a href=3D"http://sour=
ceware.org/gdb/onlinedocs/gdb/TUI-Commands.html">TUI Commands</a>.</p>
                        <p>For example, you can specify the assembly layout=
 to single step through machine instructions similar to source code:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd entry">(gdb) layout asm</span></div><!-- end code -->
                        <p>Or you can use them both (try it)</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd entry">(gdb) layout split</span></div><!-- end code -->
                        <p>Or you can look at the registers too:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd entry">(gdb) layout regs</span></div><!-- end code -->
                        <p> <a href=3D"https://beej.us/guide/bggdb/"> Beej'=
s Quick Guide to GDB</a> is a wonderful introduction to GDB using TUI.</p>
                    </section><!-- end subsection -->
                </div><!-- end content -->
            </section><!-- end page -->
           =20
            <section class=3D"page">
                <div class=3D"div-title-wrapper"><span class=3D"go-top"><a =
href=3D"https://users.cs.utah.edu/~aburtsev/238P/hw/hw4-boot-into-c/hw4-boo=
t-into-c.html#top">Top</a></span><h2 class=3D"title" toc=3D"QEMU's monitor"=
 id=3D"15" style=3D"display: inline; border-style: none;">Debugging with QE=
MU's built-in monitor</h2></div>
                <div class=3D"content">
                    <section class=3D"subsection">
                        <p>QEMU has a built-in monitor that can inspect and=
 modify the machine state. To enter the monitor press <tt> Alt + 2 </tt>. S=
ome of the following commands should be helpful in the monitor:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">QEMU 4.0.0 monitor - type 'help' for more information</span>
<span class=3D"code-line even entry">(qemu) info mem</span>
<span class=3D"code-line odd">0000000000000000-0000000000400000 00000000004=
00000 -rw</span>
<span class=3D"code-line even entry">(qemu)</span></div><!-- end code -->
                        <p>This displays mapped virtual memory and permissi=
ons. The above example tells us that <tt> 0x0000000000400000 </tt> bytes of=
 memory from <tt> 0x0000000000000000</tt> to <tt>0x0000000000400000 </tt> a=
re mapped read/write.</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">QEMU 4.0.0 monitor - type 'help' for more information</span>
<span class=3D"code-line even entry">(qemu) info registers</span>
<span class=3D"code-line odd">(...)</span></div><!-- end code -->
                        <p>This displays a full dump of the machine's inter=
nal register state.</p>
                    </section><!-- end subsection -->
                </div><!-- end content -->
            </section><!-- end page -->
           =20
            <section class=3D"page">
                <div class=3D"div-title-wrapper"><span class=3D"go-top"><a =
href=3D"https://users.cs.utah.edu/~aburtsev/238P/hw/hw4-boot-into-c/hw4-boo=
t-into-c.html#top">Top</a></span><h2 class=3D"title" toc=3D"Your Assignment=
" id=3D"16" style=3D"display: inline; border-style: none;">Your Assignment<=
/h2></div>
                <div class=3D"content">
                    <section class=3D"subsection">
                        <p>Finally, <b> your assignment is to implement  pa=
ge table that maps the first 8MB of virtual addresses to the first 8MB of p=
hysical memory</b>. At the moment we have a page table that maps first 4MB,=
 you need to define and construct a new page table once you boot into <tt>m=
ain()</tt>.</p>
                        <p>Once your page table is constructed use the prov=
ided <tt>lcr3()</tt> function to load it into the <tt>CR3</tt> register. No=
te, you have to load the physical address of the page table.</p>
                    </section><!-- end subsection -->
                    <section class=3D"subsection">
                        <h3>Extra credit 1: (10% bonus)</h3>
                        <p>Implement support for mapping 256MBs of physical=
 memory with 4KB pages.</p>
                    </section><!-- end subsection -->
                    <section class=3D"subsection">
                        <h3>Extra credit 2: (10% bonus)</h3>
                        <p>Implement a simple CGA driver, i.e., when you us=
e the <tt>printk()</tt> it should print on both serial line like now and on=
 the display.</p>
                    </section><!-- end subsection -->
                    <section class=3D"subsection">
                        <h3>Extra credit 3: (5% bonus)</h3>
                        <p>Boot on real hardware. I.e., try booting your co=
de on a real desktop or laptop by either burning a CD-ROM or a USB flash dr=
ive. Record a video of your code booting.</p>
                    </section><!-- end subsection -->
                    <section class=3D"subsection">
                        <h3>Extra credit 4: (5% bonus)</h3>
                        <p>Change the descriptor privilege level in the GDT=
 to 3. Analyse (understand and explain) what happens.</p>
                    </section><!-- end subsection -->
                </div><!-- end content -->
            </section><!-- end page -->
           =20
            <section class=3D"page">
                <div class=3D"div-title-wrapper"><span class=3D"go-top"><a =
href=3D"https://users.cs.utah.edu/~aburtsev/238P/hw/hw4-boot-into-c/hw4-boo=
t-into-c.html#top">Top</a></span><h2 class=3D"title" toc=3D"Submit your Wor=
k" id=3D"17" style=3D"display: inline; border-style: none;">Submit your Wor=
k</h2></div>
                <div class=3D"content">
                    <section class=3D"subsection">
                        <p>Submit your solution (the zip archive) through G=
radescope in the assignment called <a href=3D"https://www.gradescope.com/co=
urses/320406" target=3D"_blank" rel=3D"noopener noreferrer">HW4 - Booting i=
nto C</a>. Please zip all of your files and submit them. If you have done e=
xtra credit then place all the required files in a new folder extra1, extra=
2, etc.</p>
                        <p>You can resubmit as many times as you wish. If y=
ou have any problems with the structure the autograder will tell you. The s=
tructure of the zip file should be the following:</p>
                        <div class=3D"code fancy"><span class=3D"code-line =
odd">homework4.zip</span>
<span class=3D"code-line even">=E2=94=9C=E2=94=80=E2=94=80 required/</span>
<span class=3D"code-line odd">=E2=94=82   =E2=94=9C=E2=94=80=E2=94=80 Makef=
ile</span>
<span class=3D"code-line even">=E2=94=82   =E2=94=9C=E2=94=80=E2=94=80 grub=
.cfg</span>
<span class=3D"code-line odd">=E2=94=82   =E2=94=9C=E2=94=80=E2=94=80 conso=
le.c</span>
<span class=3D"code-line even">=E2=94=82   =E2=94=9C=E2=94=80=E2=94=80 cons=
ole.h</span>
<span class=3D"code-line odd">=E2=94=82   =E2=94=9C=E2=94=80=E2=94=80 main.=
c</span>
<span class=3D"code-line even">=E2=94=82   =E2=94=9C=E2=94=80=E2=94=80 boot=
.asm</span>
<span class=3D"code-line odd">=E2=94=82   =E2=94=9C=E2=94=80=E2=94=80 linke=
r.ld</span>
<span class=3D"code-line even">=E2=94=82   =E2=94=9C=E2=94=80=E2=94=80 mult=
iboot_header.asm</span>
<span class=3D"code-line odd">=E2=94=82   =E2=94=94=E2=94=80=E2=94=80 ...  =
                  # any other file required to start</span>
<span class=3D"code-line even">=E2=94=9C=E2=94=80=E2=94=80 extra1/         =
           # optional</span>
<span class=3D"code-line odd">=E2=94=82   =E2=94=9C=E2=94=80=E2=94=80 Makef=
ile</span>
<span class=3D"code-line even">=E2=94=82   =E2=94=9C=E2=94=80=E2=94=80 grub=
.cfg</span>
<span class=3D"code-line odd">=E2=94=82   =E2=94=9C=E2=94=80=E2=94=80 conso=
le.c</span>
<span class=3D"code-line even">=E2=94=82   =E2=94=9C=E2=94=80=E2=94=80 cons=
ole.h</span>
<span class=3D"code-line odd">=E2=94=82   =E2=94=9C=E2=94=80=E2=94=80 main.=
c</span>
<span class=3D"code-line even">=E2=94=82   =E2=94=9C=E2=94=80=E2=94=80 boot=
.asm</span>
<span class=3D"code-line odd">=E2=94=82   =E2=94=9C=E2=94=80=E2=94=80 linke=
r.ld</span>
<span class=3D"code-line even">=E2=94=82   =E2=94=9C=E2=94=80=E2=94=80 mult=
iboot_header.asm</span>
<span class=3D"code-line odd">=E2=94=82   =E2=94=94=E2=94=80=E2=94=80 ...  =
                  # any other file required to start</span>
<span class=3D"code-line even">=E2=94=9C=E2=94=80=E2=94=80 extra2/         =
           # optional</span>
<span class=3D"code-line odd">=E2=94=82   =E2=94=9C=E2=94=80=E2=94=80 Makef=
ile</span>
<span class=3D"code-line even">=E2=94=82   =E2=94=9C=E2=94=80=E2=94=80 grub=
.cfg</span>
<span class=3D"code-line odd">=E2=94=82   =E2=94=9C=E2=94=80=E2=94=80 conso=
le.c</span>
<span class=3D"code-line even">=E2=94=82   =E2=94=9C=E2=94=80=E2=94=80 cons=
ole.h</span>
<span class=3D"code-line odd">=E2=94=82   =E2=94=9C=E2=94=80=E2=94=80 main.=
c</span>
<span class=3D"code-line even">=E2=94=82   =E2=94=9C=E2=94=80=E2=94=80 boot=
.asm</span>
<span class=3D"code-line odd">=E2=94=82   =E2=94=9C=E2=94=80=E2=94=80 linke=
r.ld</span>
<span class=3D"code-line even">=E2=94=82   =E2=94=9C=E2=94=80=E2=94=80 mult=
iboot_header.asm</span>
<span class=3D"code-line odd">=E2=94=82   =E2=94=94=E2=94=80=E2=94=80 ...  =
                  # any other file required to start</span>
<span class=3D"code-line even">=E2=94=9C=E2=94=80=E2=94=80 extra3/         =
           # optional</span>
<span class=3D"code-line odd">=E2=94=82   =E2=94=94=E2=94=80=E2=94=80 video=
_link.txt         # link to video showing the booting.</span>
<span class=3D"code-line even">=E2=94=94=E2=94=80=E2=94=80 extra4/         =
           # optional</span>
<span class=3D"code-line odd">    =E2=94=94=E2=94=80=E2=94=80 explanation.t=
xt</span></div><!-- end code -->
                        <p>The file <tt>video_link.txt</tt> will only conta=
in one line, with a single link to the video:</p>
                            <ol>
                                <li>You will first show a white sheet of pa=
per with your name and UCI email address.</li>
                                <li>Then you will show the physical machine=
 booting. Make sure that the paper and screen are readable.</li>
                                <li>The video cannot have cuts. It has to b=
e taken in one single shot.</li>
                            </ol>
                    </section><!-- end subsection -->
                </div><!-- end content -->
            </section><!-- end page -->
        </article>

        <footer>
            <div class=3D"content">
                <ul>
                    <li>238P Operative Systems, Fall 2021, University of Ca=
lifornia, Irvine</li>
                    <li>Instructor: Anton Burtsev</li>
                    <li>TAs: Claudio Parra, Elahe Khatibi</li>
                </ul>
                <div class=3D"update_note">Updated: November, 2021</div>
            </div>
        </footer>
       =20
   =20

</body></html>
------MultipartBoundary--X7AbJLMYIFTKHp8K9yEpurltyGfwpKdpPJjJNyVzsn----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: https://users.cs.utah.edu/~aburtsev/238P/style/simple.css

@charset "utf-8";

.default-theme { --bgr-l: 100%; --pge-l: 100%; --bor-l: 85%; --txt-l: 32%; =
--sub-tit-l: 45%; --sub-lin-l: 93%; --ex2-l: 33%; --header-fg: #99999a; --h=
eader-fg2: #000000; --header-bg: #ffffff; --links-fg: #396cd9; --links-ac: =
#6faafb82; --links-bg: #fff8c382; --code-fg-base: #3b6343; --code-fg-comm: =
#999999; --code-fg-entry: #a10000; --code-ac: #99bb99; --code-bg: #f0faf0; =
--code-bg2: #f7fcf8; --info-fg: #00435a; --info-ac: #00a1c1; --info-bg: #ef=
fdff; --caution-fg: hsl(0,0%,var(--txt-l)); --caution-ac: #daa60033; --caut=
ion-bg: #fffbc233; --warning-fg: #7c4000; --warning-ac: #daa600; --warning-=
bg: #fffbc2; --alert-fg: #360000; --alert-ac: #ae0000; --alert-bg: #ffdada;=
 --exam-fg: #282828; --exam-ac1: #80c189; --exam-ac2: #ff6969; --exam-bg: #=
fffcd5; --note-fg: #808080; --note-ac: #cbcbcb; --note-bg: #f2f2f2; --red: =
#c30000; --magenta: #c300c3; --purple: #7d00c3; --blue: #002ec3; --cyan: #0=
0adc3; --green: #00c32f; --moss: #789b00; --yellow: #ead300; --orange: #e27=
010; --max-width: 960px; --hor-padding: min(2em, 3.5vw); --line-height: cla=
mp(1.4em, 1.9vw, 1.8em); --font-size: clamp(16px, 1.4vw, 19px); }

html { height: 100%; }

body { height: 100%; display: flex; flex-direction: column; position: relat=
ive; width: 100%; margin: 0px; font-family: Arial; background: hsl(0, 0%, v=
ar(--bgr-l)); color: hsl(0, 0%, var(--txt-l)); }

a { padding-inline: 0.1em; border-style: dotted; border-color: transparent =
transparent var(--links-fg) transparent; border-radius: 3px; border-width: =
1px; text-decoration: none; word-break: break-word; transition: color 100ms=
 ease 0s, border 100ms ease 0s; color: hsl(0, 0%, var(--txt-l)); }

a:hover { border: 1px solid var(--links-fg); color: var(--links-fg); }

span.go-top { float: right; text-align: right; margin-bottom: -1.05em; }

ul > li > b:first-child::after { content: ":"; padding-right: 0.5em; }

ol > li > b:first-child::after { content: ":"; padding-right: 0.5em; }

tt { margin: -1px; min-width: 3em; padding: 0px 0.1em; border-style: solid;=
 border-color: var(--code-ac); border-width: 1px; border-radius: 2px; font-=
size: 0.9em; word-break: break-all; white-space: pre; background: var(--cod=
e-bg); }

@keyframes highlight {=20
  0% { background: hsl(0, 0%, var(--pge-l)); }
  2% { background: var(--warning-bg); }
  100% { background: hsl(0, 0%, var(--pge-l)); }
}

:target { scroll-margin-top: 3em; animation: 2s ease-in-out 0s 1 normal non=
e running highlight; }

.key { margin-inline-end: 0.1em; padding: 0.02em 0.4em; font-size: 0.8em; b=
order-style: solid; box-shadow: hsl(0, 0%, calc( 0.75 * var(--sub-lin-l))) =
0.5px 0.5px 0px 1.5px; border-width: 0px; background: hsl(0, 0%, var(--sub-=
lin-l)); }

.fg-red { color: var(--red); }

.fg-magenta { color: var(--magenta); }

.fg-purple { color: var(--purple); }

.fg-blue { color: var(--blue); }

.fg-cyan { color: var(--cyan); }

.fg-green { color: var(--green); }

.fg-moss { color: var(--moss); }

.fg-orange { color: var(--orange); }

header { margin: 0px; position: relative; background: var(--header-bg); col=
or: var(--header-fg); }

header > .content { box-sizing: border-box; width: min(100%, var(--max-widt=
h)); margin: 0px auto; padding: 0.5em var(--hor-padding); }

header .navigation { display: block; }

header .navigation > ul { display: block; margin: 0px; padding: 0px; text-a=
lign: right; list-style: none; }

header .navigation > ul > li { display: inline-block; }

header .navigation ul a { display: inline-block; margin: 0px 0.2em; padding=
: 0.2em 0.5em; }

header > .content .title { margin: 0px 0px 2em; display: block; text-align:=
 left; clear: right; color: var(--header-fg); }

header > .content .title .pre { display: block; font-size: 1.5em; font-weig=
ht: 400; }

header > .content .title > h1 { margin: 0px; font-size: 2.5em; font-weight:=
 400; color: var(--header-fg2); }

header > .content .title .post { display: block; padding-left: min(7em, 11v=
w); padding-top: 0.15em; font-size: 1em; font-weight: 400; }

header .inner-nav { display: block; margin-top: 2em; }

header .inner-nav > ul { display: block; margin: 0px; padding: 0px; text-al=
ign: center; list-style: none; }

header .inner-nav > ul > li { display: inline-block; }

header .inner-nav > ul > li:not(:last-child)::after { content: "=E2=80=A2";=
 }

header .inner-nav ul a { border-style: none; display: inline-block; font-si=
ze: 0.8em; margin: 0px 0.2em; padding: 0.2em 0.5em; }

article { flex: 1 0 auto; width: min(100%, var(--max-width)); box-sizing: b=
order-box; margin: 1.5em auto; position: relative; font-size: var(--font-si=
ze); }

article p { text-indent: min(1em, 2vw); margin-block: calc(var(--line-heigh=
t) / 2); line-height: var(--line-height); }

.page { margin: 1px auto; padding: 3em var(--hor-padding); overflow: auto; =
outline: 1px dashed hsl(0, 0%, var(--bor-l)); background: hsl(0, 0%, var(--=
pge-l)); color: hsl(0, 0%, var(--txt-l)); }

.page > :first-child { margin-top: 0px; }

.page > :last-child { margin-bottom: 0px; }

.page > .title { margin: 0px; }

.page > .content { margin: 1em 0px 0px clamp(1em, 2vw, 2em); }

.page ul { list-style: "- "; }

.page ul, .page ol { margin: 0px; margin-inline-start: clamp(1em, 2vw, 2em)=
; padding-inline-start: 0px; }

.page ul li, .page ol li { margin: 0.2em 0px; }

ol.spaced, ul.spaced { line-height: var(--line-height); }

.subsection { margin: 1.5em 0px; }

.subsection:first-child :is(h1, h2, h3, h4, h5, h6), .div-title-wrapper:fir=
st-child { border: none; }

.subsection :is(h1, h2, h3, h4, h5, h6), .div-title-wrapper { margin: 0.5em=
 0px; padding-top: 0.2em; border-style: solid none none; border-color: hsl(=
0, 0%, var(--sub-lin-l)); border-width: 1px; color: hsl(0, 0%, var(--sub-ti=
t-l)); }

.subsection a { margin-inline: 0px 0.3em; }

.figure { display: block; margin: 1em auto; max-width: min(30em, 98%); posi=
tion: relative; border: solid 1px hsl(0, 0%, var(--bor-l)); }

.figure img { margin: 0px; padding: 0.5em 0.5em 0.25em; width: 100%; box-si=
zing: border-box; }

.figure p { margin: 0px; padding: 0.25em 0.5em 0.5em; text-indent: 0px; tex=
t-align: center; font-size: 0.85em; border-style: solid none none; border-c=
olor: hsl(0, 0%, var(--bor-l)); border-width: 1px; }

.code { display: block; padding: 0.5em; margin: 0px; font-family: monospace=
, monospace; font-size: min(3vw, 0.9em); text-align: left; vertical-align: =
middle; white-space: pre-wrap; overflow-wrap: break-word; border-style: sol=
id; border-width: 2px 2px 2px 12px; border-radius: 6px; border-color: var(-=
-code-ac); color: var(--code-fg-base); background-color: var(--code-bg); }

.side-by-side-code { display: flex; }

.side-by-side-code > .code { display: inline-block; }

.side-by-side-code > .code:last-child { flex: 1 1 0%; }

.fancy { padding: 0px; white-space: normal; }

.fancy > .code-line { display: block; min-height: min(3vw, 0.9em); white-sp=
ace: pre-wrap; box-sizing: border-box; margin-right: 0.5em; padding: 0px 0.=
5em; }

.fancy > .code-line:first-child { padding-top: 0.5em; }

.fancy > .code-line:last-child { padding-bottom: 0.5em; }

.fancy > .code-line.odd { background: var(--code-bg); }

.fancy > .code-line.even { background: linear-gradient(90deg, var(--code-bg=
2) 0%, var(--code-bg2) 90%, #fff0 100%); }

.fancy .entry { color: var(--code-fg-entry); }

.fancy .comment { color: var(--code-fg-comm); }

table { margin: 0px; border-collapse: collapse; line-height: 1.3em; font-si=
ze: 0.82em; }

table th, table td { margin: 1em; text-align: left; padding: 0.5em; border-=
style: solid none none; border-width: 1px; border-color: hsl(9, 9%, var(--b=
or-l)); }

table th { border-style: none; }

table tr td:last-child { width: 35%; }

table tr:last-child td { border-style: solid none; }

.msg { margin: 1em 0px; padding: 0.5em; border-style: solid; border-width: =
2px 2px 2px 12px; border-radius: 6px; }

.msg * { margin: 0.5em 0px; }

.msg :is(h1, h2, h3, h4, h5, h6) { margin: 0px; padding: 0px; border: none;=
 }

.msg-slim { padding: 0.2em; border-style: solid; border-width: 2px 2px 2px =
7px; border-radius: 5px; }

.info { border-color: var(--info-ac); background: var(--info-bg); color: va=
r(--info-fg); }

.note { margin-left: 3em; padding: calc(0.5em + 2px); border: none; font-si=
ze: 0.8em; background: var(--note-bg); color: var(--note-fg); }

.note a { color: var(--note-fg) !important; }

.note .source { text-align: right; }

.caution { border-color: var(--caution-ac); background: var(--caution-bg); =
color: var(--caution-fg); }

.warning { border-color: var(--warning-ac); background: var(--warning-bg); =
color: var(--warning-fg); }

.alert { border-color: var(--alert-ac); background: var(--alert-bg); color:=
 var(--alert-fg); }

.homework { border-color: var(--exam-ac1); color: var(--exam-fg); backgroun=
d: var(--exam-bg); }

.exam { border-color: var(--exam-ac2); color: var(--exam-fg); background: v=
ar(--exam-bg); }

footer { width: 100%; position: relative; bottom: 0px; background: var(--he=
ader-bg); color: var(--header-fg); }

footer > .content { width: min(100%, var(--max-width)); box-sizing: border-=
box; margin: 0px auto; padding: 0.5em var(--hor-padding); }

footer > .content > ul { display: block; margin: auto; padding: 0px 0px 1vh=
; list-style: none; line-height: 1.5em; }

footer > .content > .update_note { font-size: 0.8em; text-align: right; }
------MultipartBoundary--X7AbJLMYIFTKHp8K9yEpurltyGfwpKdpPJjJNyVzsn------
