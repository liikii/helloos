From: <Saved by Blink>
Snapshot-Content-Location: https://littleosbook.github.io/
Subject: The little book about OS development
Date: Fri, 11 Aug 2023 16:20:22 -0000
MIME-Version: 1.0
Content-Type: multipart/related;
	type="text/html";
	boundary="----MultipartBoundary--pTIzw0msXwU3B7ZB0SkpfFoayxkwkQKObHsTv4lWBu----"


------MultipartBoundary--pTIzw0msXwU3B7ZB0SkpfFoayxkwkQKObHsTv4lWBu----
Content-Type: text/html
Content-ID: <frame-0FE6F88068A45D6DDC9D6E9502EE7DE5@mhtml.blink>
Content-Transfer-Encoding: quoted-printable
Content-Location: https://littleosbook.github.io/

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.=
w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns=3D"http://www.w3.=
org/1999/xhtml"><head><meta http-equiv=3D"Content-Type" content=3D"text/htm=
l; charset=3DUTF-8"><link rel=3D"stylesheet" type=3D"text/css" href=3D"cid:=
css-8d2a4cec-adcb-483a-bf78-ee3c59f4823f@mhtml.blink" />
 =20
  <meta http-equiv=3D"Content-Style-Type" content=3D"text/css">
  <meta name=3D"generator" content=3D"pandoc">
  <meta name=3D"author" content=3D"Erik Helin, Adam Renberg">
  <title>The little book about OS development</title>
 =20
  <link rel=3D"stylesheet" href=3D"https://littleosbook.github.io/book.css"=
 type=3D"text/css">
</head>
<body>
<div id=3D"wrapper">
<div id=3D"header">
<h1 class=3D"title">The little book about OS development</h1>
<h2 class=3D"author">Erik Helin, Adam Renberg</h2>
</div>
<div class=3D"subheader">
<a href=3D"https://github.com/littleosbook/littleosbook/">2015-01-19 | Comm=
it: fe83e27dab3c39930354d2dea83f6d4ee2928212</a>
<a class=3D"pdflink" href=3D"https://littleosbook.github.io/book.pdf" title=
=3D"PDF version">PDF version</a>
</div>
<div id=3D"content">
<div id=3D"TOC">
<h1>Contents</h1>
<ul>
<li><a href=3D"https://littleosbook.github.io/#introduction"><span class=3D=
"toc-section-number">1</span> Introduction</a><ul>
<li><a href=3D"https://littleosbook.github.io/#about-the-book"><span class=
=3D"toc-section-number">1.1</span> About the Book</a></li>
<li><a href=3D"https://littleosbook.github.io/#the-reader"><span class=3D"t=
oc-section-number">1.2</span> The Reader</a></li>
<li><a href=3D"https://littleosbook.github.io/#credits-thanks-and-acknowled=
gements"><span class=3D"toc-section-number">1.3</span> Credits, Thanks and =
Acknowledgements</a></li>
<li><a href=3D"https://littleosbook.github.io/#contributors"><span class=3D=
"toc-section-number">1.4</span> Contributors</a></li>
<li><a href=3D"https://littleosbook.github.io/#changes-and-corrections"><sp=
an class=3D"toc-section-number">1.5</span> Changes and Corrections</a></li>
<li><a href=3D"https://littleosbook.github.io/#issues-and-where-to-get-help=
"><span class=3D"toc-section-number">1.6</span> Issues and where to get hel=
p</a></li>
<li><a href=3D"https://littleosbook.github.io/#license"><span class=3D"toc-=
section-number">1.7</span> License</a></li>
</ul></li>
<li><a href=3D"https://littleosbook.github.io/#first-steps"><span class=3D"=
toc-section-number">2</span> First Steps</a><ul>
<li><a href=3D"https://littleosbook.github.io/#tools"><span class=3D"toc-se=
ction-number">2.1</span> Tools</a><ul>
<li><a href=3D"https://littleosbook.github.io/#quick-setup"><span class=3D"=
toc-section-number">2.1.1</span> Quick Setup</a></li>
<li><a href=3D"https://littleosbook.github.io/#programming-languages"><span=
 class=3D"toc-section-number">2.1.2</span> Programming Languages</a></li>
<li><a href=3D"https://littleosbook.github.io/#host-operating-system"><span=
 class=3D"toc-section-number">2.1.3</span> Host Operating System</a></li>
<li><a href=3D"https://littleosbook.github.io/#build-system"><span class=3D=
"toc-section-number">2.1.4</span> Build System</a></li>
<li><a href=3D"https://littleosbook.github.io/#virtual-machine"><span class=
=3D"toc-section-number">2.1.5</span> Virtual Machine</a></li>
</ul></li>
<li><a href=3D"https://littleosbook.github.io/#booting"><span class=3D"toc-=
section-number">2.2</span> Booting</a><ul>
<li><a href=3D"https://littleosbook.github.io/#bios"><span class=3D"toc-sec=
tion-number">2.2.1</span> BIOS</a></li>
<li><a href=3D"https://littleosbook.github.io/#the-bootloader"><span class=
=3D"toc-section-number">2.2.2</span> The Bootloader</a></li>
<li><a href=3D"https://littleosbook.github.io/#the-operating-system"><span =
class=3D"toc-section-number">2.2.3</span> The Operating System</a></li>
</ul></li>
<li><a href=3D"https://littleosbook.github.io/#hello-cafebabe"><span class=
=3D"toc-section-number">2.3</span> Hello Cafebabe</a><ul>
<li><a href=3D"https://littleosbook.github.io/#compiling-the-operating-syst=
em"><span class=3D"toc-section-number">2.3.1</span> Compiling the Operating=
 System</a></li>
<li><a href=3D"https://littleosbook.github.io/#linking-the-kernel"><span cl=
ass=3D"toc-section-number">2.3.2</span> Linking the Kernel</a></li>
<li><a href=3D"https://littleosbook.github.io/#obtaining-grub"><span class=
=3D"toc-section-number">2.3.3</span> Obtaining GRUB</a></li>
<li><a href=3D"https://littleosbook.github.io/#building-an-iso-image"><span=
 class=3D"toc-section-number">2.3.4</span> Building an ISO Image</a></li>
<li><a href=3D"https://littleosbook.github.io/#running-bochs"><span class=
=3D"toc-section-number">2.3.5</span> Running Bochs</a></li>
</ul></li>
<li><a href=3D"https://littleosbook.github.io/#further-reading"><span class=
=3D"toc-section-number">2.4</span> Further Reading</a></li>
</ul></li>
<li><a href=3D"https://littleosbook.github.io/#getting-to-c"><span class=3D=
"toc-section-number">3</span> Getting to C</a><ul>
<li><a href=3D"https://littleosbook.github.io/#setting-up-a-stack"><span cl=
ass=3D"toc-section-number">3.1</span> Setting Up a Stack</a></li>
<li><a href=3D"https://littleosbook.github.io/#calling-c-code-from-assembly=
"><span class=3D"toc-section-number">3.2</span> Calling C Code From Assembl=
y</a><ul>
<li><a href=3D"https://littleosbook.github.io/#packing-structs"><span class=
=3D"toc-section-number">3.2.1</span> Packing Structs</a></li>
</ul></li>
<li><a href=3D"https://littleosbook.github.io/#compiling-c-code"><span clas=
s=3D"toc-section-number">3.3</span> Compiling C Code</a></li>
<li><a href=3D"https://littleosbook.github.io/#build-tools"><span class=3D"=
toc-section-number">3.4</span> Build Tools</a></li>
<li><a href=3D"https://littleosbook.github.io/#further-reading-1"><span cla=
ss=3D"toc-section-number">3.5</span> Further Reading</a></li>
</ul></li>
<li><a href=3D"https://littleosbook.github.io/#output"><span class=3D"toc-s=
ection-number">4</span> Output</a><ul>
<li><a href=3D"https://littleosbook.github.io/#interacting-with-the-hardwar=
e"><span class=3D"toc-section-number">4.1</span> Interacting with the Hardw=
are</a></li>
<li><a href=3D"https://littleosbook.github.io/#the-framebuffer"><span class=
=3D"toc-section-number">4.2</span> The Framebuffer</a><ul>
<li><a href=3D"https://littleosbook.github.io/#writing-text"><span class=3D=
"toc-section-number">4.2.1</span> Writing Text</a></li>
<li><a href=3D"https://littleosbook.github.io/#moving-the-cursor"><span cla=
ss=3D"toc-section-number">4.2.2</span> Moving the Cursor</a></li>
<li><a href=3D"https://littleosbook.github.io/#the-driver"><span class=3D"t=
oc-section-number">4.2.3</span> The Driver</a></li>
</ul></li>
<li><a href=3D"https://littleosbook.github.io/#the-serial-ports"><span clas=
s=3D"toc-section-number">4.3</span> The Serial Ports</a><ul>
<li><a href=3D"https://littleosbook.github.io/#configuring-the-serial-port"=
><span class=3D"toc-section-number">4.3.1</span> Configuring the Serial Por=
t</a></li>
<li><a href=3D"https://littleosbook.github.io/#configuring-the-line"><span =
class=3D"toc-section-number">4.3.2</span> Configuring the Line</a></li>
<li><a href=3D"https://littleosbook.github.io/#configuring-the-buffers"><sp=
an class=3D"toc-section-number">4.3.3</span> Configuring the Buffers</a></l=
i>
<li><a href=3D"https://littleosbook.github.io/#configuring-the-modem"><span=
 class=3D"toc-section-number">4.3.4</span> Configuring the Modem</a></li>
<li><a href=3D"https://littleosbook.github.io/#writing-data-to-the-serial-p=
ort"><span class=3D"toc-section-number">4.3.5</span> Writing Data to the Se=
rial Port</a></li>
<li><a href=3D"https://littleosbook.github.io/#configuring-bochs"><span cla=
ss=3D"toc-section-number">4.3.6</span> Configuring Bochs</a></li>
<li><a href=3D"https://littleosbook.github.io/#the-driver-1"><span class=3D=
"toc-section-number">4.3.7</span> The Driver</a></li>
</ul></li>
<li><a href=3D"https://littleosbook.github.io/#further-reading-2"><span cla=
ss=3D"toc-section-number">4.4</span> Further Reading</a></li>
</ul></li>
<li><a href=3D"https://littleosbook.github.io/#segmentation"><span class=3D=
"toc-section-number">5</span> Segmentation</a><ul>
<li><a href=3D"https://littleosbook.github.io/#accessing-memory"><span clas=
s=3D"toc-section-number">5.1</span> Accessing Memory</a></li>
<li><a href=3D"https://littleosbook.github.io/#the-global-descriptor-table-=
gdt"><span class=3D"toc-section-number">5.2</span> The Global Descriptor Ta=
ble (GDT)</a></li>
<li><a href=3D"https://littleosbook.github.io/#loading-the-gdt"><span class=
=3D"toc-section-number">5.3</span> Loading the GDT</a></li>
<li><a href=3D"https://littleosbook.github.io/#further-reading-3"><span cla=
ss=3D"toc-section-number">5.4</span> Further Reading</a></li>
</ul></li>
<li><a href=3D"https://littleosbook.github.io/#interrupts-and-input"><span =
class=3D"toc-section-number">6</span> Interrupts and Input</a><ul>
<li><a href=3D"https://littleosbook.github.io/#interrupts-handlers"><span c=
lass=3D"toc-section-number">6.1</span> Interrupts Handlers</a></li>
<li><a href=3D"https://littleosbook.github.io/#creating-an-entry-in-the-idt=
"><span class=3D"toc-section-number">6.2</span> Creating an Entry in the ID=
T</a></li>
<li><a href=3D"https://littleosbook.github.io/#handling-an-interrupt"><span=
 class=3D"toc-section-number">6.3</span> Handling an Interrupt</a></li>
<li><a href=3D"https://littleosbook.github.io/#creating-a-generic-interrupt=
-handler"><span class=3D"toc-section-number">6.4</span> Creating a Generic =
Interrupt Handler</a></li>
<li><a href=3D"https://littleosbook.github.io/#loading-the-idt"><span class=
=3D"toc-section-number">6.5</span> Loading the IDT</a></li>
<li><a href=3D"https://littleosbook.github.io/#programmable-interrupt-contr=
oller-pic"><span class=3D"toc-section-number">6.6</span> Programmable Inter=
rupt Controller (PIC)</a></li>
<li><a href=3D"https://littleosbook.github.io/#reading-input-from-the-keybo=
ard"><span class=3D"toc-section-number">6.7</span> Reading Input from the K=
eyboard</a></li>
<li><a href=3D"https://littleosbook.github.io/#further-reading-4"><span cla=
ss=3D"toc-section-number">6.8</span> Further Reading</a></li>
</ul></li>
<li><a href=3D"https://littleosbook.github.io/#the-road-to-user-mode"><span=
 class=3D"toc-section-number">7</span> The Road to User Mode</a><ul>
<li><a href=3D"https://littleosbook.github.io/#loading-an-external-program"=
><span class=3D"toc-section-number">7.1</span> Loading an External Program<=
/a><ul>
<li><a href=3D"https://littleosbook.github.io/#grub-modules"><span class=3D=
"toc-section-number">7.1.1</span> GRUB Modules</a></li>
</ul></li>
<li><a href=3D"https://littleosbook.github.io/#executing-a-program"><span c=
lass=3D"toc-section-number">7.2</span> Executing a Program</a><ul>
<li><a href=3D"https://littleosbook.github.io/#a-very-simple-program"><span=
 class=3D"toc-section-number">7.2.1</span> A Very Simple Program</a></li>
<li><a href=3D"https://littleosbook.github.io/#compiling"><span class=3D"to=
c-section-number">7.2.2</span> Compiling</a></li>
<li><a href=3D"https://littleosbook.github.io/#finding-the-program-in-memor=
y"><span class=3D"toc-section-number">7.2.3</span> Finding the Program in M=
emory</a></li>
<li><a href=3D"https://littleosbook.github.io/#jumping-to-the-code"><span c=
lass=3D"toc-section-number">7.2.4</span> Jumping to the Code</a></li>
</ul></li>
<li><a href=3D"https://littleosbook.github.io/#the-beginning-of-user-mode">=
<span class=3D"toc-section-number">7.3</span> The Beginning of User Mode</a=
></li>
</ul></li>
<li><a href=3D"https://littleosbook.github.io/#a-short-introduction-to-virt=
ual-memory"><span class=3D"toc-section-number">8</span> A Short Introductio=
n to Virtual Memory</a><ul>
<li><a href=3D"https://littleosbook.github.io/#virtual-memory-through-segme=
ntation"><span class=3D"toc-section-number">8.1</span> Virtual Memory Throu=
gh Segmentation?</a></li>
<li><a href=3D"https://littleosbook.github.io/#further-reading-5"><span cla=
ss=3D"toc-section-number">8.2</span> Further Reading</a></li>
</ul></li>
<li><a href=3D"https://littleosbook.github.io/#paging"><span class=3D"toc-s=
ection-number">9</span> Paging</a><ul>
<li><a href=3D"https://littleosbook.github.io/#why-paging"><span class=3D"t=
oc-section-number">9.1</span> Why Paging?</a></li>
<li><a href=3D"https://littleosbook.github.io/#paging-in-x86"><span class=
=3D"toc-section-number">9.2</span> Paging in x86</a><ul>
<li><a href=3D"https://littleosbook.github.io/#identity-paging"><span class=
=3D"toc-section-number">9.2.1</span> Identity Paging</a></li>
<li><a href=3D"https://littleosbook.github.io/#enabling-paging"><span class=
=3D"toc-section-number">9.2.2</span> Enabling Paging</a></li>
<li><a href=3D"https://littleosbook.github.io/#a-few-details"><span class=
=3D"toc-section-number">9.2.3</span> A Few Details</a></li>
</ul></li>
<li><a href=3D"https://littleosbook.github.io/#paging-and-the-kernel"><span=
 class=3D"toc-section-number">9.3</span> Paging and the Kernel</a><ul>
<li><a href=3D"https://littleosbook.github.io/#reasons-to-not-identity-map-=
the-kernel"><span class=3D"toc-section-number">9.3.1</span> Reasons to Not =
Identity Map the Kernel</a></li>
<li><a href=3D"https://littleosbook.github.io/#the-virtual-address-for-the-=
kernel"><span class=3D"toc-section-number">9.3.2</span> The Virtual Address=
 for the Kernel</a></li>
<li><a href=3D"https://littleosbook.github.io/#placing-the-kernel-at-0xc000=
0000"><span class=3D"toc-section-number">9.3.3</span> Placing the Kernel at=
 <code>0xC0000000</code></a></li>
<li><a href=3D"https://littleosbook.github.io/#higher-half-linker-script"><=
span class=3D"toc-section-number">9.3.4</span> Higher-half Linker Script</a=
></li>
<li><a href=3D"https://littleosbook.github.io/#entering-the-higher-half"><s=
pan class=3D"toc-section-number">9.3.5</span> Entering the Higher Half</a><=
/li>
<li><a href=3D"https://littleosbook.github.io/#running-in-the-higher-half">=
<span class=3D"toc-section-number">9.3.6</span> Running in the Higher Half<=
/a></li>
</ul></li>
<li><a href=3D"https://littleosbook.github.io/#virtual-memory-through-pagin=
g"><span class=3D"toc-section-number">9.4</span> Virtual Memory Through Pag=
ing</a></li>
<li><a href=3D"https://littleosbook.github.io/#further-reading-6"><span cla=
ss=3D"toc-section-number">9.5</span> Further Reading</a></li>
</ul></li>
<li><a href=3D"https://littleosbook.github.io/#page-frame-allocation"><span=
 class=3D"toc-section-number">10</span> Page Frame Allocation</a><ul>
<li><a href=3D"https://littleosbook.github.io/#managing-available-memory"><=
span class=3D"toc-section-number">10.1</span> Managing Available Memory</a>=
<ul>
<li><a href=3D"https://littleosbook.github.io/#how-much-memory-is-there"><s=
pan class=3D"toc-section-number">10.1.1</span> How Much Memory is There?</a=
></li>
<li><a href=3D"https://littleosbook.github.io/#managing-available-memory-1"=
><span class=3D"toc-section-number">10.1.2</span> Managing Available Memory=
</a></li>
</ul></li>
<li><a href=3D"https://littleosbook.github.io/#how-can-we-access-a-page-fra=
me"><span class=3D"toc-section-number">10.2</span> How Can We Access a Page=
 Frame?</a></li>
<li><a href=3D"https://littleosbook.github.io/#a-kernel-heap"><span class=
=3D"toc-section-number">10.3</span> A Kernel Heap</a></li>
<li><a href=3D"https://littleosbook.github.io/#further-reading-7"><span cla=
ss=3D"toc-section-number">10.4</span> Further reading</a></li>
</ul></li>
<li><a href=3D"https://littleosbook.github.io/#user-mode"><span class=3D"to=
c-section-number">11</span> User Mode</a><ul>
<li><a href=3D"https://littleosbook.github.io/#segments-for-user-mode"><spa=
n class=3D"toc-section-number">11.1</span> Segments for User Mode</a></li>
<li><a href=3D"https://littleosbook.github.io/#setting-up-for-user-mode"><s=
pan class=3D"toc-section-number">11.2</span> Setting Up For User Mode</a></=
li>
<li><a href=3D"https://littleosbook.github.io/#entering-user-mode"><span cl=
ass=3D"toc-section-number">11.3</span> Entering User Mode</a></li>
<li><a href=3D"https://littleosbook.github.io/#using-c-for-user-mode-progra=
ms"><span class=3D"toc-section-number">11.4</span> Using C for User Mode Pr=
ograms</a><ul>
<li><a href=3D"https://littleosbook.github.io/#a-c-library"><span class=3D"=
toc-section-number">11.4.1</span> A C Library</a></li>
</ul></li>
<li><a href=3D"https://littleosbook.github.io/#further-reading-8"><span cla=
ss=3D"toc-section-number">11.5</span> Further Reading</a></li>
</ul></li>
<li><a href=3D"https://littleosbook.github.io/#file-systems"><span class=3D=
"toc-section-number">12</span> File Systems</a><ul>
<li><a href=3D"https://littleosbook.github.io/#why-a-file-system"><span cla=
ss=3D"toc-section-number">12.1</span> Why a File System?</a></li>
<li><a href=3D"https://littleosbook.github.io/#a-simple-read-only-file-syst=
em"><span class=3D"toc-section-number">12.2</span> A Simple Read-Only File =
System</a></li>
<li><a href=3D"https://littleosbook.github.io/#inodes-and-writable-file-sys=
tems"><span class=3D"toc-section-number">12.3</span> Inodes and Writable Fi=
le Systems</a></li>
<li><a href=3D"https://littleosbook.github.io/#a-virtual-file-system"><span=
 class=3D"toc-section-number">12.4</span> A Virtual File System</a></li>
<li><a href=3D"https://littleosbook.github.io/#further-reading-9"><span cla=
ss=3D"toc-section-number">12.5</span> Further Reading</a></li>
</ul></li>
<li><a href=3D"https://littleosbook.github.io/#system-calls"><span class=3D=
"toc-section-number">13</span> System Calls</a><ul>
<li><a href=3D"https://littleosbook.github.io/#designing-system-calls"><spa=
n class=3D"toc-section-number">13.1</span> Designing System Calls</a></li>
<li><a href=3D"https://littleosbook.github.io/#implementing-system-calls"><=
span class=3D"toc-section-number">13.2</span> Implementing System Calls</a>=
</li>
<li><a href=3D"https://littleosbook.github.io/#further-reading-10"><span cl=
ass=3D"toc-section-number">13.3</span> Further Reading</a></li>
</ul></li>
<li><a href=3D"https://littleosbook.github.io/#multitasking"><span class=3D=
"toc-section-number">14</span> Multitasking</a><ul>
<li><a href=3D"https://littleosbook.github.io/#creating-new-processes"><spa=
n class=3D"toc-section-number">14.1</span> Creating New Processes</a></li>
<li><a href=3D"https://littleosbook.github.io/#cooperative-scheduling-with-=
yielding"><span class=3D"toc-section-number">14.2</span> Cooperative Schedu=
ling with Yielding</a></li>
<li><a href=3D"https://littleosbook.github.io/#preemptive-scheduling-with-i=
nterrupts"><span class=3D"toc-section-number">14.3</span> Preemptive Schedu=
ling with Interrupts</a><ul>
<li><a href=3D"https://littleosbook.github.io/#programmable-interval-timer"=
><span class=3D"toc-section-number">14.3.1</span> Programmable Interval Tim=
er</a></li>
<li><a href=3D"https://littleosbook.github.io/#separate-kernel-stacks-for-p=
rocesses"><span class=3D"toc-section-number">14.3.2</span> Separate Kernel =
Stacks for Processes</a></li>
<li><a href=3D"https://littleosbook.github.io/#difficulties-with-preemptive=
-scheduling"><span class=3D"toc-section-number">14.3.3</span> Difficulties =
with Preemptive Scheduling</a></li>
</ul></li>
<li><a href=3D"https://littleosbook.github.io/#further-reading-11"><span cl=
ass=3D"toc-section-number">14.4</span> Further Reading</a></li>
</ul></li>
</ul>
</div>
<h1 id=3D"introduction"><span class=3D"header-section-number">1</span> Intr=
oduction</h1>
<p>This text is a practical guide to writing your own x86 operating system.=
 It is designed to give enough help with the technical details while at the=
 same time not reveal too much with samples and code excerpts. We=E2=80=99v=
e tried to collect parts of the vast (and often excellent) expanse of mater=
ial and tutorials available, on the web and otherwise, and add our own insi=
ghts into the problems we encountered and struggled with.</p>
<p>This book is not about the theory behind operating systems, or how any s=
pecific operating system (OS) works. For OS theory we recommend the book <e=
m>Modern Operating Systems</em> by Andrew Tanenbaum <span class=3D"citation=
">[1]</span>. Lists and details on current operating systems are available =
on the Internet.</p>
<p>The starting chapters are quite detailed and explicit, to quickly get yo=
u into coding. Later chapters give more of an outline of what is needed, as=
 more and more of the implementation and design becomes up to the reader, w=
ho should now be more familiar with the world of kernel development. At the=
 end of some chapters there are links for further reading, which might be i=
nteresting and give a deeper understanding of the topics covered.</p>
<p>In <a href=3D"https://littleosbook.github.io/#first-steps">chapter 2</a>=
 and <a href=3D"https://littleosbook.github.io/#getting-to-c">3</a> we set =
up our development environment and boot up our OS kernel in a virtual machi=
ne, eventually starting to write code in C. We continue in <a href=3D"https=
://littleosbook.github.io/#output">chapter 4</a> with writing to the screen=
 and the serial port, and then we dive into segmentation in <a href=3D"http=
s://littleosbook.github.io/#segmentation">chapter 5</a> and interrupts and =
input in <a href=3D"https://littleosbook.github.io/#interrupts-and-input">c=
hapter 6</a>.</p>
<p>After this we have a quite functional but bare-bones OS kernel. In <a hr=
ef=3D"https://littleosbook.github.io/#the-road-to-user-mode">chapter 7</a> =
we start the road to user mode applications, with virtual memory through pa=
ging (<a href=3D"https://littleosbook.github.io/#a-short-introduction-to-vi=
rtual-memory">chapter 8</a> and <a href=3D"https://littleosbook.github.io/#=
paging">9</a>), memory allocation (<a href=3D"https://littleosbook.github.i=
o/#page-frame-allocation">chapter 10</a>), and finally running a user appli=
cation in <a href=3D"https://littleosbook.github.io/#user-mode">chapter 11<=
/a>.</p>
<p>In the last three chapters we discuss the more advanced topics of file s=
ystems (<a href=3D"https://littleosbook.github.io/#file-systems">chapter 12=
</a>), system calls (<a href=3D"https://littleosbook.github.io/#system-call=
s">chapter 13</a>), and multitasking (<a href=3D"https://littleosbook.githu=
b.io/#multitasking">chapter 14</a>).</p>
<h2 id=3D"about-the-book"><span class=3D"header-section-number">1.1</span> =
About the Book</h2>
<p>The OS kernel and this book were produced as part of an advanced individ=
ual course at the Royal Institute of Technology <span class=3D"citation">[2=
]</span>, Stockholm. The authors had previously taken courses in OS theory,=
 but had only minor practical experience with OS kernel development. In ord=
er to get more insight and a deeper understanding of how the theory from th=
e previous OS courses works out in practice, the authors decided to create =
a new course, which focused on the development of a small OS. Another goal =
of the course was writing a thorough tutorial on how to develop a small OS =
basically from scratch, and this short book is the result.</p>
<p>The x86 architecture is, and has been for a long time, one of the most c=
ommon hardware architectures. It was not a difficult choice to use the x86 =
architecture as the target of the OS, with its large community, extensive r=
eference material and mature emulators. The documentation and information s=
urrounding the details of the hardware we had to work with was not always e=
asy to find or understand, despite (or perhaps due to) the age of the archi=
tecture.</p>
<p>The OS was developed in about six weeks of full-time work. The implement=
ation was done in many small steps, and after each step the OS was tested m=
anually. By developing in this incremental and iterative way, it was often =
easier to find any bugs that were introduced, since only a small part of th=
e code had changed since the last known good state of the code. We encourag=
e the reader to work in a similar way.</p>
<p>During the six weeks of development, almost every single line of code wa=
s written by the authors together (this way of working is also called <em>p=
air-programming</em>). It is our belief that we managed to avoid a lot of b=
ugs due to this style of development, but this is hard to prove scientifica=
lly.</p>
<h2 id=3D"the-reader"><span class=3D"header-section-number">1.2</span> The =
Reader</h2>
<p>The reader of this book should be comfortable with UNIX/Linux, systems p=
rogramming, the C language and computer systems in general (such as hexadec=
imal notation <span class=3D"citation">[3]</span>). This book could be a wa=
y to get started learning those things, but it will be more difficult, and =
developing an operating system is already challenging on its own. Search en=
gines and other tutorials are often helpful if you get stuck.</p>
<h2 id=3D"credits-thanks-and-acknowledgements"><span class=3D"header-sectio=
n-number">1.3</span> Credits, Thanks and Acknowledgements</h2>
<p>We=E2=80=99d like to thank the OSDev community <span class=3D"citation">=
[4]</span> for their great wiki and helpful members, and James Malloy for h=
is eminent kernel development tutorial <span class=3D"citation">[5]</span>.=
 We=E2=80=99d also like to thank our supervisor Torbj=C3=B6rn Granlund for =
his insightful questions and interesting discussions.</p>
<p>Most of the CSS formatting of the book is based on the work by Scott Cha=
con for the book Pro Git, <a href=3D"http://progit.org/">http://progit.org/=
</a>.</p>
<h2 id=3D"contributors"><span class=3D"header-section-number">1.4</span> Co=
ntributors</h2>
<p>We are very grateful for the patches that people send us. The following =
users have all contributed to this book:</p>
<ul>
<li><a href=3D"https://github.com/alexschneider">alexschneider</a></li>
<li><a href=3D"https://github.com/Avidanborisov">Avidanborisov</a></li>
<li><a href=3D"https://github.com/nirs">nirs</a></li>
<li><a href=3D"https://github.com/kedarmhaswade">kedarmhaswade</a></li>
<li><a href=3D"https://github.com/vamanea">vamanea</a></li>
<li><a href=3D"https://github.com/ansjob">ansjob</a></li>
</ul>
<h2 id=3D"changes-and-corrections"><span class=3D"header-section-number">1.=
5</span> Changes and Corrections</h2>
<p>This book is hosted on Github - if you have any suggestions, comments or=
 corrections, just fork the book, write your changes, and send us a pull re=
quest. We=E2=80=99ll happily incorporate anything that makes this book bett=
er.</p>
<h2 id=3D"issues-and-where-to-get-help"><span class=3D"header-section-numbe=
r">1.6</span> Issues and where to get help</h2>
<p>If you run into problems while reading the book, please check the issues=
 on Github for help: <a href=3D"https://github.com/littleosbook/littleosboo=
k/issues">https://github.com/littleosbook/littleosbook/issues</a>.</p>
<h2 id=3D"license"><span class=3D"header-section-number">1.7</span> License=
</h2>
<p>All content is under the Creative Commons Attribution Non Commercial Sha=
re Alike 3.0 license, <a href=3D"http://creativecommons.org/licenses/by-nc-=
sa/3.0/us/">http://creativecommons.org/licenses/by-nc-sa/3.0/us/</a>. The c=
ode samples are in the public domain - use them however you want. Reference=
s to this book are always received with warmth.</p>
<h1 id=3D"first-steps"><span class=3D"header-section-number">2</span> First=
 Steps</h1>
<p>Developing an operating system (OS) is no easy task, and the question =
=E2=80=9CHow do I even begin to solve this problem?=E2=80=9D is likely to c=
ome up several times during the course of the project for different problem=
s. This chapter will help you set up your development environment and booti=
ng a very small (and primitive) operating system.</p>
<h2 id=3D"tools"><span class=3D"header-section-number">2.1</span> Tools</h2=
>
<h3 id=3D"quick-setup"><span class=3D"header-section-number">2.1.1</span> Q=
uick Setup</h3>
<p>We (the authors) have used Ubuntu <span class=3D"citation">[6]</span> as=
 the operating system for doing OS development, running it both physically =
and virtually (using the virtual machine VirtualBox <span class=3D"citation=
">[7]</span>). A quick way to get everything up and running is to use the s=
ame setup as we did, since we know that these tools work with the samples p=
rovided in this book.</p>
<p>Once Ubuntu is installed, either physical or virtual, the following pack=
ages should be installed using <code>apt-get</code>:</p>
<pre class=3D"sourceCode bash"><code class=3D"sourceCode bash">    <span cl=
ass=3D"kw">sudo</span> apt-get install build-essential nasm genisoimage boc=
hs bochs-sdl</code></pre>
<h3 id=3D"programming-languages"><span class=3D"header-section-number">2.1.=
2</span> Programming Languages</h3>
<p>The operating system will be developed using the C programming language =
<span class=3D"citation">[8]</span><span class=3D"citation">[9]</span>, usi=
ng GCC <span class=3D"citation">[10]</span>. We use C because developing an=
 OS requires a very precise control of the generated code and direct access=
 to memory. Other languages that provide the same features can also be used=
, but this book will only cover C.</p>
<p>The code will make use of one type attribute that is specific for GCC:</=
p>
<pre><code>    __attribute__((packed))</code></pre>
<p>This attribute allows us to ensure that the compiler uses a memory layou=
t for a <code>struct</code> exactly as we define it in the code. This is ex=
plained in more detail in the next chapter.</p>
<p>Due to this attribute, the example code might be hard to compile using a=
 C compiler other than GCC.</p>
<p>For writing assembly code, we have chosen NASM <span class=3D"citation">=
[11]</span> as the assembler, since we prefer NASM=E2=80=99s syntax over GN=
U Assembler.</p>
<p>Bash <span class=3D"citation">[12]</span> will be used as the scripting =
language throughout the book.</p>
<h3 id=3D"host-operating-system"><span class=3D"header-section-number">2.1.=
3</span> Host Operating System</h3>
<p>All the code examples assumes that the code is being compiled on a UNIX =
like operating system. All code examples have been successfully compiled us=
ing Ubuntu <span class=3D"citation">[6]</span> versions 11.04 and 11.10.</p=
>
<h3 id=3D"build-system"><span class=3D"header-section-number">2.1.4</span> =
Build System</h3>
<p>Make <span class=3D"citation">[13]</span> has been used when constructin=
g the Makefile examples.</p>
<h3 id=3D"virtual-machine"><span class=3D"header-section-number">2.1.5</spa=
n> Virtual Machine</h3>
<p>When developing an OS it is very convenient to be able to run your code =
in a <em>virtual machine</em> instead of on a physical computer, since star=
ting your OS in a virtual machine is much faster than getting your OS onto =
a physical medium and then running it on a physical machine. Bochs <span cl=
ass=3D"citation">[14]</span> is an emulator for the x86 (IA-32) platform wh=
ich is well suited for OS development due to its debugging features. Other =
popular choices are QEMU <span class=3D"citation">[15]</span> and VirtualBo=
x <span class=3D"citation">[7]</span>. This book uses Bochs.</p>
<p>By using a virtual machine we cannot ensure that our OS works on real, p=
hysical hardware. The environment simulated by the virtual machine is desig=
ned to be very similar to their physical counterparts, and the OS can be te=
sted on one by just copying the executable to a CD and finding a suitable m=
achine.</p>
<h2 id=3D"booting"><span class=3D"header-section-number">2.2</span> Booting=
</h2>
<p>Booting an operating system consists of transferring control along a cha=
in of small programs, each one more =E2=80=9Cpowerful=E2=80=9D than the pre=
vious one, where the operating system is the last =E2=80=9Cprogram=E2=80=9D=
. See the following figure for an example of the boot process:</p>
<div class=3D"figure">
<img src=3D"https://littleosbook.github.io/images/boot_chain.png" alt=3D"An=
 example of the boot process. Each box is a program."><p class=3D"caption">=
An example of the boot process. Each box is a program.</p>
</div>
<h3 id=3D"bios"><span class=3D"header-section-number">2.2.1</span> BIOS</h3=
>
<p>When the PC is turned on, the computer will start a small program that a=
dheres to the <em>Basic Input Output System</em> (BIOS) <span class=3D"cita=
tion">[16]</span> standard. This program is usually stored on a read only m=
emory chip on the motherboard of the PC. The original role of the BIOS prog=
ram was to export some library functions for printing to the screen, readin=
g keyboard input etc. Modern operating systems do not use the BIOS=E2=80=99=
 functions, they use drivers that interact directly with the hardware, bypa=
ssing the BIOS. Today, BIOS mainly runs some early diagnostics (power-on-se=
lf-test) and then transfers control to the bootloader.</p>
<h3 id=3D"the-bootloader"><span class=3D"header-section-number">2.2.2</span=
> The Bootloader</h3>
<p>The BIOS program will transfer control of the PC to a program called a <=
em>bootloader</em>. The bootloader=E2=80=99s task is to transfer control to=
 us, the operating system developers, and our code. However, due to some re=
strictions<a href=3D"https://littleosbook.github.io/#fn1" class=3D"footnote=
Ref" id=3D"fnref1"><sup>1</sup></a> of the hardware and because of backward=
 compatibility, the bootloader is often split into two parts: the first par=
t of the bootloader will transfer control to the second part, which finally=
 gives control of the PC to the operating system.</p>
<p>Writing a bootloader involves writing a lot of low-level code that inter=
acts with the BIOS. Therefore, an existing bootloader will be used: the GNU=
 GRand Unified Bootloader (GRUB) <span class=3D"citation">[17]</span>.</p>
<p>Using GRUB, the operating system can be built as an ordinary ELF <span c=
lass=3D"citation">[18]</span> executable, which will be loaded by GRUB into=
 the correct memory location. The compilation of the kernel requires that t=
he code is laid out in memory in a specific way (how to compile the kernel =
will be discussed later in this chapter).</p>
<h3 id=3D"the-operating-system"><span class=3D"header-section-number">2.2.3=
</span> The Operating System</h3>
<p>GRUB will transfer control to the operating system by jumping to a posit=
ion in memory. Before the jump, GRUB will look for a magic number to ensure=
 that it is actually jumping to an OS and not some random code. This magic =
number is part of the <em>multiboot specification</em> <span class=3D"citat=
ion">[19]</span> which GRUB adheres to. Once GRUB has made the jump, the OS=
 has full control of the computer.</p>
<h2 id=3D"hello-cafebabe"><span class=3D"header-section-number">2.3</span> =
Hello Cafebabe</h2>
<p>This section will describe how to implement of the smallest possible OS =
that can be used together with GRUB. The only thing the OS will do is write=
 <code>0xCAFEBABE</code> to the <code>eax</code> register (most people woul=
d probably not even call this an OS).</p>
<h3 id=3D"compiling-the-operating-system"><span class=3D"header-section-num=
ber">2.3.1</span> Compiling the Operating System</h3>
<p>This part of the OS has to be written in assembly code, since C requires=
 a stack, which isn=E2=80=99t available (the chapter <a href=3D"https://lit=
tleosbook.github.io/#getting-to-c">=E2=80=9CGetting to C=E2=80=9D</a> descr=
ibes how to set one up). Save the following code in a file called <code>loa=
der.s</code>:</p>
<pre class=3D"sourceCode nasm"><code class=3D"sourceCode nasm">    <span cl=
ass=3D"kw">global</span> loader                   <span class=3D"co">; the =
entry symbol for ELF</span>

    MAGIC_NUMBER <span class=3D"dt">equ</span> <span class=3D"bn">0x1BADB00=
2</span>     <span class=3D"co">; define the magic number constant</span>
    FLAGS        <span class=3D"dt">equ</span><span class=3D"bn"> 0x0      =
      </span><span class=3D"co">; multiboot flags</span>
    CHECKSUM     <span class=3D"dt">equ</span> -MAGIC_NUMBER  <span class=
=3D"co">; calculate the checksum</span>
                                    <span class=3D"co">; (magic number + ch=
ecksum + flags should equal 0)</span>

    <span class=3D"kw">section</span> .text:                  <span class=
=3D"co">; start of the text (code) section</span>
    <span class=3D"kw">align</span> <span class=3D"dv">4</span>            =
             <span class=3D"co">; the code must be 4 byte aligned</span>
        <span class=3D"dt">dd</span> MAGIC_NUMBER             <span class=
=3D"co">; write the magic number to the machine code,</span>
        <span class=3D"dt">dd</span> FLAGS                    <span class=
=3D"co">; the flags,</span>
        <span class=3D"dt">dd</span> CHECKSUM                 <span class=
=3D"co">; and the checksum</span>

<span class=3D"fu">    loader:</span>                         <span class=
=3D"co">; the loader label (defined as entry point in linker script)</span>
        <span class=3D"kw">mov</span> <span class=3D"kw">eax</span>, <span =
class=3D"bn">0xCAFEBABE</span>         <span class=3D"co">; place the numbe=
r 0xCAFEBABE in the register eax</span>
<span class=3D"fu">    .loop:</span>
        <span class=3D"kw">jmp</span> .<span class=3D"kw">loop</span>      =
             <span class=3D"co">; loop forever</span></code></pre>
<p>The only thing this OS will do is write the very specific number <code>0=
xCAFEBABE</code> to the <code>eax</code> register. It is <em>very</em> unli=
kely that the number <code>0xCAFEBABE</code> would be in the <code>eax</cod=
e> register if the OS did <em>not</em> put it there.</p>
<p>The file <code>loader.s</code> can be compiled into a 32 bits ELF <span =
class=3D"citation">[18]</span> object file with the following command:</p>
<pre class=3D"sourceCode bash"><code class=3D"sourceCode bash">    <span cl=
ass=3D"kw">nasm</span> -f elf32 loader.s</code></pre>
<h3 id=3D"linking-the-kernel"><span class=3D"header-section-number">2.3.2</=
span> Linking the Kernel</h3>
<p>The code must now be linked to produce an executable file, which require=
s some extra thought compared to when linking most programs. We want GRUB t=
o load the kernel at a memory address larger than or equal to <code>0x00100=
000</code> (1 megabyte (MB)), because addresses lower than 1 MB are used by=
 GRUB itself, BIOS and memory-mapped I/O. Therefore, the following linker s=
cript is needed (written for GNU LD <span class=3D"citation">[20]</span>):<=
/p>
<pre><code>ENTRY(loader)                /* the name of the entry label */

SECTIONS {
    . =3D 0x00100000;          /* the code should be loaded at 1 MB */

    .text ALIGN (0x1000) :   /* align at 4 KB */
    {
        *(.text)             /* all text sections from all files */
    }

    .rodata ALIGN (0x1000) : /* align at 4 KB */
    {
        *(.rodata*)          /* all read-only data sections from all files =
*/
    }

    .data ALIGN (0x1000) :   /* align at 4 KB */
    {
        *(.data)             /* all data sections from all files */
    }

    .bss ALIGN (0x1000) :    /* align at 4 KB */
    {
        *(COMMON)            /* all COMMON sections from all files */
        *(.bss)              /* all bss sections from all files */
    }
}</code></pre>
<p>Save the linker script into a file called <code>link.ld</code>. The exec=
utable can now be linked with the following command:</p>
<pre class=3D"sourceCode bash"><code class=3D"sourceCode bash">    <span cl=
ass=3D"kw">ld</span> -T link.ld -melf_i386 loader.o -o kernel.elf</code></p=
re>
<p>The final executable will be called <code>kernel.elf</code>.</p>
<h3 id=3D"obtaining-grub"><span class=3D"header-section-number">2.3.3</span=
> Obtaining GRUB</h3>
<p>The GRUB version we will use is GRUB Legacy, since the OS ISO image can =
then be generated on systems using both GRUB Legacy and GRUB 2. More specif=
ically, the GRUB Legacy <code>stage2_eltorito</code> bootloader will be use=
d. This file can be built from GRUB 0.97 by downloading the source from <a =
href=3D"ftp://alpha.gnu.org/gnu/grub/grub-0.97.tar.gz">ftp://alpha.gnu.org/=
gnu/grub/grub-0.97.tar.gz</a>. However, the <code>configure</code> script d=
oesn=E2=80=99t work well with Ubuntu <span class=3D"citation">[21]</span>, =
so the binary file can be downloaded from <a href=3D"http://littleosbook.gi=
thub.com/files/stage2_eltorito">http://littleosbook.github.com/files/stage2=
_eltorito</a>. Copy the file <code>stage2_eltorito</code> to the folder tha=
t already contains <code>loader.s</code> and <code>link.ld</code>.</p>
<h3 id=3D"building-an-iso-image"><span class=3D"header-section-number">2.3.=
4</span> Building an ISO Image</h3>
<p>The executable must be placed on a media that can be loaded by a virtual=
 or physical machine. In this book we will use ISO <span class=3D"citation"=
>[22]</span> image files as the media, but one can also use floppy images, =
depending on what the virtual or physical machine supports.</p>
<p>We will create the kernel ISO image with the program <code>genisoimage</=
code>. A folder must first be created that contains the files that will be =
on the ISO image. The following commands create the folder and copy the fil=
es to their correct places:</p>
<pre class=3D"sourceCode bash"><code class=3D"sourceCode bash">    <span cl=
ass=3D"kw">mkdir</span> -p iso/boot/grub              <span class=3D"co"># =
create the folder structure</span>
    <span class=3D"kw">cp</span> stage2_eltorito iso/boot/grub/   <span cla=
ss=3D"co"># copy the bootloader</span>
    <span class=3D"kw">cp</span> kernel.elf iso/boot/             <span cla=
ss=3D"co"># copy the kernel</span></code></pre>
<p>A configuration file <code>menu.lst</code> for GRUB must be created. Thi=
s file tells GRUB where the kernel is located and configures some options:<=
/p>
<pre><code>    default=3D0
    timeout=3D0

    title os
    kernel /boot/kernel.elf</code></pre>
<p>Place the file <code>menu.lst</code> in the folder <code>iso/boot/grub/<=
/code>. The contents of the <code>iso</code> folder should now look like th=
e following figure:</p>
<pre><code>    iso
    |-- boot
      |-- grub
      | |-- menu.lst
      | |-- stage2_eltorito
      |-- kernel.elf</code></pre>
<p>The ISO image can then be generated with the following command:</p>
<pre><code>    genisoimage -R                              \
                -b boot/grub/stage2_eltorito    \
                -no-emul-boot                   \
                -boot-load-size 4               \
                -A os                           \
                -input-charset utf8             \
                -quiet                          \
                -boot-info-table                \
                -o os.iso                       \
                iso</code></pre>
<p>For more information about the flags used in the command, see the manual=
 for <code>genisoimage</code>.</p>
<p>The ISO image <code>os.iso</code> now contains the kernel executable, th=
e GRUB bootloader and the configuration file.</p>
<h3 id=3D"running-bochs"><span class=3D"header-section-number">2.3.5</span>=
 Running Bochs</h3>
<p>Now we can run the OS in the Bochs emulator using the <code>os.iso</code=
> ISO image. Bochs needs a configuration file to start and an example of a =
simple configuration file is given below:</p>
<pre><code>    megs:            32
    display_library: sdl
    romimage:        file=3D/usr/share/bochs/BIOS-bochs-latest
    vgaromimage:     file=3D/usr/share/bochs/VGABIOS-lgpl-latest
    ata0-master:     type=3Dcdrom, path=3Dos.iso, status=3Dinserted
    boot:            cdrom
    log:             bochslog.txt
    clock:           sync=3Drealtime, time0=3Dlocal
    cpu:             count=3D1, ips=3D1000000</code></pre>
<p>You might need to change the path to <code>romimage</code> and <code>vga=
romimage</code> depending on how you installed Bochs. More information abou=
t the Bochs config file can be found at Boch=E2=80=99s website <span class=
=3D"citation">[23]</span>.</p>
<p>If you saved the configuration in a file named <code>bochsrc.txt</code> =
then you can run Bochs with the following command:</p>
<pre><code>    bochs -f bochsrc.txt -q</code></pre>
<p>The flag <code>-f</code> tells Bochs to use the given configuration file=
 and the flag <code>-q</code> tells Bochs to skip the interactive start men=
u. You should now see Bochs starting and displaying a console with some inf=
ormation from GRUB on it.</p>
<p>After quitting Bochs, display the log produced by Boch:</p>
<pre><code>    cat bochslog.txt</code></pre>
<p>You should now see the contents of the registers of the CPU simulated by=
 Bochs somewhere in the output. If you find <code>RAX=3D00000000CAFEBABE</c=
ode> or <code>EAX=3DCAFEBABE</code> (depending on if you are running Bochs =
with or without 64 bit support) in the output then your OS has successfully=
 booted!</p>
<h2 id=3D"further-reading"><span class=3D"header-section-number">2.4</span>=
 Further Reading</h2>
<ul>
<li>Gustavo Duertes has written an in-depth article about what actually hap=
pens when a x86 computer boots up, <a href=3D"http://duartes.org/gustavo/bl=
og/post/how-computers-boot-up">http://duartes.org/gustavo/blog/post/how-com=
puters-boot-up</a></li>
<li>Gustavo continues to describe what the kernel does in the very early st=
ages at <a href=3D"http://duartes.org/gustavo/blog/post/kernel-boot-process=
">http://duartes.org/gustavo/blog/post/kernel-boot-process</a></li>
<li>The OSDev wiki also contains a nice article about booting an x86 comput=
er: <a href=3D"http://wiki.osdev.org/Boot_Sequence">http://wiki.osdev.org/B=
oot_Sequence</a></li>
</ul>
<h1 id=3D"getting-to-c"><span class=3D"header-section-number">3</span> Gett=
ing to C</h1>
<p>This chapter will show you how to use C instead of assembly code as the =
programming language for the OS. Assembly is very good for interacting with=
 the CPU and enables maximum control over every aspect of the code. However=
, at least for the authors, C is a much more convenient language to use. Th=
erefore, we would like to use C as much as possible and use assembly code o=
nly where it make sense.</p>
<h2 id=3D"setting-up-a-stack"><span class=3D"header-section-number">3.1</sp=
an> Setting Up a Stack</h2>
<p>One prerequisite for using C is a stack, since all non-trivial C program=
s use a stack. Setting up a stack is not harder than to make the <code>esp<=
/code> register point to the end of an area of free memory (remember that t=
he stack grows towards lower addresses on the x86) that is correctly aligne=
d (alignment on 4 bytes is recommended from a performance perspective).</p>
<p>We could point <code>esp</code> to a random area in memory since, so far=
, the only thing in the memory is GRUB, BIOS, the OS kernel and some memory=
-mapped I/O. This is not a good idea - we don=E2=80=99t know how much memor=
y is available or if the area <code>esp</code> would point to is used by so=
mething else. A better idea is to reserve a piece of uninitialized memory i=
n the <code>bss</code> section in the ELF file of the kernel. It is better =
to use the <code>bss</code> section instead of the <code>data</code> sectio=
n to reduce the size of the OS executable. Since GRUB understands ELF, GRUB=
 will allocate any memory reserved in the <code>bss</code> section when loa=
ding the OS.</p>
<p>The NASM pseudo-instruction <code>resb</code> <span class=3D"citation">[=
24]</span> can be used to declare uninitialized data:</p>
<pre class=3D"sourceCode nasm"><code class=3D"sourceCode nasm">    KERNEL_S=
TACK_SIZE <span class=3D"dt">equ</span> <span class=3D"dv">4096</span>     =
             <span class=3D"co">; size of stack in bytes</span>

    <span class=3D"kw">section</span> .bss
    <span class=3D"kw">align</span> <span class=3D"dv">4</span>            =
                         <span class=3D"co">; align at 4 bytes</span>
<span class=3D"fu">    kernel_stack:</span>                               <=
span class=3D"co">; label points to beginning of memory</span>
        <span class=3D"dt">resb</span> KERNEL_STACK_SIZE                  <=
span class=3D"co">; reserve stack for the kernel</span></code></pre>
<p>There is no need to worry about the use of uninitialized memory for the =
stack, since it is not possible to read a stack location that has not been =
written (without manual pointer fiddling). A (correct) program can not pop =
an element from the stack without having pushed an element onto the stack f=
irst. Therefore, the memory locations of the stack will always be written t=
o before they are being read.</p>
<p>The stack pointer is then set up by pointing <code>esp</code> to the end=
 of the <code>kernel_stack</code> memory:</p>
<pre class=3D"sourceCode nasm"><code class=3D"sourceCode nasm">    <span cl=
ass=3D"kw">mov</span> <span class=3D"kw">esp</span>, kernel_stack + KERNEL_=
STACK_SIZE   <span class=3D"co">; point esp to the start of the</span>
                                                <span class=3D"co">; stack =
(end of memory area)</span></code></pre>
<h2 id=3D"calling-c-code-from-assembly"><span class=3D"header-section-numbe=
r">3.2</span> Calling C Code From Assembly</h2>
<p>The next step is to call a C function from assembly code. There are many=
 different conventions for how to call C code from assembly code <span clas=
s=3D"citation">[25]</span>. This book uses the <em>cdecl</em> calling conve=
ntion, since that is the one used by GCC. The cdecl calling convention stat=
es that arguments to a function should be passed via the stack (on x86). Th=
e arguments of the function should be pushed on the stack in a right-to-lef=
t order, that is, you push the rightmost argument first. The return value o=
f the function is placed in the <code>eax</code> register. The following co=
de shows an example:</p>
<pre class=3D"sourceCode c"><code class=3D"sourceCode c">    <span class=3D=
"co">/* The C function */</span>
    <span class=3D"dt">int</span> sum_of_three(<span class=3D"dt">int</span=
> arg1, <span class=3D"dt">int</span> arg2, <span class=3D"dt">int</span> a=
rg3)
    {
        <span class=3D"kw">return</span> arg1 + arg2 + arg3;
    }</code></pre>
<pre class=3D"sourceCode nasm"><code class=3D"sourceCode nasm">    <span cl=
ass=3D"co">; The assembly code</span>
    external sum_of_three   <span class=3D"co">; the function sum_of_three =
is defined elsewhere</span>

    <span class=3D"kw">push</span> <span class=3D"dt">dword</span> <span cl=
ass=3D"dv">3</span>            <span class=3D"co">; arg3</span>
    <span class=3D"kw">push</span> <span class=3D"dt">dword</span> <span cl=
ass=3D"dv">2</span>            <span class=3D"co">; arg2</span>
    <span class=3D"kw">push</span> <span class=3D"dt">dword</span> <span cl=
ass=3D"dv">1</span>            <span class=3D"co">; arg1</span>
    <span class=3D"kw">call</span> sum_of_three       <span class=3D"co">; =
call the function, the result will be in eax</span></code></pre>
<h3 id=3D"packing-structs"><span class=3D"header-section-number">3.2.1</spa=
n> Packing Structs</h3>
<p>In the rest of this book, you will often come across =E2=80=9Cconfigurat=
ion bytes=E2=80=9D that are a collection of bits in a very specific order. =
Below follows an example with 32 bits:</p>
<pre><code>Bit:     | 31     24 | 23          8 | 7     0 |
Content: | index     | address       | config  |</code></pre>
<p>Instead of using an unsigned integer, <code>unsigned int</code>, for han=
dling such configurations, it is much more convenient to use =E2=80=9Cpacke=
d structures=E2=80=9D:</p>
<pre class=3D"sourceCode C"><code class=3D"sourceCode c">    <span class=3D=
"kw">struct</span> example {
        <span class=3D"dt">unsigned</span> <span class=3D"dt">char</span> c=
onfig;   <span class=3D"co">/* bit 0 - 7   */</span>
        <span class=3D"dt">unsigned</span> <span class=3D"dt">short</span> =
address; <span class=3D"co">/* bit 8 - 23  */</span>
        <span class=3D"dt">unsigned</span> <span class=3D"dt">char</span> i=
ndex;    <span class=3D"co">/* bit 24 - 31 */</span>
    };</code></pre>
<p>When using the <code>struct</code> in the previous example there is no g=
uarantee that the size of the <code>struct</code> will be exactly 32 bits -=
 the compiler can add some padding between elements for various reasons, fo=
r example to speed up element access or due to requirements set by the hard=
ware and/or compiler. When using a <code>struct</code> to represent configu=
ration bytes, it is very important that the compiler does <em>not</em> add =
any padding, because the <code>struct</code> will eventually be treated as =
a 32 bit unsigned integer by the hardware. The attribute <code>packed</code=
> can be used to force GCC to <em>not</em> add any padding:</p>
<pre class=3D"sourceCode C"><code class=3D"sourceCode c">    <span class=3D=
"kw">struct</span> example {
        <span class=3D"dt">unsigned</span> <span class=3D"dt">char</span> c=
onfig;   <span class=3D"co">/* bit 0 - 7   */</span>
        <span class=3D"dt">unsigned</span> <span class=3D"dt">short</span> =
address; <span class=3D"co">/* bit 8 - 23  */</span>
        <span class=3D"dt">unsigned</span> <span class=3D"dt">char</span> i=
ndex;    <span class=3D"co">/* bit 24 - 31 */</span>
    } __attribute__((packed));</code></pre>
<p>Note that <code>__attribute__((packed))</code> is not part of the C stan=
dard - it might not work with all C compilers.</p>
<h2 id=3D"compiling-c-code"><span class=3D"header-section-number">3.3</span=
> Compiling C Code</h2>
<p>When compiling the C code for the OS, a lot of flags to GCC need to be u=
sed. This is because the C code should <em>not</em> assume the presence of =
a standard library, since there is no standard library available for our OS=
. For more information about the flags, see the GCC manual.</p>
<p>The flags used for compiling the C code are:</p>
<pre><code>    -m32 -nostdlib -nostdinc -fno-builtin -fno-stack-protector -=
nostartfiles
    -nodefaultlibs</code></pre>
<p>As always when writing C programs we recommend turning on all warnings a=
nd treat warnings as errors:</p>
<pre><code>    -Wall -Wextra -Werror</code></pre>
<p>You can now create a function <code>kmain</code> in a file called <code>=
kmain.c</code> that you call from <code>loader.s</code>. At this point, <co=
de>kmain</code> probably won=E2=80=99t need any arguments (but in later cha=
pters it will).</p>
<h2 id=3D"build-tools"><span class=3D"header-section-number">3.4</span> Bui=
ld Tools</h2>
<p>Now is also probably a good time to set up some build tools to make it e=
asier to compile and test-run the OS. We recommend using <code>make</code> =
<span class=3D"citation">[13]</span>, but there are plenty of other build s=
ystems available. A simple Makefile for the OS could look like the followin=
g example:</p>
<pre class=3D"sourceCode Makefile"><code class=3D"sourceCode makefile">    =
<span class=3D"dt">OBJECTS </span><span class=3D"ch">=3D</span><span class=
=3D"st"> loader.o kmain.o</span>
    <span class=3D"dt">CC </span><span class=3D"ch">=3D</span><span class=
=3D"st"> gcc</span>
    <span class=3D"dt">CFLAGS </span><span class=3D"ch">=3D</span><span cla=
ss=3D"st"> -m32 -nostdlib -nostdinc -fno-builtin -fno-stack-protector </spa=
n><span class=3D"ch">\</span>
             <span class=3D"ch">-</span><span class=3D"fu">nostartfiles -no=
defaultlibs -Wall -Wextra -Werror -c</span>
    <span class=3D"dt">LDFLAGS </span><span class=3D"ch">=3D</span><span cl=
ass=3D"st"> -T link.ld -melf_i386</span>
    <span class=3D"dt">AS </span><span class=3D"ch">=3D</span><span class=
=3D"st"> nasm</span>
    <span class=3D"dt">ASFLAGS </span><span class=3D"ch">=3D</span><span cl=
ass=3D"st"> -f elf</span>

    all: kernel.elf

    kernel.elf: <span class=3D"ch">$(</span><span class=3D"dt">OBJECTS</spa=
n><span class=3D"ch">)</span>
        ld <span class=3D"ch">$(</span><span class=3D"dt">LDFLAGS</span><sp=
an class=3D"ch">)</span> <span class=3D"ch">$(</span><span class=3D"dt">OBJ=
ECTS</span><span class=3D"ch">)</span> -o kernel.elf

    os.iso: kernel.elf
        cp kernel.elf iso/boot/kernel.elf
        genisoimage -R                              \
                    <span class=3D"ch">-</span><span class=3D"fu">b boot/gr=
ub/stage2_eltorito    </span><span class=3D"ch">\</span>
                    <span class=3D"ch">-</span><span class=3D"fu">no-emul-b=
oot                   </span><span class=3D"ch">\</span>
                    <span class=3D"ch">-</span><span class=3D"fu">boot-load=
-size 4               </span><span class=3D"ch">\</span>
                    <span class=3D"ch">-</span><span class=3D"fu">A os     =
                      </span><span class=3D"ch">\</span>
                    <span class=3D"ch">-</span><span class=3D"fu">input-cha=
rset utf8             </span><span class=3D"ch">\</span>
                    <span class=3D"ch">-</span><span class=3D"fu">quiet    =
                      </span><span class=3D"ch">\</span>
                    <span class=3D"ch">-</span><span class=3D"fu">boot-info=
-table                </span><span class=3D"ch">\</span>
                    <span class=3D"ch">-</span><span class=3D"fu">o os.iso =
                      </span><span class=3D"ch">\</span>
                    iso

    run: os.iso
        bochs -f bochsrc.txt -q

    %.o: %.c
        <span class=3D"ch">$(</span><span class=3D"dt">CC</span><span class=
=3D"ch">)</span> <span class=3D"ch">$(</span><span class=3D"dt">CFLAGS</spa=
n><span class=3D"ch">)</span>  <span class=3D"ch">$&lt;</span> -o <span cla=
ss=3D"ch">$@</span>

    %.o: %.s
        <span class=3D"ch">$(</span><span class=3D"dt">AS</span><span class=
=3D"ch">)</span> <span class=3D"ch">$(</span><span class=3D"dt">ASFLAGS</sp=
an><span class=3D"ch">)</span> <span class=3D"ch">$&lt;</span> -o <span cla=
ss=3D"ch">$@</span>

    clean:
        rm -rf *.o kernel.elf os.iso</code></pre>
<p>The contents of your working directory should now look like the followin=
g figure:</p>
<pre><code>    .
    |-- bochsrc.txt
    |-- iso
    |   |-- boot
    |     |-- grub
    |       |-- menu.lst
    |       |-- stage2_eltorito
    |-- kmain.c
    |-- loader.s
    |-- Makefile</code></pre>
<p>You should now be able to start the OS with the simple command <code>mak=
e run</code>, which will compile the kernel and boot it up in Bochs (as def=
ined in the Makefile above).</p>
<h2 id=3D"further-reading-1"><span class=3D"header-section-number">3.5</spa=
n> Further Reading</h2>
<ul>
<li>Kernigan &amp; Richie=E2=80=99s book, <em>The C Programming Language, S=
econd Edition</em>, <span class=3D"citation">[8]</span> is great for learni=
ng about all the aspects of C.</li>
</ul>
<h1 id=3D"output"><span class=3D"header-section-number">4</span> Output</h1=
>
<p>This chapter will present how to display text on the console as well as =
writing data to the serial port. Furthermore, we will create our first <em>=
driver</em>, that is, code that acts as a layer between the kernel and the =
hardware, providing a higher abstraction than communicating directly with t=
he hardware. The first part of this chapter is about creating a driver for =
the <em>framebuffer</em> <span class=3D"citation">[26]</span> to be able to=
 display text on the console. The second part shows how to create a driver =
for the serial port. Bochs can store output from the serial port in a file,=
 effectively creating a logging mechanism for the operating system.</p>
<h2 id=3D"interacting-with-the-hardware"><span class=3D"header-section-numb=
er">4.1</span> Interacting with the Hardware</h2>
<p>There are usually two different ways to interact with the hardware, <em>=
memory-mapped I/O</em> and <em>I/O ports</em>.</p>
<p>If the hardware uses memory-mapped I/O then you can write to a specific =
memory address and the hardware will be updated with the new data. One exam=
ple of this is the framebuffer, which will be discussed in more detail late=
r. For example, if you write the value <code>0x410F</code> to address <code=
>0x000B8000</code>, you will see the letter A in white color on a black bac=
kground (see the section on <a href=3D"https://littleosbook.github.io/#the-=
framebuffer">the framebuffer</a> for more details).</p>
<p>If the hardware uses I/O ports then the assembly code instructions <code=
>out</code> and <code>in</code> must be used to communicate with the hardwa=
re. The instruction <code>out</code> takes two parameters: the address of t=
he I/O port and the data to send. The instruction <code>in</code> takes a s=
ingle parameter, the address of the I/O port, and returns data from the har=
dware. One can think of I/O ports as communicating with hardware the same w=
ay as you communicate with a server using sockets. The cursor (the blinking=
 rectangle) of the framebuffer is one example of hardware controlled via I/=
O ports on a PC.</p>
<h2 id=3D"the-framebuffer"><span class=3D"header-section-number">4.2</span>=
 The Framebuffer</h2>
<p>The framebuffer is a hardware device that is capable of displaying a buf=
fer of memory on the screen <span class=3D"citation">[26]</span>. The frame=
buffer has 80 columns and 25 rows, and the row and column indices start at =
0 (so rows are labelled 0 - 24).</p>
<h3 id=3D"writing-text"><span class=3D"header-section-number">4.2.1</span> =
Writing Text</h3>
<p>Writing text to the console via the framebuffer is done with memory-mapp=
ed I/O. The starting address of the memory-mapped I/O for the framebuffer i=
s <code>0x000B8000</code> <span class=3D"citation">[27]</span>. The memory =
is divided into 16 bit cells, where the 16 bits determine both the characte=
r, the foreground color and the background color. The highest eight bits is=
 the ASCII <span class=3D"citation">[28]</span> value of the character, bit=
 7 - 4 the background and bit 3 - 0 the foreground, as can be seen in the f=
ollowing figure:</p>
<pre><code>Bit:     | 15 14 13 12 11 10 9 8 | 7 6 5 4 | 3 2 1 0 |
Content: | ASCII                 | FG      | BG      |</code></pre>
<p>The available colors are shown in the following table:</p>
<table>
<thead>
<tr class=3D"header">
<th align=3D"right">Color</th>
<th align=3D"left">Value</th>
<th align=3D"right">Color</th>
<th align=3D"left">Value</th>
<th align=3D"right">Color</th>
<th align=3D"left">Value</th>
<th align=3D"right">Color</th>
<th align=3D"left">Value</th>
</tr>
</thead>
<tbody>
<tr class=3D"odd">
<td align=3D"right">Black</td>
<td align=3D"left">0</td>
<td align=3D"right">Red</td>
<td align=3D"left">4</td>
<td align=3D"right">Dark grey</td>
<td align=3D"left">8</td>
<td align=3D"right">Light red</td>
<td align=3D"left">12</td>
</tr>
<tr class=3D"even">
<td align=3D"right">Blue</td>
<td align=3D"left">1</td>
<td align=3D"right">Magenta</td>
<td align=3D"left">5</td>
<td align=3D"right">Light blue</td>
<td align=3D"left">9</td>
<td align=3D"right">Light magenta</td>
<td align=3D"left">13</td>
</tr>
<tr class=3D"odd">
<td align=3D"right">Green</td>
<td align=3D"left">2</td>
<td align=3D"right">Brown</td>
<td align=3D"left">6</td>
<td align=3D"right">Light green</td>
<td align=3D"left">10</td>
<td align=3D"right">Light brown</td>
<td align=3D"left">14</td>
</tr>
<tr class=3D"even">
<td align=3D"right">Cyan</td>
<td align=3D"left">3</td>
<td align=3D"right">Light grey</td>
<td align=3D"left">7</td>
<td align=3D"right">Light cyan</td>
<td align=3D"left">11</td>
<td align=3D"right">White</td>
<td align=3D"left">15</td>
</tr>
</tbody>
</table>
<p>The first cell corresponds to row zero, column zero on the console. Usin=
g an ASCII table, one can see that A corresponds to 65 or <code>0x41</code>=
. Therefore, to write the character A with a green foreground (2) and dark =
grey background (8) at place (0,0), the following assembly code instruction=
 is used:</p>
<pre class=3D"sourceCode nasm"><code class=3D"sourceCode nasm">    <span cl=
ass=3D"kw">mov</span> [<span class=3D"bn">0x000B8000</span>]<span class=3D"=
bn">, 0x4128</span></code></pre>
<p>The second cell then corresponds to row zero, column one and its address=
 is therefore:</p>
<pre><code>    0x000B8000 + 16 =3D 0x000B8010</code></pre>
<p>Writing to the framebuffer can also be done in C by treating the address=
 <code>0x000B8000</code> as a char pointer, <code>char *fb =3D (char *) 0x0=
00B8000</code>. Then, writing A at place (0,0) with green foreground and da=
rk grey background becomes:</p>
<pre class=3D"sourceCode nasm"><code class=3D"sourceCode nasm">    fb[<span=
 class=3D"dv">0</span>] =3D <span class=3D"st">'A'</span><span class=3D"co"=
>;</span>
    fb[<span class=3D"dv">1</span>] =3D <span class=3D"bn">0x28</span><span=
 class=3D"co">;</span></code></pre>
<p>The following code shows how this can be wrapped into a function:</p>
<pre class=3D"sourceCode c"><code class=3D"sourceCode c">    <span class=3D=
"co">/** fb_write_cell:</span>
<span class=3D"co">     *  Writes a character with the given foreground and=
 background to position i</span>
<span class=3D"co">     *  in the framebuffer.</span>
<span class=3D"co">     *</span>
<span class=3D"co">     *  </span><span class=3D"kw">@param</span><span cla=
ss=3D"co"> </span><span class=3D"kw">i</span><span class=3D"co">  The locat=
ion in the framebuffer</span>
<span class=3D"co">     *  </span><span class=3D"kw">@param</span><span cla=
ss=3D"co"> </span><span class=3D"kw">c</span><span class=3D"co">  The chara=
cter</span>
<span class=3D"co">     *  </span><span class=3D"kw">@param</span><span cla=
ss=3D"co"> </span><span class=3D"kw">fg</span><span class=3D"co"> The foreg=
round color</span>
<span class=3D"co">     *  </span><span class=3D"kw">@param</span><span cla=
ss=3D"co"> </span><span class=3D"kw">bg</span><span class=3D"co"> The backg=
round color</span>
<span class=3D"co">     */</span>
    <span class=3D"dt">void</span> fb_write_cell(<span class=3D"dt">unsigne=
d</span> <span class=3D"dt">int</span> i, <span class=3D"dt">char</span> c,=
 <span class=3D"dt">unsigned</span> <span class=3D"dt">char</span> fg, <spa=
n class=3D"dt">unsigned</span> <span class=3D"dt">char</span> bg)
    {
        fb[i] =3D c;
        fb[i + <span class=3D"dv">1</span>] =3D ((fg &amp; <span class=3D"b=
n">0x0F</span>) &lt;&lt; <span class=3D"dv">4</span>) | (bg &amp; <span cla=
ss=3D"bn">0x0F</span>)
    }</code></pre>
<p>The function can then be used as follows:</p>
<pre class=3D"sourceCode c"><code class=3D"sourceCode c">    <span class=3D=
"ot">#define FB_GREEN     2</span>
    <span class=3D"ot">#define FB_DARK_GREY 8</span>

    fb_write_cell(<span class=3D"dv">0</span>, 'A', FB_GREEN, FB_DARK_GREY)=
;</code></pre>
<h3 id=3D"moving-the-cursor"><span class=3D"header-section-number">4.2.2</s=
pan> Moving the Cursor</h3>
<p>Moving the cursor of the framebuffer is done via two different I/O ports=
. The cursor=E2=80=99s position is determined with a 16 bits integer: 0 mea=
ns row zero, column zero; 1 means row zero, column one; 80 means row one, c=
olumn zero and so on. Since the position is 16 bits large, and the <code>ou=
t</code> assembly code instruction argument is 8 bits, the position must be=
 sent in two turns, first 8 bits then the next 8 bits. The framebuffer has =
two I/O ports, one for accepting the data, and one for describing the data =
being received. Port <code>0x3D4</code> <span class=3D"citation">[29]</span=
> is the port that describes the data and port <code>0x3D5</code> <span cla=
ss=3D"citation">[29]</span> is for the data itself.</p>
<p>To set the cursor at row one, column zero (position <code>80 =3D 0x0050<=
/code>), one would use the following assembly code instructions:</p>
<pre class=3D"sourceCode nasm"><code class=3D"sourceCode nasm">    <span cl=
ass=3D"kw">out</span> <span class=3D"bn">0x3D4</span>, <span class=3D"dv">1=
4</span>      <span class=3D"co">; 14 tells the framebuffer to expect the h=
ighest 8 bits of the position</span>
    <span class=3D"kw">out</span> <span class=3D"bn">0x3D5, 0x00    </span>=
<span class=3D"co">; sending the highest 8 bits of 0x0050</span>
    <span class=3D"kw">out</span> <span class=3D"bn">0x3D4</span>, <span cl=
ass=3D"dv">15</span>      <span class=3D"co">; 15 tells the framebuffer to =
expect the lowest 8 bits of the position</span>
    <span class=3D"kw">out</span> <span class=3D"bn">0x3D5, 0x50    </span>=
<span class=3D"co">; sending the lowest 8 bits of 0x0050</span></code></pre=
>
<p>The <code>out</code> assembly code instruction can=E2=80=99t be executed=
 directly in C. Therefore it is a good idea to wrap <code>out</code> in a f=
unction in assembly code which can be accessed from C via the cdecl calling=
 standard <span class=3D"citation">[25]</span>:</p>
<pre class=3D"sourceCode nasm"><code class=3D"sourceCode nasm">    <span cl=
ass=3D"kw">global</span> outb             <span class=3D"co">; make the lab=
el outb visible outside this file</span>

    <span class=3D"co">; outb - send a byte to an I/O port</span>
    <span class=3D"co">; stack: [esp + 8] the data byte</span>
    <span class=3D"co">;        [esp + 4] the I/O port</span>
    <span class=3D"co">;        [esp    ] return address</span>
<span class=3D"fu">    outb:</span>
        <span class=3D"kw">mov</span> <span class=3D"kw">al</span>, [<span =
class=3D"kw">esp</span> + <span class=3D"dv">8</span>]    <span class=3D"co=
">; move the data to be sent into the al register</span>
        <span class=3D"kw">mov</span> <span class=3D"kw">dx</span>, [<span =
class=3D"kw">esp</span> + <span class=3D"dv">4</span>]    <span class=3D"co=
">; move the address of the I/O port into the dx register</span>
        <span class=3D"kw">out</span> <span class=3D"kw">dx</span>, <span c=
lass=3D"kw">al</span>           <span class=3D"co">; send the data to the I=
/O port</span>
        <span class=3D"kw">ret</span>                  <span class=3D"co">;=
 return to the calling function</span></code></pre>
<p>By storing this function in a file called <code>io.s</code> and also cre=
ating a header <code>io.h</code>, the <code>out</code> assembly code instru=
ction can be conveniently accessed from C:</p>
<pre class=3D"sourceCode c"><code class=3D"sourceCode c">    <span class=3D=
"ot">#ifndef INCLUDE_IO_H</span>
    <span class=3D"ot">#define INCLUDE_IO_H</span>

    <span class=3D"co">/** outb:</span>
<span class=3D"co">     *  Sends the given data to the given I/O port. Defi=
ned in io.s</span>
<span class=3D"co">     *</span>
<span class=3D"co">     *  </span><span class=3D"kw">@param</span><span cla=
ss=3D"co"> </span><span class=3D"kw">port</span><span class=3D"co"> The I/O=
 port to send the data to</span>
<span class=3D"co">     *  </span><span class=3D"kw">@param</span><span cla=
ss=3D"co"> </span><span class=3D"kw">data</span><span class=3D"co"> The dat=
a to send to the I/O port</span>
<span class=3D"co">     */</span>
    <span class=3D"dt">void</span> outb(<span class=3D"dt">unsigned</span> =
<span class=3D"dt">short</span> port, <span class=3D"dt">unsigned</span> <s=
pan class=3D"dt">char</span> data);

    <span class=3D"ot">#endif </span><span class=3D"co">/* INCLUDE_IO_H */<=
/span></code></pre>
<p>Moving the cursor can now be wrapped in a C function:</p>
<pre class=3D"sourceCode c"><code class=3D"sourceCode c">    <span class=3D=
"ot">#include "io.h"</span>

    <span class=3D"co">/* The I/O ports */</span>
    <span class=3D"ot">#define FB_COMMAND_PORT         0x3D4</span>
    <span class=3D"ot">#define FB_DATA_PORT            0x3D5</span>

    <span class=3D"co">/* The I/O port commands */</span>
    <span class=3D"ot">#define FB_HIGH_BYTE_COMMAND    14</span>
    <span class=3D"ot">#define FB_LOW_BYTE_COMMAND     15</span>

    <span class=3D"co">/** fb_move_cursor:</span>
<span class=3D"co">     *  Moves the cursor of the framebuffer to the given=
 position</span>
<span class=3D"co">     *</span>
<span class=3D"co">     *  </span><span class=3D"kw">@param</span><span cla=
ss=3D"co"> </span><span class=3D"kw">pos</span><span class=3D"co"> The new =
position of the cursor</span>
<span class=3D"co">     */</span>
    <span class=3D"dt">void</span> fb_move_cursor(<span class=3D"dt">unsign=
ed</span> <span class=3D"dt">short</span> pos)
    {
        outb(FB_COMMAND_PORT, FB_HIGH_BYTE_COMMAND);
        outb(FB_DATA_PORT,    ((pos &gt;&gt; <span class=3D"dv">8</span>) &=
amp; <span class=3D"bn">0x00FF</span>));
        outb(FB_COMMAND_PORT, FB_LOW_BYTE_COMMAND);
        outb(FB_DATA_PORT,    pos &amp; <span class=3D"bn">0x00FF</span>);
    }</code></pre>
<h3 id=3D"the-driver"><span class=3D"header-section-number">4.2.3</span> Th=
e Driver</h3>
<p>The driver should provide an interface that the rest of the code in the =
OS will use for interacting with the framebuffer. There is no right or wron=
g in what functionality the interface should provide, but a suggestion is t=
o have a <code>write</code> function with the following declaration:</p>
<pre class=3D"sourceCode c"><code class=3D"sourceCode c">    <span class=3D=
"dt">int</span> write(<span class=3D"dt">char</span> *buf, <span class=3D"d=
t">unsigned</span> <span class=3D"dt">int</span> len);</code></pre>
<p>The <code>write</code> function writes the contents of the buffer <code>=
buf</code> of length <code>len</code> to the screen. The <code>write</code>=
 function should automatically advance the cursor after a character has bee=
n written and scroll the screen if necessary.</p>
<h2 id=3D"the-serial-ports"><span class=3D"header-section-number">4.3</span=
> The Serial Ports</h2>
<p>The serial port <span class=3D"citation">[30]</span> is an interface for=
 communicating between hardware devices and although it is available on alm=
ost all motherboards, it is seldom exposed to the user in the form of a DE-=
9 connector nowadays. The serial port is easy to use, and, more importantly=
, it can be used as a logging utility in Bochs. If a computer has support f=
or a serial port, then it usually has support for multiple serial ports, bu=
t we will only make use of one of the ports. This is because we will only u=
se the serial ports for logging. Furthermore, we will only use the serial p=
orts for output, not input. The serial ports are completely controlled via =
I/O ports.</p>
<h3 id=3D"configuring-the-serial-port"><span class=3D"header-section-number=
">4.3.1</span> Configuring the Serial Port</h3>
<p>The first data that need to be sent to the serial port is configuration =
data. In order for two hardware devices to be able to talk to each other th=
ey must agree upon a couple of things. These things include:</p>
<ul>
<li>The speed used for sending data (bit or baud rate)</li>
<li>If any error checking should be used for the data (parity bit, stop bit=
s)</li>
<li>The number of bits that represent a unit of data (data bits)</li>
</ul>
<h3 id=3D"configuring-the-line"><span class=3D"header-section-number">4.3.2=
</span> Configuring the Line</h3>
<p>Configuring the line means to configure how data is being sent over the =
line. The serial port has an I/O port, the <em>line command port</em>, that=
 is used for configuration.</p>
<p>First the speed for sending data will be set. The serial port has an int=
ernal clock that runs at 115200 Hz. Setting the speed means sending a divis=
or to the serial port, for example sending 2 results in a speed of <code>11=
5200 / 2 =3D 57600</code> Hz.</p>
<p>The divisor is a 16 bit number but we can only send 8 bits at a time. We=
 must therefore send an instruction telling the serial port to first expect=
 the highest 8 bits, then the lowest 8 bits. This is done by sending <code>=
0x80</code> to the line command port. An example is shown below:</p>
<pre class=3D"sourceCode c"><code class=3D"sourceCode c">    <span class=3D=
"ot">#include "io.h" </span><span class=3D"co">/* io.h is implement in the =
section "Moving the cursor" */</span>

    <span class=3D"co">/* The I/O ports */</span>

    <span class=3D"co">/* All the I/O ports are calculated relative to the =
data port. This is because</span>
<span class=3D"co">     * all serial ports (COM1, COM2, COM3, COM4) have th=
eir ports in the same</span>
<span class=3D"co">     * order, but they start at different values.</span>
<span class=3D"co">     */</span>

    <span class=3D"ot">#define SERIAL_COM1_BASE                0x3F8      <=
/span><span class=3D"co">/* COM1 base port */</span>

    <span class=3D"ot">#define SERIAL_DATA_PORT(base)          (base)</span=
>
    <span class=3D"ot">#define SERIAL_FIFO_COMMAND_PORT(base)  (base + 2)</=
span>
    <span class=3D"ot">#define SERIAL_LINE_COMMAND_PORT(base)  (base + 3)</=
span>
    <span class=3D"ot">#define SERIAL_MODEM_COMMAND_PORT(base) (base + 4)</=
span>
    <span class=3D"ot">#define SERIAL_LINE_STATUS_PORT(base)   (base + 5)</=
span>

    <span class=3D"co">/* The I/O port commands */</span>

    <span class=3D"co">/* SERIAL_LINE_ENABLE_DLAB:</span>
<span class=3D"co">     * Tells the serial port to expect first the highest=
 8 bits on the data port,</span>
<span class=3D"co">     * then the lowest 8 bits will follow</span>
<span class=3D"co">     */</span>
    <span class=3D"ot">#define SERIAL_LINE_ENABLE_DLAB         0x80</span>

    <span class=3D"co">/** serial_configure_baud_rate:</span>
<span class=3D"co">     *  Sets the speed of the data being sent. The defau=
lt speed of a serial</span>
<span class=3D"co">     *  port is 115200 bits/s. The argument is a divisor=
 of that number, hence</span>
<span class=3D"co">     *  the resulting speed becomes (115200 / divisor) b=
its/s.</span>
<span class=3D"co">     *</span>
<span class=3D"co">     *  </span><span class=3D"kw">@param</span><span cla=
ss=3D"co"> </span><span class=3D"kw">com</span><span class=3D"co">      The=
 COM port to configure</span>
<span class=3D"co">     *  </span><span class=3D"kw">@param</span><span cla=
ss=3D"co"> </span><span class=3D"kw">divisor</span><span class=3D"co">  The=
 divisor</span>
<span class=3D"co">     */</span>
    <span class=3D"dt">void</span> serial_configure_baud_rate(<span class=
=3D"dt">unsigned</span> <span class=3D"dt">short</span> com, <span class=3D=
"dt">unsigned</span> <span class=3D"dt">short</span> divisor)
    {
        outb(SERIAL_LINE_COMMAND_PORT(com),
             SERIAL_LINE_ENABLE_DLAB);
        outb(SERIAL_DATA_PORT(com),
             (divisor &gt;&gt; <span class=3D"dv">8</span>) &amp; <span cla=
ss=3D"bn">0x00FF</span>);
        outb(SERIAL_DATA_PORT(com),
             divisor &amp; <span class=3D"bn">0x00FF</span>);
    }</code></pre>
<p>The way that data should be sent must be configured. This is also done v=
ia the line command port by sending a byte. The layout of the 8 bits looks =
like the following:</p>
<pre><code>Bit:     | 7 | 6 | 5 4 3 | 2 | 1 0 |
Content: | d | b | prty  | s | dl  |</code></pre>
<p>A description for each name can be found in the table below (and in <spa=
n class=3D"citation">[31]</span>):</p>
<table>
<thead>
<tr class=3D"header">
<th align=3D"right">Name</th>
<th align=3D"left">Description</th>
</tr>
</thead>
<tbody>
<tr class=3D"odd">
<td align=3D"right">d</td>
<td align=3D"left">Enables (<code>d =3D 1</code>) or disables (<code>d =3D =
0</code>) DLAB</td>
</tr>
<tr class=3D"even">
<td align=3D"right">b</td>
<td align=3D"left">If break control is enabled (<code>b =3D 1</code>) or di=
sabled (<code>b =3D 0</code>)</td>
</tr>
<tr class=3D"odd">
<td align=3D"right">prty</td>
<td align=3D"left">The number of parity bits to use</td>
</tr>
<tr class=3D"even">
<td align=3D"right">s</td>
<td align=3D"left">The number of stop bits to use (<code>s =3D 0</code> equ=
als 1, <code>s =3D 1</code> equals 1.5 or 2)</td>
</tr>
<tr class=3D"odd">
<td align=3D"right">dl</td>
<td align=3D"left">Describes the length of the data</td>
</tr>
</tbody>
</table>
<p>We will use the mostly standard value <code>0x03</code> <span class=3D"c=
itation">[31]</span>, meaning a length of 8 bits, no parity bit, one stop b=
it and break control disabled. This is sent to the line command port, as se=
en in the following example:</p>
<pre class=3D"sourceCode c"><code class=3D"sourceCode c">    <span class=3D=
"co">/** serial_configure_line:</span>
<span class=3D"co">     *  Configures the line of the given serial port. Th=
e port is set to have a</span>
<span class=3D"co">     *  data length of 8 bits, no parity bits, one stop =
bit and break control</span>
<span class=3D"co">     *  disabled.</span>
<span class=3D"co">     *</span>
<span class=3D"co">     *  </span><span class=3D"kw">@param</span><span cla=
ss=3D"co"> </span><span class=3D"kw">com</span><span class=3D"co">  The ser=
ial port to configure</span>
<span class=3D"co">     */</span>
    <span class=3D"dt">void</span> serial_configure_line(<span class=3D"dt"=
>unsigned</span> <span class=3D"dt">short</span> com)
    {
        <span class=3D"co">/* Bit:     | 7 | 6 | 5 4 3 | 2 | 1 0 |</span>
<span class=3D"co">         * Content: | d | b | prty  | s | dl  |</span>
<span class=3D"co">         * Value:   | 0 | 0 | 0 0 0 | 0 | 1 1 | =3D 0x03=
</span>
<span class=3D"co">         */</span>
        outb(SERIAL_LINE_COMMAND_PORT(com), <span class=3D"bn">0x03</span>)=
;
    }</code></pre>
<p>The article on OSDev <span class=3D"citation">[31]</span> has a more in-=
depth explanation of the values.</p>
<h3 id=3D"configuring-the-buffers"><span class=3D"header-section-number">4.=
3.3</span> Configuring the Buffers</h3>
<p>When data is transmitted via the serial port it is placed in buffers, bo=
th when receiving and sending data. This way, if you send data to the seria=
l port faster than it can send it over the wire, it will be buffered. Howev=
er, if you send too much data too fast the buffer will be full and data wil=
l be lost. In other words, the buffers are FIFO queues. The FIFO queue conf=
iguration byte looks like the following figure:</p>
<pre><code>Bit:     | 7 6 | 5  | 4 | 3   | 2   | 1   | 0 |
Content: | lvl | bs | r | dma | clt | clr | e |</code></pre>
<p>A description for each name can be found in the table below:</p>
<table>
<thead>
<tr class=3D"header">
<th align=3D"right">Name</th>
<th align=3D"left">Description</th>
</tr>
</thead>
<tbody>
<tr class=3D"odd">
<td align=3D"right">lvl</td>
<td align=3D"left">How many bytes should be stored in the FIFO buffers</td>
</tr>
<tr class=3D"even">
<td align=3D"right">bs</td>
<td align=3D"left">If the buffers should be 16 or 64 bytes large</td>
</tr>
<tr class=3D"odd">
<td align=3D"right">r</td>
<td align=3D"left">Reserved for future use</td>
</tr>
<tr class=3D"even">
<td align=3D"right">dma</td>
<td align=3D"left">How the serial port data should be accessed</td>
</tr>
<tr class=3D"odd">
<td align=3D"right">clt</td>
<td align=3D"left">Clear the transmission FIFO buffer</td>
</tr>
<tr class=3D"even">
<td align=3D"right">clr</td>
<td align=3D"left">Clear the receiver FIFO buffer</td>
</tr>
<tr class=3D"odd">
<td align=3D"right">e</td>
<td align=3D"left">If the FIFO buffer should be enabled or not</td>
</tr>
</tbody>
</table>
<p>We use the value <code>0xC7 =3D 11000111</code> that:</p>
<ul>
<li>Enables FIFO</li>
<li>Clear both receiver and transmission FIFO queues</li>
<li>Use 14 bytes as size of queue</li>
</ul>
<p>The WikiBook on serial programming <span class=3D"citation">[32]</span> =
explains the values in more depth.</p>
<h3 id=3D"configuring-the-modem"><span class=3D"header-section-number">4.3.=
4</span> Configuring the Modem</h3>
<p>The modem control register is used for very simple hardware flow control=
 via the Ready To Transmit (RTS) and Data Terminal Ready (DTR) pins. When c=
onfiguring the serial port we want RTS and DTR to be 1, which means that we=
 are ready to send data.</p>
<p>The modem configuration byte is shown in the following figure:</p>
<pre><code>Bit:     | 7 | 6 | 5  | 4  | 3   | 2   | 1   | 0   |
Content: | r | r | af | lb | ao2 | ao1 | rts | dtr |</code></pre>
<p>A description for each name can be found in the table below:</p>
<table>
<thead>
<tr class=3D"header">
<th align=3D"right">Name</th>
<th align=3D"left">Description</th>
</tr>
</thead>
<tbody>
<tr class=3D"odd">
<td align=3D"right">r</td>
<td align=3D"left">Reserved</td>
</tr>
<tr class=3D"even">
<td align=3D"right">af</td>
<td align=3D"left">Autoflow control enabled</td>
</tr>
<tr class=3D"odd">
<td align=3D"right">lb</td>
<td align=3D"left">Loopback mode (used for debugging serial ports)</td>
</tr>
<tr class=3D"even">
<td align=3D"right">ao2</td>
<td align=3D"left">Auxiliary output 2, used for receiving interrupts</td>
</tr>
<tr class=3D"odd">
<td align=3D"right">ao1</td>
<td align=3D"left">Auxiliary output 1</td>
</tr>
<tr class=3D"even">
<td align=3D"right">rts</td>
<td align=3D"left">Ready To Transmit</td>
</tr>
<tr class=3D"odd">
<td align=3D"right">dtr</td>
<td align=3D"left">Data Terminal Ready</td>
</tr>
</tbody>
</table>
<p>We don=E2=80=99t need to enable interrupts, because we won=E2=80=99t han=
dle any received data. Therefore we use the configuration value <code>0x03 =
=3D 00000011</code> (RTS =3D 1 and DTS =3D 1).</p>
<h3 id=3D"writing-data-to-the-serial-port"><span class=3D"header-section-nu=
mber">4.3.5</span> Writing Data to the Serial Port</h3>
<p>Writing data to the serial port is done via the data I/O port. However, =
before writing, the transmit FIFO queue has to be empty (all previous write=
s must have finished). The transmit FIFO queue is empty if bit 5 of the lin=
e status I/O port is equal to one.</p>
<p>Reading the contents of an I/O port is done via the <code>in</code> asse=
mbly code instruction. There is no way to use the <code>in</code> assembly =
code instruction from C, therefore it has to be wrapped (the same way as th=
e <code>out</code> assembly code instruction):</p>
<pre class=3D"sourceCode nasm"><code class=3D"sourceCode nasm">    <span cl=
ass=3D"kw">global</span> inb

    <span class=3D"co">; inb - returns a byte from the given I/O port</span=
>
    <span class=3D"co">; stack: [esp + 4] The address of the I/O port</span=
>
    <span class=3D"co">;        [esp    ] The return address</span>
<span class=3D"fu">    inb:</span>
        <span class=3D"kw">mov</span> <span class=3D"kw">dx</span>, [<span =
class=3D"kw">esp</span> + <span class=3D"dv">4</span>]       <span class=3D=
"co">; move the address of the I/O port to the dx register</span>
        <span class=3D"kw">in</span>  <span class=3D"kw">al</span>, <span c=
lass=3D"kw">dx</span>              <span class=3D"co">; read a byte from th=
e I/O port and store it in the al register</span>
        <span class=3D"kw">ret</span>                     <span class=3D"co=
">; return the read byte</span></code></pre>
<pre class=3D"sourceCode c"><code class=3D"sourceCode c">    <span class=3D=
"co">/* in file io.h */</span>

    <span class=3D"co">/** inb:</span>
<span class=3D"co">     *  Read a byte from an I/O port.</span>
<span class=3D"co">     *</span>
<span class=3D"co">     *  </span><span class=3D"kw">@param</span><span cla=
ss=3D"co">  </span><span class=3D"kw">port</span><span class=3D"co"> The ad=
dress of the I/O port</span>
<span class=3D"co">     *  </span><span class=3D"kw">@return</span><span cl=
ass=3D"co">      The read byte</span>
<span class=3D"co">     */</span>
    <span class=3D"dt">unsigned</span> <span class=3D"dt">char</span> inb(<=
span class=3D"dt">unsigned</span> <span class=3D"dt">short</span> port);</c=
ode></pre>
<p>Checking if the transmit FIFO is empty can then be done from C:</p>
<pre class=3D"sourceCode c"><code class=3D"sourceCode c">    <span class=3D=
"ot">#include "io.h"</span>

    <span class=3D"co">/** serial_is_transmit_fifo_empty:</span>
<span class=3D"co">     *  Checks whether the transmit FIFO queue is empty =
or not for the given COM</span>
<span class=3D"co">     *  port.</span>
<span class=3D"co">     *</span>
<span class=3D"co">     *  </span><span class=3D"kw">@param</span><span cla=
ss=3D"co">  </span><span class=3D"kw">com</span><span class=3D"co"> The COM=
 port</span>
<span class=3D"co">     *  </span><span class=3D"kw">@return</span><span cl=
ass=3D"co"> 0 if the transmit FIFO queue is not empty</span>
<span class=3D"co">     *          1 if the transmit FIFO queue is empty</s=
pan>
<span class=3D"co">     */</span>
    <span class=3D"dt">int</span> serial_is_transmit_fifo_empty(<span class=
=3D"dt">unsigned</span> <span class=3D"dt">int</span> com)
    {
        <span class=3D"co">/* 0x20 =3D 0010 0000 */</span>
        <span class=3D"kw">return</span> inb(SERIAL_LINE_STATUS_PORT(com)) =
&amp; <span class=3D"bn">0x20</span>;
    }</code></pre>
<p>Writing to a serial port means spinning as long as the transmit FIFO que=
ue isn=E2=80=99t empty, and then writing the data to the data I/O port.</p>
<h3 id=3D"configuring-bochs"><span class=3D"header-section-number">4.3.6</s=
pan> Configuring Bochs</h3>
<p>To save the output from the first serial serial port the Bochs configura=
tion file <code>bochsrc.txt</code> must be updated. The <code>com1</code> c=
onfiguration instructs Bochs how to handle first serial port:</p>
<pre><code>    com1: enabled=3D1, mode=3Dfile, dev=3Dcom1.out</code></pre>
<p>The output from serial port one will now be stored in the file <code>com=
1.out</code>.</p>
<h3 id=3D"the-driver-1"><span class=3D"header-section-number">4.3.7</span> =
The Driver</h3>
<p>We recommend that you implement a <code>write</code> function for the se=
rial port similar to the <code>write</code> function in the driver for the =
framebuffer. To avoid name clashes with the <code>write</code> function for=
 the framebuffer it is a good idea to name the functions <code>fb_write</co=
de> and <code>serial_write</code> to distinguish them.</p>
<p>We further recommend that you try to write a <code>printf</code>-like fu=
nction, see section 7.3 in <span class=3D"citation">[8]</span>. The <code>p=
rintf</code> function could take an additional argument to decide to which =
device to write the output (framebuffer or serial).</p>
<p>A final recommendation is that you create some way of distinguishing the=
 severeness of the log messages, for example by prepending the messages wit=
h <code>DEBUG</code>, <code>INFO</code> or <code>ERROR</code>.</p>
<h2 id=3D"further-reading-2"><span class=3D"header-section-number">4.4</spa=
n> Further Reading</h2>
<ul>
<li>The book =E2=80=9CSerial programming=E2=80=9D (available on WikiBooks) =
has a great section on programming the serial port, <a href=3D"http://en.wi=
kibooks.org/wiki/Serial_Programming/8250_UART_Programming#UART_Registers">h=
ttp://en.wikibooks.org/wiki/Serial_Programming/8250_UART_Programming#UART_R=
egisters</a></li>
<li>The OSDev wiki has a page with a lot of information about the serial po=
rts, <a href=3D"http://wiki.osdev.org/Serial_ports">http://wiki.osdev.org/S=
erial_ports</a></li>
</ul>
<h1 id=3D"segmentation"><span class=3D"header-section-number">5</span> Segm=
entation</h1>
<p><em>Segmentation</em> in x86 means accessing the memory through segments=
. Segments are portions of the address space, possibly overlapping, specifi=
ed by a base address and a limit. To address a byte in segmented memory you=
 use a 48-bit <em>logical address</em>: 16 bits that specifies the segment =
and 32-bits that specifies what offset within that segment you want. The of=
fset is added to the base address of the segment, and the resulting linear =
address is checked against the segment=E2=80=99s limit - see the figure bel=
ow. If everything works out fine (including access-rights checks ignored fo=
r now) the result is a <em>linear address</em>. When paging is disabled, th=
en the linear address space is mapped 1:1 onto the <em>physical address</em=
> space, and the physical memory can be accessed. (See the chapter <a href=
=3D"https://littleosbook.github.io/#paging">=E2=80=9CPaging=E2=80=9D</a> fo=
r how to enable paging.)</p>
<div class=3D"figure">
<img src=3D"https://littleosbook.github.io/images/intel_3_5_logical_to_line=
ar.png" alt=3D"Translation of logical addresses to linear addresses."><p cl=
ass=3D"caption">Translation of logical addresses to linear addresses.</p>
</div>
<p>To enable segmentation you need to set up a table that describes each se=
gment - a <em>segment descriptor table</em>. In x86, there are two types of=
 descriptor tables: the <em>Global Descriptor Table</em> (GDT) and <em>Loca=
l Descriptor Tables</em> (LDT). An LDT is set up and managed by user-space =
processes, and all processes have their own LDT. LDTs can be used if a more=
 complex segmentation model is desired - we won=E2=80=99t use it. The GDT i=
s shared by everyone - it=E2=80=99s global.</p>
<p>As we discuss in the sections on virtual memory and paging, segmentation=
 is rarely used more than in a minimal setup, similar to what we do below.<=
/p>
<h2 id=3D"accessing-memory"><span class=3D"header-section-number">5.1</span=
> Accessing Memory</h2>
<p>Most of the time when accessing memory there is no need to explicitly sp=
ecify the segment to use. The processor has six 16-bit segment registers: <=
code>cs</code>, <code>ss</code>, <code>ds</code>, <code>es</code>, <code>gs=
</code> and <code>fs</code>. The register <code>cs</code> is the code segme=
nt register and specifies the segment to use when fetching instructions. Th=
e register <code>ss</code> is used whenever accessing the stack (through th=
e stack pointer <code>esp</code>), and <code>ds</code> is used for other da=
ta accesses. The OS is free to use the registers <code>es</code>, <code>gs<=
/code> and <code>fs</code> however it want.</p>
<p>Below is an example showing implicit use of the segment registers:</p>
<pre class=3D"sourceCode nasm"><code class=3D"sourceCode nasm"><span class=
=3D"fu">    func:</span>
        <span class=3D"kw">mov</span> <span class=3D"kw">eax</span>, [<span=
 class=3D"kw">esp</span><span class=3D"dv">+4</span>]
        <span class=3D"kw">mov</span> <span class=3D"kw">ebx</span>, [<span=
 class=3D"kw">eax</span>]
        <span class=3D"kw">add</span> <span class=3D"kw">ebx</span>, <span =
class=3D"dv">8</span>
        <span class=3D"kw">mov</span> [<span class=3D"kw">eax</span>], <spa=
n class=3D"kw">ebx</span>
        <span class=3D"kw">ret</span></code></pre>
<p>The above example can be compared with the following one that makes expl=
icit use of the segment registers:</p>
<pre class=3D"sourceCode nasm"><code class=3D"sourceCode nasm"><span class=
=3D"fu">    func:</span>
        <span class=3D"kw">mov</span> <span class=3D"kw">eax</span>, [<span=
 class=3D"kw">ss</span>:<span class=3D"kw">esp</span><span class=3D"dv">+4<=
/span>]
        <span class=3D"kw">mov</span> <span class=3D"kw">ebx</span>, [<span=
 class=3D"kw">ds</span>:<span class=3D"kw">eax</span>]
        <span class=3D"kw">add</span> <span class=3D"kw">ebx</span>, <span =
class=3D"dv">8</span>
        <span class=3D"kw">mov</span> [<span class=3D"kw">ds</span>:<span c=
lass=3D"kw">eax</span>], <span class=3D"kw">ebx</span>
        <span class=3D"kw">ret</span></code></pre>
<p>You don=E2=80=99t need to use <code>ss</code> for storing the stack segm=
ent selector, or <code>ds</code> for the data segment selector. You could s=
tore the stack segment selector in <code>ds</code> and vice versa. However,=
 in order to use the implicit style shown above, you must store the segment=
 selectors in their indented registers.</p>
<p>Segment descriptors and their fields are described in figure 3-8 in the =
Intel manual <span class=3D"citation">[33]</span>.</p>
<h2 id=3D"the-global-descriptor-table-gdt"><span class=3D"header-section-nu=
mber">5.2</span> The Global Descriptor Table (GDT)</h2>
<p>A GDT/LDT is an array of 8-byte segment descriptors. The first descripto=
r in the GDT is always a null descriptor and can never be used to access me=
mory. At least two segment descriptors (plus the null descriptor) are neede=
d for the GDT, because the descriptor contains more information than just t=
he base and limit fields. The two most relevant fields for us are the <em>T=
ype</em> field and the <em>Descriptor Privilege Level</em> (DPL) field.</p>
<p>Table 3-1 in chapter 3 of the Intel manual <span class=3D"citation">[33]=
</span> specifies the values for the Type field. The table shows that the T=
ype field can=E2=80=99t be both writable <em>and</em> executable at the sam=
e time. Therefore, two segments are needed: one segment for executing code =
to put in <code>cs</code> (Type is Execute-only or Execute-Read) and one se=
gment for reading and writing data (Type is Read/Write) to put in the other=
 segment registers.</p>
<p>The DPL specifies the <em>privilege levels</em> required to use the segm=
ent. x86 allows for four privilege levels (PL), 0 to 3, where PL0 is the mo=
st privileged. In most operating systems (eg. Linux and Windows), only PL0 =
and PL3 are used. However, some operating system, such as MINIX, make use o=
f all levels. The kernel should be able to do anything, therefore it uses s=
egments with DPL set to 0 (also called kernel mode). The current privilege =
level (CPL) is determined by the segment selector in <code>cs</code>.</p>
<p>The segments needed are described in the table below.</p>
<table class=3D" has_caption">
<caption>The segment descriptors needed.</caption>
<thead>
<tr class=3D"header">
<th align=3D"right">Index</th>
<th align=3D"right">Offset</th>
<th align=3D"left">Name</th>
<th align=3D"left">Address range</th>
<th align=3D"left">Type</th>
<th align=3D"left">DPL</th>
</tr>
</thead>
<tbody>
<tr class=3D"odd">
<td align=3D"right">0</td>
<td align=3D"right"><code>0x00</code></td>
<td align=3D"left">null descriptor</td>
<td align=3D"left"></td>
<td align=3D"left"></td>
<td align=3D"left"></td>
</tr>
<tr class=3D"even">
<td align=3D"right">1</td>
<td align=3D"right"><code>0x08</code></td>
<td align=3D"left">kernel code segment</td>
<td align=3D"left"><code>0x00000000 - 0xFFFFFFFF</code></td>
<td align=3D"left">RX</td>
<td align=3D"left">PL0</td>
</tr>
<tr class=3D"odd">
<td align=3D"right">2</td>
<td align=3D"right"><code>0x10</code></td>
<td align=3D"left">kernel data segment</td>
<td align=3D"left"><code>0x00000000 - 0xFFFFFFFF</code></td>
<td align=3D"left">RW</td>
<td align=3D"left">PL0</td>
</tr>
</tbody>
</table>
<p>Note that the segments overlap - they both encompass the entire linear a=
ddress space. In our minimal setup we=E2=80=99ll only use segmentation to g=
et privilege levels. See the Intel manual <span class=3D"citation">[33]</sp=
an>, chapter 3, for details on the other descriptor fields.</p>
<h2 id=3D"loading-the-gdt"><span class=3D"header-section-number">5.3</span>=
 Loading the GDT</h2>
<p>Loading the GDT into the processor is done with the <code>lgdt</code> as=
sembly code instruction, which takes the address of a struct that specifies=
 the start and size of the GDT. It is easiest to encode this information us=
ing a <a href=3D"https://littleosbook.github.io/#packing-structs">=E2=80=9C=
packed struct=E2=80=9D</a> as shown in the following example:</p>
<pre class=3D"sourceCode c"><code class=3D"sourceCode c">    <span class=3D=
"kw">struct</span> gdt {
        <span class=3D"dt">unsigned</span> <span class=3D"dt">int</span> ad=
dress;
        <span class=3D"dt">unsigned</span> <span class=3D"dt">short</span> =
size;
    } __attribute__((packed));</code></pre>
<p>If the content of the <code>eax</code> register is the address to such a=
 struct, then the GDT can be loaded with the assembly code shown below:</p>
<pre class=3D"sourceCode nasm"><code class=3D"sourceCode nasm">    <span cl=
ass=3D"kw">lgdt</span> [<span class=3D"kw">eax</span>]</code></pre>
<p>It might be easier if you make this instruction available from C, the sa=
me way as was done with the assembly code instructions <code>in</code> and =
<code>out</code>.</p>
<p>After the GDT has been loaded the segment registers needs to be loaded w=
ith their corresponding segment selectors. The content of a segment selecto=
r is described in the figure and table below:</p>
<pre><code>Bit:     | 15                                3 | 2  | 1 0 |
Content: | offset (index)                      | ti | rpl |</code></pre>
<table class=3D" has_caption">
<caption>The layout of segment selectors.</caption>
<colgroup><col width=3D"23%">
<col width=3D"76%">
</colgroup><thead>
<tr class=3D"header">
<th align=3D"left">Name</th>
<th align=3D"left">Description</th>
</tr>
</thead>
<tbody>
<tr class=3D"odd">
<td align=3D"left">rpl</td>
<td align=3D"left">Requested Privilege Level - we want to execute in PL0 fo=
r now.</td>
</tr>
<tr class=3D"even">
<td align=3D"left">ti</td>
<td align=3D"left">Table Indicator. 0 means that this specifies a GDT segme=
nt, 1 means an LDT Segment.</td>
</tr>
<tr class=3D"odd">
<td align=3D"left">offset (index)</td>
<td align=3D"left">Offset within descriptor table.</td>
</tr>
</tbody>
</table>
<p>The offset of the segment selector is added to the start of the GDT to g=
et the address of the segment descriptor: <code>0x08</code> for the first d=
escriptor and <code>0x10</code> for the second, since each descriptor is 8 =
bytes. The Requested Privilege Level (RPL) should be <code>0</code> since t=
he kernel of the OS should execute in privilege level 0.</p>
<p>Loading the segment selector registers is easy for the data registers - =
just copy the correct offsets to the registers:</p>
<pre class=3D"sourceCode nasm"><code class=3D"sourceCode nasm">    <span cl=
ass=3D"kw">mov</span> <span class=3D"kw">ds</span><span class=3D"bn">, 0x10=
</span>
    <span class=3D"kw">mov</span> <span class=3D"kw">ss</span><span class=
=3D"bn">, 0x10</span>
    <span class=3D"kw">mov</span> <span class=3D"kw">es</span><span class=
=3D"bn">, 0x10</span>
    .
    .
    .</code></pre>
<p>To load <code>cs</code> we have to do a =E2=80=9Cfar jump=E2=80=9D:</p>
<pre class=3D"sourceCode nasm"><code class=3D"sourceCode nasm">    <span cl=
ass=3D"co">; code here uses the previous cs</span>
    <span class=3D"kw">jmp</span> <span class=3D"bn">0x08</span>:flush_cs  =
 <span class=3D"co">; specify cs when jumping to flush_cs</span>

<span class=3D"fu">    flush_cs:</span>
        <span class=3D"co">; now we've changed cs to 0x08</span></code></pr=
e>
<p>A far jump is a jump where we explicitly specify the full 48-bit logical=
 address: the segment selector to use and the absolute address to jump to. =
It will first set <code>cs</code> to <code>0x08</code> and then jump to <co=
de>flush_cs</code> using its absolute address.</p>
<h2 id=3D"further-reading-3"><span class=3D"header-section-number">5.4</spa=
n> Further Reading</h2>
<ul>
<li>Chapter 3 of the Intel manual <span class=3D"citation">[33]</span> is f=
illed with low-level and technical details about segmentation.</li>
<li>The OSDev wiki has a page about segmentation: <a href=3D"http://wiki.os=
dev.org/Segmentation">http://wiki.osdev.org/Segmentation</a></li>
<li>The Wikipedia page on x86 segmentation might be worth looking into: <a =
href=3D"http://en.wikipedia.org/wiki/X86_memory_segmentation">http://en.wik=
ipedia.org/wiki/X86_memory_segmentation</a></li>
</ul>
<h1 id=3D"interrupts-and-input"><span class=3D"header-section-number">6</sp=
an> Interrupts and Input</h1>
<p>Now that the OS can produce <em>output</em> it would be nice if it also =
could get some <em>input</em>. (The operating system must be able to handle=
 <em>interrupts</em> in order to read information from the keyboard). An in=
terrupt occurs when a hardware device, such as the keyboard, the serial por=
t or the timer, signals the CPU that the state of the device has changed. T=
he CPU itself can also send interrupts due to program errors, for example w=
hen a program references memory it doesn=E2=80=99t have access to, or when =
a program divides a number by zero. Finally, there are also <em>software in=
tterupts</em>, which are interrupts that are caused by the <code>int</code>=
 assembly code instruction, and they are often used for system calls.</p>
<h2 id=3D"interrupts-handlers"><span class=3D"header-section-number">6.1</s=
pan> Interrupts Handlers</h2>
<p>Interrupts are handled via the <em>Interrupt Descriptor Table</em> (IDT)=
. The IDT describes a handler for each interrupt. The interrupts are number=
ed (0 - 255) and the handler for interrupt <em>i</em> is defined at the <em=
>ith</em> position in the table. There are three different kinds of handler=
s for interrupts:</p>
<ul>
<li>Task handler</li>
<li>Interrupt handler</li>
<li>Trap handler</li>
</ul>
<p>The task handlers use functionality specific to the Intel version of x86=
, so they won=E2=80=99t be covered here (see the Intel manual <span class=
=3D"citation">[33]</span>, chapter 6, for more info). The only difference b=
etween an interrupt handler and a trap handler is that the interrupt handle=
r disables interrupts, which means you cannot get an interrupt while at the=
 same time handling an interrupt. In this book, we will use trap handlers a=
nd disable interrupts manually when we need to.</p>
<h2 id=3D"creating-an-entry-in-the-idt"><span class=3D"header-section-numbe=
r">6.2</span> Creating an Entry in the IDT</h2>
<p>An entry in the IDT for an interrupt handler consists of 64 bits. The hi=
ghest 32 bits are shown in the figure below:</p>
<pre><code>Bit:     | 31              16 | 15 | 14 13 | 12 | 11 | 10 9 8 | =
7 6 5 | 4 3 2 1 0 |
Content: | offset high        | P  | DPL   | 0  | D  | 1  1 0 | 0 0 0 | res=
erved  |</code></pre>
<p>The lowest 32 bits are presented in the following figure:</p>
<pre><code>Bit:     | 31              16 | 15              0 |
Content: | segment selector   | offset low        |</code></pre>
<p>A description for each name can be found in the table below:</p>
<table>
<thead>
<tr class=3D"header">
<th align=3D"right">Name</th>
<th align=3D"left">Description</th>
</tr>
</thead>
<tbody>
<tr class=3D"odd">
<td align=3D"right">offset high</td>
<td align=3D"left">The 16 highest bits of the 32 bit address in the segment=
.</td>
</tr>
<tr class=3D"even">
<td align=3D"right">offset low</td>
<td align=3D"left">The 16 lowest bits of the 32 bits address in the segment=
.</td>
</tr>
<tr class=3D"odd">
<td align=3D"right">p</td>
<td align=3D"left">If the handler is present in memory or not (1 =3D presen=
t, 0 =3D not present).</td>
</tr>
<tr class=3D"even">
<td align=3D"right">DPL</td>
<td align=3D"left">Descriptor Privilige Level, the privilege level the hand=
ler can be called from (0, 1, 2, 3).</td>
</tr>
<tr class=3D"odd">
<td align=3D"right">D</td>
<td align=3D"left">Size of gate, (1 =3D 32 bits, 0 =3D 16 bits).</td>
</tr>
<tr class=3D"even">
<td align=3D"right">segment selector</td>
<td align=3D"left">The offset in the GDT.</td>
</tr>
<tr class=3D"odd">
<td align=3D"right">r</td>
<td align=3D"left">Reserved.</td>
</tr>
</tbody>
</table>
<p>The offset is a pointer to code (preferably an assembly code label). For=
 example, to create an entry for a handler whose code starts at <code>0xDEA=
DBEEF</code> and that runs in privilege level 0 (therefore using the same c=
ode segment selector as the kernel) the following two bytes would be used:<=
/p>
<pre><code>    0xDEAD8E00
    0x0008BEEF</code></pre>
<p>If the IDT is represented as an <code>unsigned integer idt[512]</code> t=
hen to register the above example as an handler for interrupt 0 (divide-by-=
zero), the following code would be used:</p>
<pre class=3D"sourceCode c"><code class=3D"sourceCode c">    idt[<span clas=
s=3D"dv">0</span>] =3D <span class=3D"bn">0xDEAD8E00</span>
    idt[<span class=3D"dv">1</span>] =3D <span class=3D"bn">0x0008BEEF</spa=
n></code></pre>
<p>As written in the chapter <a href=3D"https://littleosbook.github.io/#get=
ting-to-c">=E2=80=9CGetting to C=E2=80=9D</a>, we recommend that you instea=
d of using bytes (or unsigned integers) use packed structures to make the c=
ode more readable.</p>
<h2 id=3D"handling-an-interrupt"><span class=3D"header-section-number">6.3<=
/span> Handling an Interrupt</h2>
<p>When an interrupt occurs the CPU will push some information about the in=
terrupt onto the stack, then look up the appropriate interrupt hander in th=
e IDT and jump to it. The stack at the time of the interrupt will look like=
 the following:</p>
<pre><code>    [esp + 12] eflags
    [esp + 8]  cs
    [esp + 4]  eip
    [esp]      error code?</code></pre>
<p>The reason for the question mark behind error code is that not all inter=
rupts create an <em>error code</em>. The specific CPU interrupts that put a=
n error code on the stack are 8, 10, 11, 12, 13, 14 and 17. The error code =
can be used by the interrupt handler to get more information on what has ha=
ppened. Also, note that the interrupt <em>number</em> is <em>not</em> pushe=
d onto the stack. We can only determine what interrupt has occurred by know=
ing what code is executing - if the handler registered for interrupt 17 is =
executing, then interrupt 17 has occurred.</p>
<p>Once the interrupt handler is done, it uses the <code>iret</code> instru=
ction to return. The instruction <code>iret</code> expects the stack to be =
the same as at the time of the interrupt (see the figure above). Therefore,=
 any values pushed onto the stack by the interrupt handler must be popped. =
Before returning, <code>iret</code> restores <code>eflags</code> by popping=
 the value from the stack and then finally jumps to <code>cs:eip</code> as =
specified by the values on the stack.</p>
<p>The interrupt handler has to be written in assembly code, since all regi=
sters that the interrupt handlers use must be preserved by pushing them ont=
o the stack. This is because the code that was interrupted doesn=E2=80=99t =
know about the interrupt and will therefore expect that its registers stay =
the same. Writing all the logic of the interrupt handler in assembly code w=
ill be tiresome. Creating a handler in assembly code that saves the registe=
rs, calls a C function, restores the registers and finally executes <code>i=
ret</code> is a good idea!</p>
<p>The C handler should get the state of the registers, the state of the st=
ack and the number of the interrupt as arguments. The following definitions=
 can for example be used:</p>
<pre class=3D"sourceCode c"><code class=3D"sourceCode c">    <span class=3D=
"kw">struct</span> cpu_state {
        <span class=3D"dt">unsigned</span> <span class=3D"dt">int</span> ea=
x;
        <span class=3D"dt">unsigned</span> <span class=3D"dt">int</span> eb=
x;
        <span class=3D"dt">unsigned</span> <span class=3D"dt">int</span> ec=
x;
        .
        .
        .
        <span class=3D"dt">unsigned</span> <span class=3D"dt">int</span> es=
p;
    } __attribute__((packed));

    <span class=3D"kw">struct</span> stack_state {
        <span class=3D"dt">unsigned</span> <span class=3D"dt">int</span> er=
ror_code;
        <span class=3D"dt">unsigned</span> <span class=3D"dt">int</span> ei=
p;
        <span class=3D"dt">unsigned</span> <span class=3D"dt">int</span> cs=
;
        <span class=3D"dt">unsigned</span> <span class=3D"dt">int</span> ef=
lags;
    } __attribute__((packed));

    <span class=3D"dt">void</span> interrupt_handler(<span class=3D"kw">str=
uct</span> cpu_state cpu, <span class=3D"kw">struct</span> stack_state stac=
k, <span class=3D"dt">unsigned</span> <span class=3D"dt">int</span> interru=
pt);</code></pre>
<h2 id=3D"creating-a-generic-interrupt-handler"><span class=3D"header-secti=
on-number">6.4</span> Creating a Generic Interrupt Handler</h2>
<p>Since the CPU does not push the interrupt number on the stack it is a li=
ttle tricky to write a generic interrupt handler. This section will use mac=
ros to show how it can be done. Writing one version for each interrupt is t=
edious - it is better to use the macro functionality of NASM <span class=3D=
"citation">[34]</span>. And since not all interrupts produce an error code =
the value 0 will be added as the =E2=80=9Cerror code=E2=80=9D for interrupt=
s without an error code. The following code shows an example of how this ca=
n be done:</p>
<pre class=3D"sourceCode nasm"><code class=3D"sourceCode nasm">    <span cl=
ass=3D"ot">%macro no_error_code_interrupt_handler %1</span>
    <span class=3D"kw">global</span> interrupt_handler_<span class=3D"ot">%=
1</span>
    interrupt_handler_<span class=3D"ot">%1:</span>
        <span class=3D"kw">push</span>    <span class=3D"dt">dword</span> <=
span class=3D"dv">0</span>                     <span class=3D"co">; push 0 =
as error code</span>
        <span class=3D"kw">push</span>    <span class=3D"dt">dword</span> <=
span class=3D"ot">%1                    ; push the interrupt number</span>
        <span class=3D"kw">jmp</span>     common_interrupt_handler    <span=
 class=3D"co">; jump to the common handler</span>
    <span class=3D"ot">%endmacro</span>

    <span class=3D"ot">%macro error_code_interrupt_handler %1</span>
    <span class=3D"kw">global</span> interrupt_handler_<span class=3D"ot">%=
1</span>
    interrupt_handler_<span class=3D"ot">%1:</span>
        <span class=3D"kw">push</span>    <span class=3D"dt">dword</span> <=
span class=3D"ot">%1                    ; push the interrupt number</span>
        <span class=3D"kw">jmp</span>     common_interrupt_handler    <span=
 class=3D"co">; jump to the common handler</span>
    <span class=3D"ot">%endmacro</span>

<span class=3D"fu">    common_interrupt_handler:</span>               <span=
 class=3D"co">; the common parts of the generic interrupt handler</span>
        <span class=3D"co">; save the registers</span>
        <span class=3D"kw">push</span>    <span class=3D"kw">eax</span>
        <span class=3D"kw">push</span>    <span class=3D"kw">ebx</span>
        .
        .
        .
        <span class=3D"kw">push</span>    <span class=3D"kw">ebp</span>

        <span class=3D"co">; call the C function</span>
        <span class=3D"kw">call</span>    interrupt_handler

        <span class=3D"co">; restore the registers</span>
        <span class=3D"kw">pop</span>     <span class=3D"kw">ebp</span>
        .
        .
        .
        <span class=3D"kw">pop</span>     <span class=3D"kw">ebx</span>
        <span class=3D"kw">pop</span>     <span class=3D"kw">eax</span>

        <span class=3D"co">; restore the esp</span>
        <span class=3D"kw">add</span>     <span class=3D"kw">esp</span>, <s=
pan class=3D"dv">8</span>

        <span class=3D"co">; return to the code that got interrupted</span>
        <span class=3D"kw">iret</span>

    no_error_code_interrupt_handler <span class=3D"dv">0</span>       <span=
 class=3D"co">; create handler for interrupt 0</span>
    no_error_code_interrupt_handler <span class=3D"dv">1</span>       <span=
 class=3D"co">; create handler for interrupt 1</span>
    .
    .
    .
    error_code_handler              <span class=3D"dv">7</span>       <span=
 class=3D"co">; create handler for interrupt 7</span>
    .
    .
    .</code></pre>
<p>The <code>common_interrupt_handler</code> does the following:</p>
<ul>
<li>Push the registers on the stack.</li>
<li>Call the C function <code>interrupt_handler</code>.</li>
<li>Pop the registers from the stack.</li>
<li>Add 8 to <code>esp</code> (because of the error code and the interrupt =
number pushed earlier).</li>
<li>Execute <code>iret</code> to return to the interrupted code.</li>
</ul>
<p>Since the macros declare global labels the addresses of the interrupt ha=
ndlers can be accessed from C or assembly code when creating the IDT.</p>
<h2 id=3D"loading-the-idt"><span class=3D"header-section-number">6.5</span>=
 Loading the IDT</h2>
<p>The IDT is loaded with the <code>lidt</code> assembly code instruction w=
hich takes the address of the first element in the table. It is easiest to =
wrap this instruction and use it from C:</p>
<pre class=3D"sourceCode nasm"><code class=3D"sourceCode nasm">    <span cl=
ass=3D"kw">global</span>  load_idt

    <span class=3D"co">; load_idt - Loads the interrupt descriptor table (I=
DT).</span>
    <span class=3D"co">; stack: [esp + 4] the address of the first entry in=
 the IDT</span>
    <span class=3D"co">;        [esp    ] the return address</span>
<span class=3D"fu">    load_idt:</span>
        <span class=3D"kw">mov</span>     <span class=3D"kw">eax</span>, [<=
span class=3D"kw">esp</span><span class=3D"dv">+4</span>]    <span class=3D=
"co">; load the address of the IDT into register eax</span>
        <span class=3D"kw">lidt</span>    <span class=3D"kw">eax</span>    =
         <span class=3D"co">; load the IDT</span>
        <span class=3D"kw">ret</span>                     <span class=3D"co=
">; return to the calling function</span></code></pre>
<h2 id=3D"programmable-interrupt-controller-pic"><span class=3D"header-sect=
ion-number">6.6</span> Programmable Interrupt Controller (PIC)</h2>
<p>To start using hardware interrupts you must first configure the Programm=
able Interrupt Controller (PIC). The PIC makes it possible to map signals f=
rom the hardware to interrupts. The reasons for configuring the PIC are:</p=
>
<ul>
<li>Remap the interrupts. The PIC uses interrupts 0 - 15 for hardware inter=
rupts by default, which conflicts with the CPU interrupts. Therefore the PI=
C interrupts must be remapped to another interval.</li>
<li>Select which interrupts to receive. You probably don=E2=80=99t want to =
receive interrupts from all devices since you don=E2=80=99t have code that =
handles these interrupts anyway.</li>
<li>Set up the correct mode for the PIC.</li>
</ul>
<p>In the beginning there was only one PIC (PIC 1) and eight interrupts. As=
 more hardware were added, 8 interrupts were too few. The solution chosen w=
as to chain on another PIC (PIC 2) on the first PIC (see interrupt 2 on PIC=
 1).</p>
<p>The hardware interrupts are shown in the table below:</p>
<table>
<thead>
<tr class=3D"header">
<th align=3D"right">PIC 1</th>
<th align=3D"left">Hardware</th>
<th align=3D"right">PIC 2</th>
<th align=3D"left">Hardware</th>
</tr>
</thead>
<tbody>
<tr class=3D"odd">
<td align=3D"right">0</td>
<td align=3D"left">Timer</td>
<td align=3D"right">8</td>
<td align=3D"left">Real Time Clock</td>
</tr>
<tr class=3D"even">
<td align=3D"right">1</td>
<td align=3D"left">Keyboard</td>
<td align=3D"right">9</td>
<td align=3D"left">General I/O</td>
</tr>
<tr class=3D"odd">
<td align=3D"right">2</td>
<td align=3D"left">PIC 2</td>
<td align=3D"right">10</td>
<td align=3D"left">General I/O</td>
</tr>
<tr class=3D"even">
<td align=3D"right">3</td>
<td align=3D"left">COM 2</td>
<td align=3D"right">11</td>
<td align=3D"left">General I/O</td>
</tr>
<tr class=3D"odd">
<td align=3D"right">4</td>
<td align=3D"left">COM 1</td>
<td align=3D"right">12</td>
<td align=3D"left">General I/O</td>
</tr>
<tr class=3D"even">
<td align=3D"right">5</td>
<td align=3D"left">LPT 2</td>
<td align=3D"right">13</td>
<td align=3D"left">Coprocessor</td>
</tr>
<tr class=3D"odd">
<td align=3D"right">6</td>
<td align=3D"left">Floppy disk</td>
<td align=3D"right">14</td>
<td align=3D"left">IDE Bus</td>
</tr>
<tr class=3D"even">
<td align=3D"right">7</td>
<td align=3D"left">LPT 1</td>
<td align=3D"right">15</td>
<td align=3D"left">IDE Bus</td>
</tr>
</tbody>
</table>
<p>A great tutorial for configuring the PIC can be found at the SigOPS webs=
ite <span class=3D"citation">[35]</span>. We won=E2=80=99t repeat that info=
rmation here.</p>
<p>Every interrupt from the PIC has to be acknowledged - that is, sending a=
 message to the PIC confirming that the interrupt has been handled. If this=
 isn=E2=80=99t done the PIC won=E2=80=99t generate any more interrupts.</p>
<p>Acknowledging a PIC interrupt is done by sending the byte <code>0x20</co=
de> to the PIC that raised the interrupt. Implementing a <code>pic_acknowle=
dge</code> function can thus be done as follows:</p>
<pre class=3D"sourceCode c"><code class=3D"sourceCode c">    <span class=3D=
"ot">#include "io.h"</span>

    <span class=3D"ot">#define PIC1_PORT_A 0x20</span>
    <span class=3D"ot">#define PIC2_PORT_A 0xA0</span>

    <span class=3D"co">/* The PIC interrupts have been remapped */</span>
    <span class=3D"ot">#define PIC1_START_INTERRUPT 0x20</span>
    <span class=3D"ot">#define PIC2_START_INTERRUPT 0x28</span>
    <span class=3D"ot">#define PIC2_END_INTERRUPT   PIC2_START_INTERRUPT + =
7</span>

    <span class=3D"ot">#define PIC_ACK     0x20</span>

    <span class=3D"co">/** pic_acknowledge:</span>
<span class=3D"co">     *  Acknowledges an interrupt from either PIC 1 or P=
IC 2.</span>
<span class=3D"co">     *</span>
<span class=3D"co">     *  </span><span class=3D"kw">@param</span><span cla=
ss=3D"co"> </span><span class=3D"kw">num</span><span class=3D"co"> The numb=
er of the interrupt</span>
<span class=3D"co">     */</span>
    <span class=3D"dt">void</span> pic_acknowledge(<span class=3D"dt">unsig=
ned</span> integer interrupt)
    {
        <span class=3D"kw">if</span> (interrupt &lt; PIC1_START_INTERRUPT |=
| interrupt &gt; PIC2_END_INTERRUPT) {
          <span class=3D"kw">return</span>;
        }

        <span class=3D"kw">if</span> (interrupt &lt; PIC2_START_INTERRUPT) =
{
          outb(PIC1_PORT_A, PIC_ACK);
        } <span class=3D"kw">else</span> {
          outb(PIC2_PORT_A, PIC_ACK);
        }
    }</code></pre>
<h2 id=3D"reading-input-from-the-keyboard"><span class=3D"header-section-nu=
mber">6.7</span> Reading Input from the Keyboard</h2>
<p>The keyboard does not generate ASCII characters, it generates scan codes=
. A scan code represents a button - both presses and releases. The scan cod=
e representing the just pressed button can be read from the keyboard=E2=80=
=99s data I/O port which has address <code>0x60</code>. How this can be don=
e is shown in the following example:</p>
<pre class=3D"sourceCode c"><code class=3D"sourceCode c">    <span class=3D=
"ot">#include "io.h"</span>

    <span class=3D"ot">#define KBD_DATA_PORT   0x60</span>

    <span class=3D"co">/** read_scan_code:</span>
<span class=3D"co">     *  Reads a scan code from the keyboard</span>
<span class=3D"co">     *</span>
<span class=3D"co">     *  </span><span class=3D"kw">@return</span><span cl=
ass=3D"co"> The scan code (NOT an ASCII character!)</span>
<span class=3D"co">     */</span>
    <span class=3D"dt">unsigned</span> <span class=3D"dt">char</span> read_=
scan_code(<span class=3D"dt">void</span>)
    {
        <span class=3D"kw">return</span> inb(KBD_DATA_PORT);
    }</code></pre>
<p>The next step is to write a function that translates a scan code to the =
corresponding ASCII character. If you want to map the scan codes to ASCII c=
haracters as is done on an American keyboard then Andries Brouwer has a gre=
at tutorial <span class=3D"citation">[36]</span>.</p>
<p>Remember, since the keyboard interrupt is raised by the PIC, you must ca=
ll <code>pic_acknowledge</code> at the end of the keyboard interrupt handle=
r. Also, the keyboard will not send you any more interrupts until you read =
the scan code from the keyboard.</p>
<h2 id=3D"further-reading-4"><span class=3D"header-section-number">6.8</spa=
n> Further Reading</h2>
<ul>
<li>The OSDev wiki has a great page on interrupts, <a href=3D"http://wiki.o=
sdev.org/Interrupts">http://wiki.osdev.org/Interrupts</a></li>
<li>Chapter 6 of Intel Manual 3a <span class=3D"citation">[33]</span> descr=
ibes everything there is to know about interrupts.</li>
</ul>
<h1 id=3D"the-road-to-user-mode"><span class=3D"header-section-number">7</s=
pan> The Road to User Mode</h1>
<p>Now that the kernel boots, prints to screen and reads from keyboard - wh=
at do we do? Usually, a kernel is not supposed to do the application logic =
itself, but leave that for applications. The kernel creates the proper abst=
ractions (for memory, files, devices) to make application development easie=
r, performs tasks on behalf of applications (system calls) and <a href=3D"h=
ttps://littleosbook.github.io/#scheduling">schedules processes</a>.</p>
<p>User mode, in contrast with kernel mode, is the environment in which the=
 user=E2=80=99s programs execute. This environment is less privileged than =
the kernel, and will prevent (badly written) user programs from messing wit=
h other programs or the kernel. Badly written kernels are free to mess up w=
hat they want.</p>
<p>There=E2=80=99s quite a way to go until the OS created in this book can =
execute programs in user mode, but this chapter will show how to easily exe=
cute a small program in kernel mode.</p>
<h2 id=3D"loading-an-external-program"><span class=3D"header-section-number=
">7.1</span> Loading an External Program</h2>
<p>Where do we get the external program from? Somehow we need to load the c=
ode we want to execute into memory. More feature-complete operating systems=
 usually have drivers and file systems that enable them to load the softwar=
e from a CD-ROM drive, a hard disk or other persistent media.</p>
<p>Instead of creating all these drivers and file systems we will use a fea=
ture in GRUB called modules to load the program.</p>
<h3 id=3D"grub-modules"><span class=3D"header-section-number">7.1.1</span> =
GRUB Modules</h3>
<p>GRUB can load arbitrary files into memory from the ISO image, and these =
files are usually referred to as <em>modules</em>. To make GRUB load a modu=
le, edit the file <code>iso/boot/grub/menu.lst</code> and add the following=
 line at the end of the file:</p>
<pre><code>    module /modules/program</code></pre>
<p>Now create the folder <code>iso/modules</code>:</p>
<pre><code>    mkdir -p iso/modules</code></pre>
<p>The application <code>program</code> will be created later in this chapt=
er.</p>
<p>The code that calls <code>kmain</code> must be updated to pass informati=
on to <code>kmain</code> about where it can find the modules. We also want =
to tell GRUB that it should align all the modules on page boundaries when l=
oading them (see the chapter <a href=3D"https://littleosbook.github.io/#pag=
ing">=E2=80=9CPaging=E2=80=9D</a> for details about page alignment).</p>
<p>To instruct GRUB how to load our modules, the =E2=80=9Cmultiboot header=
=E2=80=9D - the first bytes of the kernel - must be updated as follows:</p>
<pre class=3D"sourceCode nasm"><code class=3D"sourceCode nasm">    <span cl=
ass=3D"co">; in file `loader.s`</span>


    MAGIC_NUMBER    <span class=3D"dt">equ</span> <span class=3D"bn">0x1BAD=
B002</span>      <span class=3D"co">; define the magic number constant</spa=
n>
    ALIGN_MODULES   <span class=3D"dt">equ</span><span class=3D"bn"> 0x0000=
0001      </span><span class=3D"co">; tell GRUB to align modules</span>

    <span class=3D"co">; calculate the checksum (all options + checksum sho=
uld equal 0)</span>
    CHECKSUM        <span class=3D"dt">equ</span> -(MAGIC_NUMBER + ALIGN_MO=
DULES)

    <span class=3D"kw">section</span> .text:                      <span cla=
ss=3D"co">; start of the text (code) section</span>
    <span class=3D"kw">align</span> <span class=3D"dv">4</span>            =
                 <span class=3D"co">; the code must be 4 byte aligned</span=
>
        <span class=3D"dt">dd</span> MAGIC_NUMBER                 <span cla=
ss=3D"co">; write the magic number</span>
        <span class=3D"dt">dd</span> ALIGN_MODULES                <span cla=
ss=3D"co">; write the align modules instruction</span>
        <span class=3D"dt">dd</span> CHECKSUM                     <span cla=
ss=3D"co">; write the checksum</span></code></pre>
<p>GRUB will also store a pointer to a <code>struct</code> in the register =
<code>ebx</code> that, among other things, describes at which addresses the=
 modules are loaded. Therefore, you probably want to push <code>ebx</code> =
on the stack before calling <code>kmain</code> to make it an argument for <=
code>kmain</code>.</p>
<h2 id=3D"executing-a-program"><span class=3D"header-section-number">7.2</s=
pan> Executing a Program</h2>
<h3 id=3D"a-very-simple-program"><span class=3D"header-section-number">7.2.=
1</span> A Very Simple Program</h3>
<p>A program written at this stage can only perform a few actions. Therefor=
e, a very short program that writes a value to a register suffices as a tes=
t program. Halting Bochs after a while and then check that register contain=
s the correct number by looking in the Bochs log will verify that the progr=
am has run. This is an example of such a short program:</p>
<pre class=3D"sourceCode nasm"><code class=3D"sourceCode nasm">    <span cl=
ass=3D"co">; set eax to some distinguishable number, to read from the log a=
fterwards</span>
    <span class=3D"kw">mov</span> <span class=3D"kw">eax</span>, <span clas=
s=3D"bn">0xDEADBEEF</span>

    <span class=3D"co">; enter infinite loop, nothing more to do</span>
    <span class=3D"co">; $ means "beginning of line", ie. the same instruct=
ion</span>
    <span class=3D"kw">jmp</span> <span class=3D"dv">$</span></code></pre>
<h3 id=3D"compiling"><span class=3D"header-section-number">7.2.2</span> Com=
piling</h3>
<p>Since our kernel cannot parse advanced executable formats we need to com=
pile the code into a flat binary. NASM can do this with the flag <code>-f</=
code>:</p>
<pre><code>    nasm -f bin program.s -o program</code></pre>
<p>This is all we need. You must now move the file <code>program</code> to =
the folder <code>iso/modules</code>.</p>
<h3 id=3D"finding-the-program-in-memory"><span class=3D"header-section-numb=
er">7.2.3</span> Finding the Program in Memory</h3>
<p>Before jumping to the program we must find where it resides in memory. A=
ssuming that the contents of <code>ebx</code> is passed as an argument to <=
code>kmain</code>, we can do this entirely from C.</p>
<p>The pointer in <code>ebx</code> points to a <em>multiboot</em> structure=
 <span class=3D"citation">[19]</span>. Download the <code>multiboot.h</code=
> file from <a href=3D"http://www.gnu.org/software/grub/manual/multiboot/ht=
ml_node/multiboot.h.html">http://www.gnu.org/software/grub/manual/multiboot=
/html_node/multiboot.h.html</a>, which describes the structure.</p>
<p>The pointer passed to <code>kmain</code> in the <code>ebx</code> registe=
r can be cast to a <code>multiboot_info_t</code> pointer. The address of th=
e first module is in the field <code>mods_addr</code>. The following code s=
hows an example:</p>
<pre class=3D"sourceCode c"><code class=3D"sourceCode c">    <span class=3D=
"dt">int</span> kmain(<span class=3D"co">/* additional arguments */</span> =
<span class=3D"dt">unsigned</span> <span class=3D"dt">int</span> ebx)
    {
        multiboot_info_t *mbinfo =3D (multiboot_info_t *) ebx;
        <span class=3D"dt">unsigned</span> <span class=3D"dt">int</span> ad=
dress_of_module =3D mbinfo-&gt;mods_addr;
    }</code></pre>
<p>However, before just blindly following the pointer, you should check tha=
t the module got loaded correctly by GRUB. This can be done by checking the=
 <code>flags</code> field of the <code>multiboot_info_t</code> structure. Y=
ou should also check the field <code>mods_count</code> to make sure it is e=
xactly 1. For more details about the multiboot structure, see the multiboot=
 documentation <span class=3D"citation">[19]</span>.</p>
<h3 id=3D"jumping-to-the-code"><span class=3D"header-section-number">7.2.4<=
/span> Jumping to the Code</h3>
<p>The only thing left to do is to jump to the code loaded by GRUB. Since i=
t is easier to parse the multiboot structure in C than assembly code, calli=
ng the code from C is more convenient (it can of course be done with <code>=
jmp</code> or <code>call</code> in assembly code as well). The C code could=
 look like this:</p>
<pre class=3D"sourceCode c"><code class=3D"sourceCode c">    <span class=3D=
"kw">typedef</span> <span class=3D"dt">void</span> (*call_module_t)(<span c=
lass=3D"dt">void</span>);
    <span class=3D"co">/* ... */</span>
    call_module_t start_program =3D (call_module_t) address_of_module;
    start_program();
    <span class=3D"co">/* we'll never get here, unless the module code retu=
rns */</span></code></pre>
<p>If we start the kernel, wait until it has run and entered the infinite l=
oop in the program, and then halt Bochs, we should see <code>0xDEADBEEF</co=
de> in the register <code>eax</code> via the Bochs log. We have successfull=
y started a program in our OS!</p>
<h2 id=3D"the-beginning-of-user-mode"><span class=3D"header-section-number"=
>7.3</span> The Beginning of User Mode</h2>
<p>The program we=E2=80=99ve written now runs at the same privilege level a=
s the kernel - we=E2=80=99ve just entered it in a somewhat peculiar way. To=
 enable applications to execute at a different privilege level we=E2=80=99l=
l need to, beside <a href=3D"https://littleosbook.github.io/#segmentation">=
<em>segmentation</em></a>, do <a href=3D"https://littleosbook.github.io/#pa=
ging"><em>paging</em></a> and <a href=3D"https://littleosbook.github.io/#pa=
ge-frame-allocation"><em>page frame allocation</em></a>.</p>
<p>It=E2=80=99s quite a lot of work and technical details to go through, bu=
t in a few chapters you=E2=80=99ll have working user mode programs.</p>
<h1 id=3D"a-short-introduction-to-virtual-memory"><span class=3D"header-sec=
tion-number">8</span> A Short Introduction to Virtual Memory</h1>
<p><em>Virtual memory</em> is an abstraction of physical memory. The purpos=
e of virtual memory is generally to simplify application development and to=
 let processes address more memory than what is actually physically present=
 in the machine. We also don=E2=80=99t want applications messing with the k=
ernel or other applications=E2=80=99 memory due to security.</p>
<p>In the x86 architecture, virtual memory can be accomplished in two ways:=
 <em>segmentation</em> and <em>paging</em>. Paging is by far the most commo=
n and versatile technique, and we=E2=80=99ll implement it the next chapter.=
 Some use of segmentation is still necessary to allow for code to execute u=
nder different privilege levels.</p>
<p>Managing memory is a big part of what an operating system does. <a href=
=3D"https://littleosbook.github.io/#paging">Paging</a> and <a href=3D"https=
://littleosbook.github.io/#page-frame-allocation">page frame allocation</a>=
 deals with that.</p>
<p>Segmentation and paging is described in the <span class=3D"citation">[33=
]</span>, chapter 3 and 4.</p>
<h2 id=3D"virtual-memory-through-segmentation"><span class=3D"header-sectio=
n-number">8.1</span> Virtual Memory Through Segmentation?</h2>
<p>You could skip paging entirely and just use segmentation for virtual mem=
ory. Each user mode process would get its own segment, with base address an=
d limit properly set up. This way no process can see the memory of another =
process. A problem with this is that the physical memory for a process need=
s to be contiguous (or at least it is very convenient if it is). Either we =
need to know in advance how much memory the program will require (unlikely)=
, or we can move the memory segments to places where they can grow when the=
 limit is reached (expensive, causes fragmentation - can result in =E2=80=
=9Cout of memory=E2=80=9D even though enough memory is available). Paging s=
olves both these problems.</p>
<p>It is interesting to note that in x86_64 (the 64-bit version of the x86 =
architecture), segmentation is almost completely removed.</p>
<h2 id=3D"further-reading-5"><span class=3D"header-section-number">8.2</spa=
n> Further Reading</h2>
<ul>
<li>LWN.net has an article on virtual memory: <a href=3D"http://lwn.net/Art=
icles/253361/">http://lwn.net/Articles/253361/</a></li>
<li>Gustavo Duarte has also written an article about virtual memory: <a hre=
f=3D"http://duartes.org/gustavo/blog/post/memory-translation-and-segmentati=
on">http://duartes.org/gustavo/blog/post/memory-translation-and-segmentatio=
n</a></li>
</ul>
<h1 id=3D"paging"><span class=3D"header-section-number">9</span> Paging</h1=
>
<p>Segmentation translates a logical address into a linear address. <em>Pag=
ing</em> translates these linear addresses onto the physical address space,=
 and determines access rights and how the memory should be cached.</p>
<h2 id=3D"why-paging"><span class=3D"header-section-number">9.1</span> Why =
Paging?</h2>
<p>Paging is the most common technique used in x86 to enable virtual memory=
. Virtual memory through paging means that each process will get the impres=
sion that the available memory range is <code>0x00000000</code> - <code>0xF=
FFFFFFF</code> even though the actual size of the memory might be much less=
. It also means that when a process addresses a byte of memory it will use =
a virtual (linear) address instead of physical one. The code in the user pr=
ocess won=E2=80=99t notice any difference (except for execution delays). Th=
e linear address gets translated to a physical address by the MMU and the p=
age table. If the virtual address isn=E2=80=99t mapped to a physical addres=
s, the CPU will raise a page fault interrupt.</p>
<p>Paging is optional, and some operating systems do not make use of it. Bu=
t if we want to mark certain areas of memory accessible only to code runnin=
g at a certain privilege level (to be able to have processes running at dif=
ferent privilege levels), paging is the neatest way to do it.</p>
<h2 id=3D"paging-in-x86"><span class=3D"header-section-number">9.2</span> P=
aging in x86</h2>
<p>Paging in x86 (chapter 4 in the Intel manual <span class=3D"citation">[3=
3]</span>) consists of a <em>page directory</em> (PDT) that can contain ref=
erences to 1024 <em>page tables</em> (PT), each of which can point to 1024 =
sections of physical memory called <em>page frames</em> (PF). Each page fra=
me is 4096 byte large. In a virtual (linear) address, the highest 10 bits s=
pecifies the offset of a page directory entry (PDE) in the current PDT, the=
 next 10 bits the offset of a page table entry (PTE) within the page table =
pointed to by that PDE. The lowest 12 bits in the address is the offset wit=
hin the page frame to be addressed.</p>
<p>All page directories, page tables and page frames need to be aligned on =
4096 byte addresses. This makes it possible to address a PDT, PT or PF with=
 just the highest 20 bits of a 32 bit address, since the lowest 12 need to =
be zero.</p>
<p>The PDE and PTE structure is very similar to each other: 32 bits (4 byte=
s), where the highest 20 bits points to a PTE or PF, and the lowest 12 bits=
 control access rights and other configurations. 4 bytes times 1024 equals =
4096 bytes, so a page directory and page table both fit in a page frame the=
mselves.</p>
<p>The translation of linear addresses to physical addresses is described i=
n the figure below.</p>
<p>While pages are normally 4096 bytes, it is also possible to use 4 MB pag=
es. A PDE then points directly to a 4 MB page frame, which needs to be alig=
ned on a 4 MB address boundary. The address translation is almost the same =
as in the figure, with just the page table step removed. It is possible to =
mix 4 MB and 4 KB pages.</p>
<div class=3D"figure">
<img src=3D"https://littleosbook.github.io/images/intel_4_2_linear_address_=
translation.png" alt=3D"Translating virtual addresses (linear addresses) to=
 physical addresses."><p class=3D"caption">Translating virtual addresses (l=
inear addresses) to physical addresses.</p>
</div>
<p>The 20 bits pointing to the current PDT is stored in the register <code>=
cr3</code>. The lower 12 bits of <code>cr3</code> are used for configuratio=
n.</p>
<p>For more details on the paging structures, see chapter 4 in the Intel ma=
nual <span class=3D"citation">[33]</span>. The most interesting bits are <e=
m>U/S</em>, which determine what privilege levels can access this page (PL0=
 or PL3), and <em>R/W</em>, which makes the memory in the page read-write o=
r read-only.</p>
<h3 id=3D"identity-paging"><span class=3D"header-section-number">9.2.1</spa=
n> Identity Paging</h3>
<p>The simplest kind of paging is when we map each virtual address onto the=
 same physical address, called <em>identity paging</em>. This can be done a=
t compile time by creating a page directory where each entry points to its =
corresponding 4 MB frame. In NASM this can be done with macros and commands=
 (<code>%rep</code>, <code>times</code> and <code>dd</code>). It can of cou=
rse also be done at run-time by using ordinary assembly code instructions.<=
/p>
<h3 id=3D"enabling-paging"><span class=3D"header-section-number">9.2.2</spa=
n> Enabling Paging</h3>
<p>Paging is enabled by first writing the address of a page directory to <c=
ode>cr3</code> and then setting bit 31 (the PG =E2=80=9Cpaging-enable=E2=80=
=9D bit) of <code>cr0</code> to <code>1</code>. To use 4 MB pages, set the =
PSE bit (Page Size Extensions, bit 4) of <code>cr4</code>. The following as=
sembly code shows an example:</p>
<pre class=3D"sourceCode nasm"><code class=3D"sourceCode nasm">    <span cl=
ass=3D"co">; eax has the address of the page directory</span>
    <span class=3D"kw">mov</span> <span class=3D"kw">cr3</span>, <span clas=
s=3D"kw">eax</span>

    <span class=3D"kw">mov</span> <span class=3D"kw">ebx</span>, <span clas=
s=3D"kw">cr4</span>        <span class=3D"co">; read current cr4</span>
    <span class=3D"kw">or</span>  <span class=3D"kw">ebx</span><span class=
=3D"bn">, 0x00000010 </span><span class=3D"co">; set PSE</span>
    <span class=3D"kw">mov</span> <span class=3D"kw">cr4</span>, <span clas=
s=3D"kw">ebx</span>        <span class=3D"co">; update cr4</span>

    <span class=3D"kw">mov</span> <span class=3D"kw">ebx</span>, <span clas=
s=3D"kw">cr0</span>        <span class=3D"co">; read current cr0</span>
    <span class=3D"kw">or</span>  <span class=3D"kw">ebx</span><span class=
=3D"bn">, 0x80000000 </span><span class=3D"co">; set PG</span>
    <span class=3D"kw">mov</span> <span class=3D"kw">cr0</span>, <span clas=
s=3D"kw">ebx</span>        <span class=3D"co">; update cr0</span>

    <span class=3D"co">; now paging is enabled</span></code></pre>
<h3 id=3D"a-few-details"><span class=3D"header-section-number">9.2.3</span>=
 A Few Details</h3>
<p>It is important to note that all addresses within the page directory, pa=
ge tables and in <code>cr3</code> need to be physical addresses to the stru=
ctures, never virtual. This will be more relevant in later sections where w=
e dynamically update the paging structures (see the chapter <a href=3D"http=
s://littleosbook.github.io/#user-mode">=E2=80=9CUser Mode=E2=80=9D</a>).</p=
>
<p>An instruction that is useful when an updating a PDT or PT is <code>invl=
pg</code>. It invalidates the <em>Translation Lookaside Buffer</em> (TLB) e=
ntry for a virtual address. The TLB is a cache for translated addresses, ma=
pping physical addresses corresponding to virtual addresses. This is only r=
equired when changing a PDE or PTE that was previously mapped to something =
else. If the PDE or PTE had previously been marked as not present (bit 0 wa=
s set to 0), executing <code>invlpg</code> is unnecessary. Changing the val=
ue of <code>cr3</code> will cause all entries in the TLB to be invalidated.=
</p>
<p>An example of invalidating a TLB entry is shown below:</p>
<pre class=3D"sourceCode nasm"><code class=3D"sourceCode nasm">    <span cl=
ass=3D"co">; invalidate any TLB references to virtual address 0</span>
    <span class=3D"kw">invlpg</span> [<span class=3D"dv">0</span>]</code></=
pre>
<h2 id=3D"paging-and-the-kernel"><span class=3D"header-section-number">9.3<=
/span> Paging and the Kernel</h2>
<p>This section will describe how paging affects the OS kernel. We encourag=
e you to run your OS using identity paging before trying to implement a mor=
e advanced paging setup, since it can be hard to debug a malfunctioning pag=
e table that is set up via assembly code.</p>
<h3 id=3D"reasons-to-not-identity-map-the-kernel"><span class=3D"header-sec=
tion-number">9.3.1</span> Reasons to Not Identity Map the Kernel</h3>
<p>If the kernel is placed at the beginning of the virtual address space - =
that is, the virtual address space (<code>0x00000000</code>, <code>"size of=
 kernel"</code>) maps to the location of the kernel in memory - there will =
be issues when linking the user mode process code. Normally, during linking=
, the linker assumes that the code will be loaded into the memory position =
<code>0x00000000</code>. Therefore, when resolving absolute references, <co=
de>0x00000000</code> will be the base address for calculating the exact pos=
ition. But if the kernel is mapped onto the virtual address space (<code>0x=
00000000</code>, <code>"size of kernel"</code>), the user mode process cann=
ot be loaded at virtual address <code>0x00000000</code> - it must be placed=
 somewhere else. Therefore, the assumption from the linker that the user mo=
de process is loaded into memory at position <code>0x00000000</code> is wro=
ng. This can be corrected by using a linker script which tells the linker t=
o assume a different starting address, but that is a very cumbersome soluti=
on for the users of the operating system.</p>
<p>This also assumes that we want the kernel to be part of the user mode pr=
ocess=E2=80=99 address space. As we will see later, this is a nice feature,=
 since during system calls we don=E2=80=99t have to change any paging struc=
tures to get access to the kernel=E2=80=99s code and data. The kernel pages=
 will of course require privilege level 0 for access, to prevent a user pro=
cess from reading or writing kernel memory.</p>
<h3 id=3D"the-virtual-address-for-the-kernel"><span class=3D"header-section=
-number">9.3.2</span> The Virtual Address for the Kernel</h3>
<p>Preferably, the kernel should be placed at a very high virtual memory ad=
dress, for example <code>0xC0000000</code> (3 GB). The user mode process is=
 not likely to be 3 GB large, which is now the only way that it can conflic=
t with the kernel. When the kernel uses virtual addresses at 3 GB and above=
 it is called a <em>higher-half kernel</em>. <code>0xC0000000</code> is jus=
t an example, the kernel can be placed at any address higher than 0 to get =
the same benefits. Choosing the correct address depends on how much virtual=
 memory should be available for the kernel (it is easiest if all memory abo=
ve the kernel virtual address should belong to the kernel) and how much vir=
tual memory should be available for the process.</p>
<p>If the user mode process is larger than 3 GB, some pages will need to be=
 swapped out by the kernel. Swapping pages is not part of this book.</p>
<h3 id=3D"placing-the-kernel-at-0xc0000000"><span class=3D"header-section-n=
umber">9.3.3</span> Placing the Kernel at <code>0xC0000000</code></h3>
<p>To start with, it is better to place the kernel at <code>0xC0100000</cod=
e> than <code>0xC0000000</code>, since this makes it possible to map (<code=
>0x00000000</code>, <code>0x00100000</code>) to (<code>0xC0000000</code>, <=
code>0xC0100000</code>). This way, the entire range (<code>0x00000000</code=
>, <code>"size of kernel"</code>) of memory is mapped to the range (<code>0=
xC0000000</code>, <code>0xC0000000  + "size of kernel"</code>).</p>
<p>Placing the kernel at <code>0xC0100000</code> isn=E2=80=99t hard, but it=
 does require some thought. This is once again a linking problem. When the =
linker resolves all absolute references in the kernel, it will assume that =
our kernel is loaded at physical memory location <code>0x00100000</code>, n=
ot <code>0x00000000</code>, since relocation is used in the linker script (=
see the section <a href=3D"https://littleosbook.github.io/#linking-the-kern=
el">=E2=80=9CLinking the kernel=E2=80=9D</a>). However, we want the jumps t=
o be resolved using <code>0xC0100000</code> as base address, since otherwis=
e a kernel jump will jump straight into the user mode process code (remembe=
r that the user mode process is loaded at virtual memory <code>0x00000000</=
code>).</p>
<p>However, we can=E2=80=99t simply tell the linker to assume that the kern=
el starts (is loaded) at <code>0xC01000000</code>, since we want it to be l=
oaded at the physical address <code>0x00100000</code>. The reason for havin=
g the kernel loaded at 1 MB is because it can=E2=80=99t be loaded at <code>=
0x00000000</code>, since there is BIOS and GRUB code loaded below 1 MB. Fur=
thermore, we cannot assume that we can load the kernel at <code>0xC0100000<=
/code>, since the machine might not have 3 GB of physical memory.</p>
<p>This can be solved by using both relocation (<code>.=3D0xC0100000</code>=
) and the <code>AT</code> instruction in the linker script. Relocation spec=
ifies that non-relative memory-references should should use the relocation =
address as base in address calculations. <code>AT</code> specifies where th=
e kernel should be loaded into memory. Relocation is done at link time by G=
NU ld <span class=3D"citation">[37]</span>, the load address specified by <=
code>AT</code> is handled by GRUB when loading the kernel, and is part of t=
he ELF format <span class=3D"citation">[18]</span>.</p>
<h3 id=3D"higher-half-linker-script"><span class=3D"header-section-number">=
9.3.4</span> Higher-half Linker Script</h3>
<p>We can modify the <a href=3D"https://littleosbook.github.io/#linking-the=
-kernel">first linker script</a> to implement this:</p>
<pre><code>    ENTRY(loader)           /* the name of the entry symbol */

    . =3D 0xC0100000          /* the code should be relocated to 3GB + 1MB =
*/

    /* align at 4 KB and load at 1 MB */
    .text ALIGN (0x1000) : AT(ADDR(.text)-0xC0000000)
    {
        *(.text)            /* all text sections from all files */
    }

    /* align at 4 KB and load at 1 MB + . */
    .rodata ALIGN (0x1000) : AT(ADDR(.text)-0xC0000000)
    {
        *(.rodata*)         /* all read-only data sections from all files *=
/
    }

    /* align at 4 KB and load at 1 MB + . */
    .data ALIGN (0x1000) : AT(ADDR(.text)-0xC0000000)
    {
        *(.data)            /* all data sections from all files */
    }

    /* align at 4 KB and load at 1 MB + . */
    .bss ALIGN (0x1000) : AT(ADDR(.text)-0xC0000000)
    {
        *(COMMON)           /* all COMMON sections from all files */
        *(.bss)             /* all bss sections from all files */
    }</code></pre>
<h3 id=3D"entering-the-higher-half"><span class=3D"header-section-number">9=
.3.5</span> Entering the Higher Half</h3>
<p>When GRUB jumps to the kernel code, there is no paging table. Therefore,=
 all references to <code>0xC0100000 + X</code> won=E2=80=99t be mapped to t=
he correct physical address, and will therefore cause a general protection =
exception (GPE) at the very best, otherwise (if the computer has more than =
3 GB of memory) the computer will just crash.</p>
<p>Therefore, assembly code that doesn=E2=80=99t use relative jumps or rela=
tive memory addressing must be used to do the following:</p>
<ul>
<li>Set up a page table.</li>
<li>Add identity mapping for the first 4 MB of the virtual address space.</=
li>
<li>Add an entry for <code>0xC0100000</code> that maps to <code>0x0010000</=
code></li>
</ul>
<p>If we skip the identity mapping for the first 4 MB, the CPU would genera=
te a page fault immediately after paging was enabled when trying to fetch t=
he next instruction from memory. After the table has been created, an jump =
can be done to a label to make <code>eip</code> point to a virtual address =
in the higher half:</p>
<pre class=3D"sourceCode nasm"><code class=3D"sourceCode nasm">    <span cl=
ass=3D"co">; assembly code executing at around 0x00100000</span>
    <span class=3D"co">; enable paging for both actual location of kernel</=
span>
    <span class=3D"co">; and its higher-half virtual location</span>

    <span class=3D"kw">lea</span> <span class=3D"kw">ebx</span>, [higher_ha=
lf] <span class=3D"co">; load the address of the label in ebx</span>
    <span class=3D"kw">jmp</span> <span class=3D"kw">ebx</span>            =
    <span class=3D"co">; jump to the label</span>

<span class=3D"fu">    higher_half:</span>
        <span class=3D"co">; code here executes in the higher half kernel</=
span>
        <span class=3D"co">; eip is larger than 0xC0000000</span>
        <span class=3D"co">; can continue kernel initialisation, calling C =
code, etc.</span></code></pre>
<p>The register <code>eip</code> will now point to a memory location somewh=
ere right after <code>0xC0100000</code> - all the code can now execute as i=
f it were located at <code>0xC0100000</code>, the higher-half. The entry ma=
pping of the first 4 MB of virtual memory to the first 4 MB of physical mem=
ory can now be removed from the page table and its corresponding entry in t=
he TLB invalidated with <code>invlpg [0]</code>.</p>
<h3 id=3D"running-in-the-higher-half"><span class=3D"header-section-number"=
>9.3.6</span> Running in the Higher Half</h3>
<p>There are a few more details we must deal with when using a higher-half =
kernel. We must be careful when using memory-mapped I/O that uses specific =
memory locations. For example, the frame buffer is located at <code>0x000B8=
000</code>, but since there is no entry in the page table for the address <=
code>0x000B8000</code> any longer, the address <code>0xC00B8000</code> must=
 be used, since the virtual address <code>0xC0000000</code> maps to the phy=
sical address <code>0x00000000</code>.</p>
<p>Any explicit references to addresses within the multiboot structure need=
s to be changed to reflect the new virtual addresses as well.</p>
<p>Mapping 4 MB pages for the kernel is simple, but wastes memory (unless y=
ou have a really big kernel). Creating a higher-half kernel mapped in as 4 =
KB pages saves memory but is harder to set up. Memory for the page director=
y and one page table can be reserved in the <code>.data</code> section, but=
 one needs to configure the mappings from virtual to physical addresses at =
run-time. The size of the kernel can be determined by exporting labels from=
 the linker script <span class=3D"citation">[37]</span>, which we=E2=80=99l=
l need to do later anyway when writing the page frame allocator (see the ch=
apter <a href=3D"https://littleosbook.github.io/#page-frame-allocation">=E2=
=80=9CPage Frame Allocation</a>).</p>
<h2 id=3D"virtual-memory-through-paging"><span class=3D"header-section-numb=
er">9.4</span> Virtual Memory Through Paging</h2>
<p>Paging enables two things that are good for virtual memory. First, it al=
lows for fine-grained access control to memory. You can mark pages as read-=
only, read-write, only for PL0 etc. Second, it creates the illusion of cont=
iguous memory. User mode processes, and the kernel, can access memory as if=
 it were contiguous, and the contiguous memory can be extended without the =
need to move data around in memory. We can also allow the user mode program=
s access to all memory below 3 GB, but unless they actually use it, we don=
=E2=80=99t have to assign page frames to the pages. This allows processes t=
o have code located near <code>0x00000000</code> and the stack at just belo=
w <code>0xC0000000</code>, and still not require more than two actual pages=
.</p>
<h2 id=3D"further-reading-6"><span class=3D"header-section-number">9.5</spa=
n> Further Reading</h2>
<ul>
<li>Chapter 4 (and to some extent chapter 3) of the Intel manual <span clas=
s=3D"citation">[33]</span> are your definitive sources for the details abou=
t paging.</li>
<li>Wikipedia has an article on paging: <a href=3D"http://en.wikipedia.org/=
wiki/Paging">http://en.wikipedia.org/wiki/Paging</a></li>
<li>The OSDev wiki has a page on paging: <a href=3D"http://wiki.osdev.org/P=
aging">http://wiki.osdev.org/Paging</a> and a tutorial for making a higher-=
half kernel: <a href=3D"http://wiki.osdev.org/Higher_Half_bare_bones">http:=
//wiki.osdev.org/Higher_Half_bare_bones</a></li>
<li>Gustavo Duarte=E2=80=99s article on how a kernel manages memory is well=
 worth a read: <a href=3D"http://duartes.org/gustavo/blog/post/anatomy-of-a=
-program-in-memory">http://duartes.org/gustavo/blog/post/anatomy-of-a-progr=
am-in-memory</a></li>
<li>Details on the linker command language can be found at Steve Chamberlai=
n=E2=80=99s website <span class=3D"citation">[37]</span>.</li>
<li>More details on the ELF format can be found in this presentation: <a hr=
ef=3D"http://flint.cs.yale.edu/cs422/doc/ELF_Format.pdf">http://flint.cs.ya=
le.edu/cs422/doc/ELF_Format.pdf</a></li>
</ul>
<h1 id=3D"page-frame-allocation"><span class=3D"header-section-number">10</=
span> Page Frame Allocation</h1>
<p>When using virtual memory, how does the OS know which parts of memory ar=
e free to use? That is the role of the page frame allocator.</p>
<h2 id=3D"managing-available-memory"><span class=3D"header-section-number">=
10.1</span> Managing Available Memory</h2>
<h3 id=3D"how-much-memory-is-there"><span class=3D"header-section-number">1=
0.1.1</span> How Much Memory is There?</h3>
<p>First we need to know how much memory is available on the computer the O=
S is running on. The easiest way to do this is to read it from the multiboo=
t structure <span class=3D"citation">[19]</span> passed to us by GRUB. GRUB=
 collects the information we need about the memory - what is reserved, I/O =
mapped, read-only etc. We must also make sure that we don=E2=80=99t mark th=
e part of memory used by the kernel as free (since GRUB doesn=E2=80=99t mar=
k this memory as reserved). One way to know how much memory the kernel uses=
 is to export labels at the beginning and the end of the kernel binary from=
 the linker script:</p>
<pre><code>    ENTRY(loader)           /* the name of the entry symbol */

    . =3D 0xC0100000          /* the code should be relocated to 3 GB + 1 M=
B */

    /* these labels get exported to the code files */
    kernel_virtual_start =3D .;
    kernel_physical_start =3D . - 0xC0000000;

    /* align at 4 KB and load at 1 MB */
    .text ALIGN (0x1000) : AT(ADDR(.text)-0xC0000000)
    {
        *(.text)            /* all text sections from all files */
    }

    /* align at 4 KB and load at 1 MB + . */
    .rodata ALIGN (0x1000) : AT(ADDR(.rodata)-0xC0000000)
    {
        *(.rodata*)         /* all read-only data sections from all files *=
/
    }

    /* align at 4 KB and load at 1 MB + . */
    .data ALIGN (0x1000) : AT(ADDR(.data)-0xC0000000)
    {
        *(.data)            /* all data sections from all files */
    }

    /* align at 4 KB and load at 1 MB + . */
    .bss ALIGN (0x1000) : AT(ADDR(.bss)-0xC0000000)
    {
        *(COMMON)           /* all COMMON sections from all files */
        *(.bss)             /* all bss sections from all files */
    }

    kernel_virtual_end =3D .;
    kernel_physical_end =3D . - 0xC0000000;</code></pre>
<p>These labels can directly be read from assembly code and pushed on the s=
tack to make them available to C code:</p>
<pre class=3D"sourceCode nasm"><code class=3D"sourceCode nasm">    <span cl=
ass=3D"kw">extern</span> kernel_virtual_start
    <span class=3D"kw">extern</span> kernel_virtual_end
    <span class=3D"kw">extern</span> kernel_physical_start
    <span class=3D"kw">extern</span> kernel_physical_end

    <span class=3D"co">; ...</span>

    <span class=3D"kw">push</span> kernel_physical_end
    <span class=3D"kw">push</span> kernel_physical_start
    <span class=3D"kw">push</span> kernel_virtual_end
    <span class=3D"kw">push</span> kernel_virtual_start

    <span class=3D"kw">call</span> kmain</code></pre>
<p>This way we get the labels as arguments to <code>kmain</code>. If you wa=
nt to use C instead of assembly code, one way to do it is to declare the la=
bels as functions and take the addresses of these functions:</p>
<pre class=3D"sourceCode c"><code class=3D"sourceCode c">    <span class=3D=
"dt">void</span> kernel_virtual_start(<span class=3D"dt">void</span>);

    <span class=3D"co">/* ... */</span>

    <span class=3D"dt">unsigned</span> <span class=3D"dt">int</span> vaddr =
=3D (<span class=3D"dt">unsigned</span> <span class=3D"dt">int</span>) &amp=
;kernel_virtual_start;</code></pre>
<p>If you use GRUB modules you need to make sure the memory they use is mar=
ked as reserved as well.</p>
<p>Note that the available memory does not need to be contiguous. In the fi=
rst 1 MB there are several I/O-mapped memory sections, as well as memory us=
ed by GRUB and the BIOS. Other parts of the memory might be similarly unava=
ilable.</p>
<p>It=E2=80=99s convenient to divide the memory sections into complete page=
 frames, as we can=E2=80=99t map part of pages into memory.</p>
<h3 id=3D"managing-available-memory-1"><span class=3D"header-section-number=
">10.1.2</span> Managing Available Memory</h3>
<p>How do we know which page frames are in use? The page frame allocator ne=
eds to keep track of which are free and which aren=E2=80=99t. There are sev=
eral ways to do this: bitmaps, linked lists, trees, the Buddy System (used =
by Linux) etc. For more information about the different algorithms see the =
article on OSDev <span class=3D"citation">[38]</span>.</p>
<p>Bitmaps are quite easy to implement. One bit is used for each page frame=
 and one (or more) page frames are dedicated to store the bitmap. (Note tha=
t this is just one way to do it, other designs might be better and/or more =
fun to implement.)</p>
<h2 id=3D"how-can-we-access-a-page-frame"><span class=3D"header-section-num=
ber">10.2</span> How Can We Access a Page Frame?</h2>
<p>The page frame allocator returns the physical start address of the page =
frame. This page frame is not mapped in - no page table points to this page=
 frame. How can we read and write data to the frame?</p>
<p>We need to map the page frame into virtual memory, by updating the PDT a=
nd/or PT used by the kernel. What if all available page tables are full? Th=
en we can=E2=80=99t map the page frame into memory, because we=E2=80=99d ne=
ed a new page table - which takes up an entire page frame - and to write to=
 this page frame we=E2=80=99d need to map its page frame=E2=80=A6 Somehow t=
his circular dependency must be broken.</p>
<p>One solution is to reserve a part of the first page table used by the ke=
rnel (or some other higher-half page table) for temporarily mapping page fr=
ames to make them accessible. If the kernel is mapped at <code>0xC0000000</=
code> (page directory entry with index 768), and 4 KB page frames are used,=
 then the kernel has at least one page table. If we assume - or limit us to=
 - a kernel of size at most 4 MB minus 4 KB we can dedicate the last entry =
(entry 1023) of this page table for temporary mappings. The virtual address=
 of pages mapped in using the last entry of the kernel=E2=80=99s PT will be=
:</p>
<pre><code>    (768 &lt;&lt; 22) | (1023 &lt;&lt; 12) | 0x000 =3D 0xC03FF00=
0</code></pre>
<p>After we=E2=80=99ve temporarily mapped the page frame we want to use as =
a page table, and set it up to map in our first page frame, we can add it t=
o the paging directory, and remove the temporary mapping.</p>
<h2 id=3D"a-kernel-heap"><span class=3D"header-section-number">10.3</span> =
A Kernel Heap</h2>
<p>So far we=E2=80=99ve only been able to work with fixed-size data, or dir=
ectly with raw memory. Now that we have a page frame allocator we can imple=
ment <code>malloc</code> and <code>free</code> to use in the kernel.</p>
<p>Kernighan and Ritchie <span class=3D"citation">[8]</span> have an exampl=
e implementation in their book <span class=3D"citation">[8]</span> that we =
can draw inspiration from. The only modification we need to do is to replac=
e calls to <code>sbrk</code>/<code>brk</code> with calls to the page frame =
allocator when more memory is needed. We must also make sure to map the pag=
e frames returned by the page frame allocator to virtual addresses. A corre=
ct implementation should also return page frames to the page frame allocato=
r on call to <code>free</code>, whenever sufficiently large blocks of memor=
y are freed.</p>
<h2 id=3D"further-reading-7"><span class=3D"header-section-number">10.4</sp=
an> Further reading</h2>
<ul>
<li>The OSDev wiki page on page frame allocation: <a href=3D"http://wiki.os=
dev.org/Page_Frame_Allocation">http://wiki.osdev.org/Page_Frame_Allocation<=
/a></li>
</ul>
<h1 id=3D"user-mode"><span class=3D"header-section-number">11</span> User M=
ode</h1>
<p>User mode is now almost within our reach, there are just a few more step=
s required to get there. Although these steps might seem easy they way they=
 are presented in this chapter, they can be tricky to implement, since ther=
e are a lot of places where small errors will cause bugs that are hard to f=
ind.</p>
<h2 id=3D"segments-for-user-mode"><span class=3D"header-section-number">11.=
1</span> Segments for User Mode</h2>
<p>To enable user mode we need to add two more segments to the GDT. They ar=
e very similar to the kernel segments we added when we <a href=3D"https://l=
ittleosbook.github.io/#the-global-descriptor-table-gdt">set up the GDT</a> =
in the <a href=3D"https://littleosbook.github.io/#segmentation">chapter abo=
ut segmentation</a>:</p>
<table class=3D" has_caption">
<caption>The segment descriptors needed for user mode.</caption>
<thead>
<tr class=3D"header">
<th align=3D"right">Index</th>
<th align=3D"right">Offset</th>
<th align=3D"left">Name</th>
<th align=3D"left">Address range</th>
<th align=3D"left">Type</th>
<th align=3D"left">DPL</th>
</tr>
</thead>
<tbody>
<tr class=3D"odd">
<td align=3D"right">3</td>
<td align=3D"right"><code>0x18</code></td>
<td align=3D"left">user code segment</td>
<td align=3D"left"><code>0x00000000 - 0xFFFFFFFF</code></td>
<td align=3D"left">RX</td>
<td align=3D"left">PL3</td>
</tr>
<tr class=3D"even">
<td align=3D"right">4</td>
<td align=3D"right"><code>0x20</code></td>
<td align=3D"left">user data segment</td>
<td align=3D"left"><code>0x00000000 - 0xFFFFFFFF</code></td>
<td align=3D"left">RW</td>
<td align=3D"left">PL3</td>
</tr>
</tbody>
</table>
<p>The difference is the DPL, which now allows code to execute in PL3. The =
segments can still be used to address the entire address space, just using =
these segments for user mode code will not protect the kernel. For that we =
need paging.</p>
<h2 id=3D"setting-up-for-user-mode"><span class=3D"header-section-number">1=
1.2</span> Setting Up For User Mode</h2>
<p>There are a few things every user mode process needs:</p>
<ul>
<li><p>Page frames for code, data and stack. At the moment it suffices to a=
llocate one page frame for the stack and enough page frames to fit the prog=
ram=E2=80=99s code. Don=E2=80=99t worry about setting up a stack that can b=
e grow and shrink at this point in time, focus on getting a basic implement=
ation work first.</p></li>
<li><p>The binary from the GRUB module has to be copied to the page frames =
used for the programs code.</p></li>
<li><p>A page directory and page tables are needed to map the page frames d=
escribed above into memory. At least two page tables are needed, because th=
e code and data should be mapped in at <code>0x00000000</code> and increasi=
ng, and the stack should start just below the kernel, at <code>0xBFFFFFFB</=
code>, growing towards lower addresses. The U/S flag has to be set to allow=
 PL3 access.</p></li>
</ul>
<p>It might be convenient to store this information in a <code>struct</code=
> representing a process. This process <code>struct</code> can be dynamical=
ly allocated with the kernel=E2=80=99s <code>malloc</code> function.</p>
<h2 id=3D"entering-user-mode"><span class=3D"header-section-number">11.3</s=
pan> Entering User Mode</h2>
<p>The only way to execute code with a lower privilege level than the curre=
nt privilege level (CPL) is to execute an <code>iret</code> or <code>lret</=
code> instruction - interrupt return or long return, respectively.</p>
<p>To enter user mode we set up the stack as if the processor had raised an=
 inter-privilege level interrupt. The stack should look like the following:=
</p>
<pre><code>    [esp + 16]  ss      ; the stack segment selector we want for=
 user mode
    [esp + 12]  esp     ; the user mode stack pointer
    [esp +  8]  eflags  ; the control flags we want to use in user mode
    [esp +  4]  cs      ; the code segment selector
    [esp +  0]  eip     ; the instruction pointer of user mode code to exec=
ute</code></pre>
<p>See the Intel manual <span class=3D"citation">[33]</span>, section 6.2.1=
, figure 6-4 for more information.</p>
<p>The instruction <code>iret</code> will then read these values from the s=
tack and fill in the corresponding registers. Before we execute <code>iret<=
/code> we need to change to the page directory we setup for the user mode p=
rocess. It is important to remember that to continue executing kernel code =
after we=E2=80=99ve switched PDT, the kernel needs to be mapped in. One way=
 to accomplish this is to have a separate PDT for the kernel, which maps al=
l data at <code>0xC0000000</code> and above, and merge it with the user PDT=
 (which only maps below <code>0xC0000000</code>) when performing the switch=
. Remember that physical address of the PDT has to be used when setting the=
 register <code>cr3</code>.</p>
<p>The register <code>eflags</code> contains a set of different flags, spec=
ified in section 2.3 of the Intel manual <span class=3D"citation">[33]</spa=
n>. Most important for us is the interrupt enable (IF) flag. The assembly c=
ode instruction <code>sti</code> can=E2=80=99t be used in privilege level 3=
 for enabling interrupts. If interrupts are disabled when entering user mod=
e, then interrupts can=E2=80=99t enabled once user mode is entered. Setting=
 the IF flag in the <code>eflags</code> entry on the stack will enable inte=
rrupts in user mode, since the assembly code instruction <code>iret</code> =
will set the register <code>eflags</code> to the corresponding value on the=
 stack.</p>
<p>For now, we should have interrupts disabled, as it requires a little mor=
e work to get inter-privilege level interrupts to work properly (see the se=
ction <a href=3D"https://littleosbook.github.io/#system-calls">=E2=80=9CSys=
tem calls=E2=80=9D</a>).</p>
<p>The value <code>eip</code> on the stack should point to the entry point =
for the user code - <code>0x00000000</code> in our case. The value <code>es=
p</code> on the stack should be where the stack starts - <code>0xBFFFFFFB</=
code> (<code>0xC0000000 - 4</code>).</p>
<p>The values <code>cs</code> and <code>ss</code> on the stack should be th=
e segment selectors for the user code and user data segments, respectively.=
 As we saw in the <a href=3D"https://littleosbook.github.io/#creating-and-l=
oading-the-gdt">segmentation chapter</a>, the lowest two bits of a segment =
selector is the RPL - the Requested Privilege Level. When using <code>iret<=
/code> to enter PL3, the RPL of <code>cs</code> and <code>ss</code> should =
be <code>0x3</code>. The following code shows an example:</p>
<pre class=3D"sourceCode nasm"><code class=3D"sourceCode nasm">    USER_MOD=
E_CODE_SEGMENT_SELECTOR <span class=3D"dt">equ</span><span class=3D"bn"> 0x=
18</span>
    USER_MODE_DATA_SEGMENT_SELECTOR <span class=3D"dt">equ</span><span clas=
s=3D"bn"> 0x20</span>
    <span class=3D"kw">mov</span> <span class=3D"kw">cs</span>, USER_MODE_C=
ODE_SEGMENT_SELECTOR |<span class=3D"bn"> 0x3</span>
    <span class=3D"kw">mov</span> <span class=3D"kw">ss</span>, USER_MODE_D=
ATA_SEGMENT_SELECTOR |<span class=3D"bn"> 0x3</span></code></pre>
<p>The register <code>ds</code>, and the other data segment registers, shou=
ld be set to the same segment selector as <code>ss</code>. They can be set =
the ordinary way, with the <code>mov</code> assembly code instruction.</p>
<p>We are now ready to execute <code>iret</code>. If everything has been se=
t up right, we should now have a kernel that can enter user mode.</p>
<h2 id=3D"using-c-for-user-mode-programs"><span class=3D"header-section-num=
ber">11.4</span> Using C for User Mode Programs</h2>
<p>When C is used as the programming language for user mode programs, it is=
 important to think about the structure of the file that will be the result=
 of the compilation.</p>
<p>The reason we can use ELF <span class=3D"citation">[18]</span> as the fi=
le format for for the kernel executable is because GRUB knows how to parse =
and interpret the ELF file format. If we implemented an ELF parser, we coul=
d compile the user mode programs into ELF binaries as well. We leave this a=
s an exercise for the reader.</p>
<p>One thing we can do to make it easier to develop user mode programs is t=
o allow the programs to be written in C, but compile them to flat binaries =
instead of ELF binaries. In C the layout of the generated code is more unpr=
edictable and the entry point, <code>main</code>, might not be at offset 0 =
in the binary. One common way to work around this is to add a few assembly =
code lines placed at offset 0 which calls <code>main</code>:</p>
<pre class=3D"sourceCode nasm"><code class=3D"sourceCode nasm">    <span cl=
ass=3D"kw">extern</span> main

    <span class=3D"kw">section</span> .text
        <span class=3D"co">; push argv</span>
        <span class=3D"co">; push argc</span>
        <span class=3D"kw">call</span> main
        <span class=3D"co">; main has returned, eax is return value</span>
        <span class=3D"kw">jmp</span>  <span class=3D"dv">$</span>    <span=
 class=3D"co">; loop forever</span></code></pre>
<p>If this code is saved in a file called <code>start.s</code>, then the fo=
llowing code show an example of a linker script that places these instructi=
ons first in executable (remember that <code>start.s</code> gets compiled t=
o <code>start.o</code>):</p>
<pre><code>    OUTPUT_FORMAT("binary")    /* output flat binary */

    SECTIONS
    {
        . =3D 0;                 /* relocate to address 0 */

        .text ALIGN(4):
        {
            start.o(.text)     /* include the .text section of start.o */
            *(.text)           /* include all other .text sections */
        }

        .data ALIGN(4):
        {
            *(.data)
        }

        .rodata ALIGN(4):
        {
            *(.rodata*)
        }
    }</code></pre>
<p><em>Note</em>: <code>*(.text)</code> will not include the <code>.text</c=
ode> section of <code>start.o</code> again.</p>
<p>With this script we can write programs in C or assembler (or any other l=
anguage that compiles to object files linkable with <code>ld</code>), and i=
t is easy to load and map for the kernel (<code>.rodata</code> will be mapp=
ed in as writeable, though).</p>
<p>When we compile user programs we want the following GCC flags:</p>
<pre><code>    -m32 -nostdlib -nostdinc -fno-builtin -fno-stack-protector -=
nostartfiles
    -nodefaultlibs</code></pre>
<p>For linking, the followings flags should be used:</p>
<pre><code>    -T link.ld -melf_i386  # emulate 32 bits ELF, the binary out=
put is specified
                           # in the linker script</code></pre>
<p>The option <code>-T</code> instructs the linker to use the linker script=
 <code>link.ld</code>.</p>
<h3 id=3D"a-c-library"><span class=3D"header-section-number">11.4.1</span> =
A C Library</h3>
<p>It might now be interesting to start thinking about writing a small =E2=
=80=9Cstandard library=E2=80=9D for your programs. Some of the functionalit=
y requires <a href=3D"https://littleosbook.github.io/#system-calls">system =
calls</a> to work, but some, such as the functions in <code>string.h</code>=
, does not.</p>
<h2 id=3D"further-reading-8"><span class=3D"header-section-number">11.5</sp=
an> Further Reading</h2>
<ul>
<li>Gustavo Duarte has an article on privilege levels: <a href=3D"http://du=
artes.org/gustavo/blog/post/cpu-rings-privilege-and-protection">http://duar=
tes.org/gustavo/blog/post/cpu-rings-privilege-and-protection</a></li>
</ul>
<h1 id=3D"file-systems"><span class=3D"header-section-number">12</span> Fil=
e Systems</h1>
<p>We are not required to have file systems in our operating system, but it=
 is a very usable abstraction, and it often plays a central part of many op=
erating systems, especially UNIX-like operating systems. Before we start th=
e process of supporting multiple processes and system calls we might want t=
o consider implementing a simple file system.</p>
<h2 id=3D"why-a-file-system"><span class=3D"header-section-number">12.1</sp=
an> Why a File System?</h2>
<p>How do we specify what programs to run in our OS? Which is the first pro=
gram to run? How do programs output data or read input?</p>
<p>In UNIX-like systems, with their almost-everything-is-a-file convention,=
 these problems are solved by the file system. (It might also be interestin=
g to read a bit about the Plan 9 project, which takes this idea one step fu=
rther.)</p>
<h2 id=3D"a-simple-read-only-file-system"><span class=3D"header-section-num=
ber">12.2</span> A Simple Read-Only File System</h2>
<p>The simplest file system might be what we already have - one file, exist=
ing only in RAM, loaded by GRUB before the kernel starts. When the kernel a=
nd operating system grows this is probably too limiting.</p>
<p>A file system that is slightly more advanced than just the bits of one f=
ile is a file with metadata. The metadata can describe the type of the file=
, the size of the file and so on. A utility program can be created that run=
s at build time, adding this metadata to a file. This way, a =E2=80=9Cfile =
system in a file=E2=80=9D can be constructed by concatenating several files=
 with metadata into one large file. The result of this technique is a read-=
only file system that resides in memory (once GRUB has loaded the file).</p=
>
<p>The program constructing the file system can traverse a directory on the=
 host system and add all subdirectories and files as part of the target fil=
e system. Each object in the file system (directory or file) can consist of=
 a header and a body, where the body of a file is the actual file and the b=
ody of a directory is a list of entries - names and =E2=80=9Caddresses=E2=
=80=9D of other files and directories.</p>
<p>Each object in this file system will become contiguous, so they will be =
easy to read from memory for the kernel. All objects will also have a fixed=
 size (except for the last one, which can grow), therefore it is difficult =
to add new files or modify existing ones.</p>
<h2 id=3D"inodes-and-writable-file-systems"><span class=3D"header-section-n=
umber">12.3</span> Inodes and Writable File Systems</h2>
<p>When the need for a writable file system arises, then it is a good idea =
to look into the concept of an <em>inode</em>. See the section <a href=3D"h=
ttps://littleosbook.github.io/#further-reading-6">=E2=80=9CFurther Reading=
=E2=80=9D</a> for recommended reading.</p>
<h2 id=3D"a-virtual-file-system"><span class=3D"header-section-number">12.4=
</span> A Virtual File System</h2>
<p>What abstraction should be used for reading and writing to devices such =
as the screen and the keyboard?</p>
<p>A virtual file system (VFS) creates an abstraction on top of the concret=
e file systems. A VFS mainly supplies the path system and file hierarchy, i=
t delegates operations on files to the underlying file systems. The origina=
l paper on VFS is succinct and well worth a read. See the section <a href=
=3D"https://littleosbook.github.io/#further-reading-6">=E2=80=9CFurther Rea=
ding=E2=80=9D</a> for a reference.</p>
<p>With a VFS we could mount a special file system on the path <code>/dev</=
code>. This file system would handle all devices such as keyboards and the =
console. However, one could also take the traditional UNIX approach, with m=
ajor/minor device numbers and <code>mknod</code> to create special files fo=
r devices. Which approach you think is the most appropriate is up to you, t=
here is no right or wrong when building abstraction layers (although some a=
bstractions turn out way more useful than others).</p>
<h2 id=3D"further-reading-9"><span class=3D"header-section-number">12.5</sp=
an> Further Reading</h2>
<ul>
<li>The ideas behind the Plan 9 operating systems is worth taking a look at=
: <a href=3D"http://plan9.bell-labs.com/plan9/index.html">http://plan9.bell=
-labs.com/plan9/index.html</a></li>
<li>Wikipedia=E2=80=99s page on inodes: <a href=3D"http://en.wikipedia.org/=
wiki/Inode">http://en.wikipedia.org/wiki/Inode</a> and the inode pointer st=
ructure: <a href=3D"http://en.wikipedia.org/wiki/Inode_pointer_structure">h=
ttp://en.wikipedia.org/wiki/Inode_pointer_structure</a>.</li>
<li>The original paper on the concept of vnodes and a virtual file system i=
s quite interesting: <a href=3D"http://www.arl.wustl.edu/~fredk/Courses/cs5=
23/fall01/Papers/kleiman86vnodes.pdf">http://www.arl.wustl.edu/~fredk/Cours=
es/cs523/fall01/Papers/kleiman86vnodes.pdf</a></li>
<li>Poul-Henning Kamp discusses the idea of a special file system for <code=
>/dev</code> in <a href=3D"http://static.usenix.org/publications/library/pr=
oceedings/bsdcon02/full_papers/kamp/kamp_html/index.html">http://static.use=
nix.org/publications/library/proceedings/bsdcon02/full_papers/kamp/kamp_htm=
l/index.html</a></li>
</ul>
<h1 id=3D"system-calls"><span class=3D"header-section-number">13</span> Sys=
tem Calls</h1>
<p><em>System calls</em> is the way user-mode applications interact with th=
e kernel - to ask for resources, request operations to be performed, etc. T=
he system call API is the part of the kernel that is most exposed to the us=
ers, therefore its design requires some thought.</p>
<h2 id=3D"designing-system-calls"><span class=3D"header-section-number">13.=
1</span> Designing System Calls</h2>
<p>It is up to us, the kernel developers, to design the system calls that a=
pplication developers can use. We can draw inspiration from the POSIX stand=
ards or, if they seem like too much work, just look at the ones for Linux, =
and pick and choose. See the section <a href=3D"https://littleosbook.github=
.io/#further-reading-7">=E2=80=9CFurther Reading=E2=80=9D</a> at the end of=
 the chapter for references.</p>
<h2 id=3D"implementing-system-calls"><span class=3D"header-section-number">=
13.2</span> Implementing System Calls</h2>
<p>System calls are traditionally invoked with software interrupts. The use=
r applications put the appropriate values in registers or on the stack and =
then initiates a pre-defined interrupt which transfers execution to the ker=
nel. The interrupt number used is dependent on the kernel, Linux uses the n=
umber <code>0x80</code> to identify that an interrupt is intended as a syst=
em call.</p>
<p>When system calls are executed, the current privilege level is typically=
 changed from PL3 to PL0 (if the application is running in user mode). To a=
llow this, the DPL of the entry in the IDT for the system call interrupt ne=
eds to allow PL3 access.</p>
<p>Whenever inter-privilege level interrupts occur, the processor pushes a =
few important registers onto the stack - the same ones we used to enter use=
r mode <a href=3D"https://littleosbook.github.io/#user-mode">before</a>, se=
e figure 6-4, section 6.12.1, in the Intel manual <span class=3D"citation">=
[33]</span>. What stack is used? The same section in <span class=3D"citatio=
n">[33]</span> specifies that if an interrupt leads to code executing at a =
numerically lower privilege level, a stack switch occurs. The new values fo=
r the registers <code>ss</code> and <code>esp</code> is loaded from the cur=
rent Task State Segment (TSS). The TSS structure is specified in figure 7-2=
, section 7.2.1 of the Intel manual <span class=3D"citation">[33]</span>.</=
p>
<p>To enable system calls we need to setup a TSS before entering user mode.=
 Setting it up can be done in C by setting the <code>ss0</code> and <code>e=
sp0</code> fields of a =E2=80=9Cpacked struct=E2=80=9D that represents a TS=
S. Before loading the =E2=80=9Cpacked struct=E2=80=9D into the processor, a=
 TSS descriptor has to be added to the GDT. The structure of the TSS descri=
ptor is described in section 7.2.2 in <span class=3D"citation">[33]</span>.=
</p>
<p>You specify the current TSS segment selector by loading it into the <cod=
e>tr</code> register with the <code>ltr</code> assembly code instruction. I=
f the TSS segment descriptor has index 5, and thus offset <code>5 * 8 =3D 4=
0 =3D 0x28</code>, this is the value that should be loaded into the registe=
r <code>tr</code>.</p>
<p>When we entered user mode before in the chapter <a href=3D"https://littl=
eosbook.github.io/#entering-user-mode">=E2=80=9CEntering User Mode=E2=80=9D=
</a> we disabled interrupts when executing in PL3. Since system calls are i=
mplemented using interrupts, interrupts must be enabled in user mode. Setti=
ng the IF flag bit in the <code>eflags</code> value on the stack will make =
<code>iret</code> enable interrupts (since the <code>eflags</code> value on=
 the stack will be loaded into the <code>eflags</code> register by the asse=
mbly code instruction <code>iret</code>).</p>
<h2 id=3D"further-reading-10"><span class=3D"header-section-number">13.3</s=
pan> Further Reading</h2>
<ul>
<li>The Wikipedia page on POSIX, with links to the specifications: <a href=
=3D"http://en.wikipedia.org/wiki/POSIX">http://en.wikipedia.org/wiki/POSIX<=
/a></li>
<li>A list of system calls used in Linux: <a href=3D"http://bluemaster.iu.h=
io.no/edu/dark/lin-asm/syscalls.html">http://bluemaster.iu.hio.no/edu/dark/=
lin-asm/syscalls.html</a></li>
<li>The Wikipedia page on system calls: <a href=3D"http://en.wikipedia.org/=
wiki/System_call">http://en.wikipedia.org/wiki/System_call</a></li>
<li>The Intel manual <span class=3D"citation">[33]</span> sections on inter=
rupts (chapter 6) and TSS (chapter 7) are where you get all the details you=
 need.</li>
</ul>
<h1 id=3D"multitasking"><span class=3D"header-section-number">14</span> Mul=
titasking</h1>
<p>How do you make multiple processes appear to run at the same time? Today=
, this question has two answers:</p>
<ul>
<li>With the availability of multi-core processors, or on system with multi=
ple processors, two processes can actually run at the same time by running =
two processes on different cores or processors.</li>
<li>Fake it. That is, switch rapidly (faster than a human can notice) betwe=
en the processes. At any given moment there is only one process executing, =
but the rapid switching gives the impression that they are running =E2=80=
=9Cat the same time=E2=80=9D.</li>
</ul>
<p>Since the operating system created in this book does not support multi-c=
ore processors or multiple processors the only option is to fake it. The pa=
rt of the operating system responsible for rapidly switching between the pr=
ocesses is called the <em>scheduling algorithm</em>.</p>
<h2 id=3D"creating-new-processes"><span class=3D"header-section-number">14.=
1</span> Creating New Processes</h2>
<p>Creating new processes is usually done with two different system calls: =
<code>fork</code> and <code>exec</code>. <code>fork</code> creates an exact=
 copy of the currently running process, while <code>exec</code> replaces th=
e current process with one that is specified by a path to the location of a=
 program in the file system. Of these two we recommend that you start imple=
menting <code>exec</code>, since this system call will do almost exactly th=
e same steps as described in the section <a href=3D"https://littleosbook.gi=
thub.io/#setting-up-for-user-mode">=E2=80=9CSetting up for user mode=E2=80=
=9D</a> in the chapter <a href=3D"https://littleosbook.github.io/#user-mode=
">=E2=80=9CUser Mode=E2=80=9D</a>.</p>
<h2 id=3D"cooperative-scheduling-with-yielding"><span class=3D"header-secti=
on-number">14.2</span> Cooperative Scheduling with Yielding</h2>
<p>The easiest way to achieve rapid switching between processes is if the p=
rocesses themselves are responsible for the switching. The processes run fo=
r a while and then tell the OS (via a system call) that it can now switch t=
o another process. Giving up the control of CPU to another process is calle=
d <em>yielding</em> and when the processes themselves are responsible for t=
he scheduling it=E2=80=99s called <em>cooperative scheduling</em>, since al=
l the processes must cooperate with each other.</p>
<p>When a process yields the process=E2=80=99 entire state must be saved (a=
ll the registers), preferably on the kernel heap in a structure that repres=
ents a process. When changing to a new process all the registers must be re=
stored from the saved values.</p>
<p>Scheduling can be implemented by keeping a list of which processes are r=
unning. The system call <code>yield</code> should then run the next process=
 in the list and put the current one last (other schemes are possible, but =
this is a simple one).</p>
<p>The transfer of control to the new process is done via the <code>iret</c=
ode> assembly code instruction in exactly the same way as explained in the =
section <a href=3D"https://littleosbook.github.io/#entering-user-mode">=E2=
=80=9CEntering user mode=E2=80=9D</a> in the chapter <a href=3D"https://lit=
tleosbook.github.io/#user-mode">=E2=80=9CUser Mode=E2=80=9D</a>.</p>
<p>We <strong>strongly</strong> recommend that you start to implement suppo=
rt for multiple processes by implementing cooperative scheduling. We furthe=
r recommend that you have a working solution for both <code>exec</code>, <c=
ode>fork</code> and <code>yield</code> before implementing preemptive sched=
uling. Since cooperative scheduling is deterministic, it is much easier to =
debug than preemptive scheduling.</p>
<h2 id=3D"preemptive-scheduling-with-interrupts"><span class=3D"header-sect=
ion-number">14.3</span> Preemptive Scheduling with Interrupts</h2>
<p>Instead of letting the processes themselves manage when to change to ano=
ther process the OS can switch processes automatically after a short period=
 of time. The OS can set up the <em>programmable interval timer</em> (PIT) =
to raise an interrupt after a short period of time, for example 20 ms. In t=
he interrupt handler for the PIT interrupt the OS will change the running p=
rocess to a new one. This way the processes themselves don=E2=80=99t need t=
o worry about scheduling. This kind of scheduling is called <em>preemptive =
scheduling</em>.</p>
<h3 id=3D"programmable-interval-timer"><span class=3D"header-section-number=
">14.3.1</span> Programmable Interval Timer</h3>
<p>To be able to do preemptive scheduling the PIT must first be configured =
to raise interrupts every <em>x</em> milliseconds, where <em>x</em> should =
be configurable.</p>
<p>The configuration of the PIT is very similar to the configuration of oth=
er hardware devices: a byte is sent to an I/O port. The command port of the=
 PIT is <code>0x43</code>. To read about all the configuration options, see=
 the article about the PIT on OSDev <span class=3D"citation">[39]</span>. W=
e use the following options:</p>
<ul>
<li>Raise interrupts (use channel 0)</li>
<li>Send the divider as low byte then high byte (see next section for an ex=
planation)</li>
<li>Use a square wave</li>
<li>Use binary mode</li>
</ul>
<p>This results in the configuration byte <code>00110110</code>.</p>
<p>Setting the interval for how often interrupts are to be raised is done v=
ia a <em>divider</em>, the same way as for the serial port. Instead of send=
ing the PIT a value (e.g.&nbsp;in milliseconds) that says how often an inte=
rrupt should be raised you send the divider. The PIT operates at 1193182 Hz=
 as default. Sending the divider 10 results in the PIT running at <code>119=
3182 / 10 =3D 119318</code> Hz. The divider can only be 16 bits, so it is o=
nly possible to configure the timer=E2=80=99s frequency between 1193182 Hz =
and <code>1193182 / 65535 =3D 18.2</code> Hz. We recommend that you create =
a function that takes an interval in milliseconds and converts it to the co=
rrect divider.</p>
<p>The divider is sent to the channel 0 data I/O port of the PIT, but since=
 only one byte can be sent at at a time, the lowest 8 bits of the divider h=
as to sent first, then the highest 8 bits of the divider can be sent. The c=
hannel 0 data I/O port is located at <code>0x40</code>. Again, see the arti=
cle on OSDev <span class=3D"citation">[39]</span> for more details.</p>
<h3 id=3D"separate-kernel-stacks-for-processes"><span class=3D"header-secti=
on-number">14.3.2</span> Separate Kernel Stacks for Processes</h3>
<p>If all processes uses the same kernel stack (the stack exposed by the TS=
S) there will be trouble if a process is interrupted while still in kernel =
mode. The process that is being switched to will now use the same kernel st=
ack and will overwrite what the previous process have written on the stack =
(remember that TSS data structure points to the <em>beginning</em> of the s=
tack).</p>
<p>To solve this problem every process should have it=E2=80=99s own kernel =
stack, the same way that each process have their own user mode stack. When =
switching process the TSS must be updated to point to the new process=E2=80=
=99 kernel stack.</p>
<h3 id=3D"difficulties-with-preemptive-scheduling"><span class=3D"header-se=
ction-number">14.3.3</span> Difficulties with Preemptive Scheduling</h3>
<p>When using preemptive scheduling one problem arises that doesn=E2=80=99t=
 exist with cooperative scheduling. With cooperative scheduling every time =
a process yields, it must be in user mode (privilege level 3), since yield =
is a system call. With preemptive scheduling, the processes can be interrup=
ted in either user mode or kernel mode (privilege level 0), since the proce=
ss itself does not control when it gets interrupted.</p>
<p>Interrupting a process in kernel mode is a little bit different than int=
errupting a process in user mode, due to the way the CPU sets up the stack =
at interrupts. If a privilege level change occurred (the process was interr=
upted in user mode) the CPU will push the value of the process <code>ss</co=
de> and <code>esp</code> register on the stack. If <em>no</em> privilege le=
vel change occurs (the process was interrupted in kernel mode) the CPU won=
=E2=80=99t push the <code>esp</code> register on the stack. Furthermore, if=
 there was no privilege level change, the CPU won=E2=80=99t change stack to=
 the one defined it the TSS.</p>
<p>This problem is solved by calculating what the value of <code>esp</code>=
 was <em>before</em> the interrupt. Since you know that the CPU pushes 3 th=
ings on the stack when no privilege change happens and you know how much yo=
u have pushed on the stack, you can calculate what the value of <code>esp</=
code> was at the time of the interrupt. This is possible since the CPU won=
=E2=80=99t change stacks if there is no privilege level change, so the cont=
ent of <code>esp</code> will be the same as at the time of the interrupt.</=
p>
<p>To further complicate things, one must think of how to handle case when =
switching to a new process that should be running in kernel mode. Since <co=
de>iret</code> is being used without a privilege level change the CPU won=
=E2=80=99t update the value of <code>esp</code> with the one placed on the =
stack - you must update <code>esp</code> yourself.</p>
<h2 id=3D"further-reading-11"><span class=3D"header-section-number">14.4</s=
pan> Further Reading</h2>
<ul>
<li>For more information about different scheduling algorithms, see <a href=
=3D"http://wiki.osdev.org/Scheduling_Algorithms">http://wiki.osdev.org/Sche=
duling_Algorithms</a></li>
</ul>
<div class=3D"references">
<h1><span class=3D"header-section-number">14.4</span> References</h1>
<p>[1] Andrew Tanenbaum, 2007. <em>Modern operating systems, 3rd edition</e=
m>. Prentice Hall, Inc.,</p>
<p>[2] <em>The royal institute of technology</em>, <a href=3D"http://www.kt=
h.se/">http://www.kth.se</a>,</p>
<p>[3] Wikipedia, <em>Hexadecimal</em>, <a href=3D"http://en.wikipedia.org/=
wiki/Hexadecimal">http://en.wikipedia.org/wiki/Hexadecimal</a>,</p>
<p>[4] OSDev, <em>OSDev</em>, <a href=3D"http://wiki.osdev.org/Main_Page">h=
ttp://wiki.osdev.org/Main_Page</a>,</p>
<p>[5] James Molloy, <em>James m=E2=80=99s kernel development tutorial</em>=
, <a href=3D"http://www.jamesmolloy.co.uk/tutorial_html/">http://www.jamesm=
olloy.co.uk/tutorial_html/</a>,</p>
<p>[6] Canonical Ltd, <em>Ubuntu</em>, <a href=3D"http://www.ubuntu.com/">h=
ttp://www.ubuntu.com/</a>,</p>
<p>[7] Oracle, <em>Oracle vM virtualBox</em>, <a href=3D"http://www.virtual=
box.org/">http://www.virtualbox.org/</a>,</p>
<p>[8] Dennis M. Ritchie Brian W. Kernighan, 1988. <em>The c programming la=
nguage, second edition</em>. Prentice Hall, Inc.,</p>
<p>[9] Wikipedia, <em>C (programming language)</em>, <a href=3D"http://en.w=
ikipedia.org/wiki/C_(programming_language)">http://en.wikipedia.org/wiki/C_=
(programming_language)</a>,</p>
<p>[10] Free Software Foundation, <em>GCC, the gNU compiler collection</em>=
, <a href=3D"http://gcc.gnu.org/">http://gcc.gnu.org/</a>,</p>
<p>[11] NASM, <em>NASM: The netwide assembler</em>, <a href=3D"http://www.n=
asm.us/">http://www.nasm.us/</a>,</p>
<p>[12] Wikipedia, <em>Bash</em>, <a href=3D"http://en.wikipedia.org/wiki/B=
ash_%28Unix_shell%29">http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29</a=
>,</p>
<p>[13] Free Software Foundation, <em>GNU make</em>, <a href=3D"http://www.=
gnu.org/software/make/">http://www.gnu.org/software/make/</a>,</p>
<p>[14] Volker Ruppert, <em>bochs: The open souce iA-32 emulation project</=
em>, <a href=3D"http://bochs.sourceforge.net/">http://bochs.sourceforge.net=
/</a>,</p>
<p>[15] QEMU, <em>QEMU</em>, <a href=3D"http://wiki.qemu.org/Main_Page">htt=
p://wiki.qemu.org/Main_Page</a>,</p>
<p>[16] Wikipedia, <em>BIOS</em>, <a href=3D"https://en.wikipedia.org/wiki/=
BIOS">https://en.wikipedia.org/wiki/BIOS</a>,</p>
<p>[17] Free Software Foundation, <em>GNU gRUB</em>, <a href=3D"http://www.=
gnu.org/software/grub/">http://www.gnu.org/software/grub/</a>,</p>
<p>[18] Wikipedia, <em>Executable and linkable format</em>, <a href=3D"http=
://en.wikipedia.org/wiki/Executable_and_Linkable_Format">http://en.wikipedi=
a.org/wiki/Executable_and_Linkable_Format</a>,</p>
<p>[19] Free Software Foundation, <em>Multiboot specification version 0.6.9=
6</em>, <a href=3D"http://www.gnu.org/software/%20%20%20%20%20%20%20%20%20%=
20%20grub/manual/multiboot/multiboot.html">http://www.gnu.org/software/
           grub/manual/multiboot/multiboot.html</a>,</p>
<p>[20] GNU, <em>GNU binutils</em>, <a href=3D"http://www.gnu.org/software/=
binutils/">http://www.gnu.org/software/binutils/</a>,</p>
<p>[21] Lars Nodeen, <em>Bug #426419: configure: error: GRUB requires a wor=
king absolute objcopy</em>, <a href=3D"https://bugs.launchpad.net/ubuntu/+s=
ource/grub/+bug/426419">https://bugs.launchpad.net/ubuntu/+source/grub/+bug=
/426419</a>,</p>
<p>[22] Wikipedia, <em>ISO image</em>, <a href=3D"http://en.wikipedia.org/w=
iki/ISO_image">http://en.wikipedia.org/wiki/ISO_image</a>,</p>
<p>[23] Bochs, <em>bochsrc</em>, <a href=3D"http://bochs.sourceforge.net/do=
c/docbook/user/bochsrc.html">http://bochs.sourceforge.net/doc/docbook/user/=
bochsrc.html</a>,</p>
<p>[24] NASM, <em>RESB and friends: Declaring uninitialized data</em>, <a h=
ref=3D"http://www.nasm.us/doc/nasmdoc3.htm">http://www.nasm.us/doc/nasmdoc3=
.htm</a>,</p>
<p>[25] Wikipedia, <em>x86 calling conventions</em>, <a href=3D"http://en.w=
ikipedia.org/wiki/X86_calling_conventions">http://en.wikipedia.org/wiki/X86=
_calling_conventions</a>,</p>
<p>[26] Wikipedia, <em>Framebuffer</em>, <a href=3D"http://en.wikipedia.org=
/wiki/Framebuffer">http://en.wikipedia.org/wiki/Framebuffer</a>,</p>
<p>[27] Wikipedia, <em>VGA-compatible text mode</em>, <a href=3D"http://en.=
wikipedia.org/wiki/VGA-compatible_text_mode">http://en.wikipedia.org/wiki/V=
GA-compatible_text_mode</a>,</p>
<p>[28] Wikipedia, <em>ASCII</em>, <a href=3D"https://en.wikipedia.org/wiki=
/Ascii">https://en.wikipedia.org/wiki/Ascii</a>,</p>
<p>[29] OSDev, <em>VGA hardware</em>, <a href=3D"http://wiki.osdev.org/VGA_=
Hardware">http://wiki.osdev.org/VGA_Hardware</a>,</p>
<p>[30] Wikipedia, <em>Serial port</em>, <a href=3D"http://en.wikipedia.org=
/wiki/Serial_port">http://en.wikipedia.org/wiki/Serial_port</a>,</p>
<p>[31] OSDev, <em>Serial ports</em>, <a href=3D"http://wiki.osdev.org/Seri=
al_ports">http://wiki.osdev.org/Serial_ports</a>,</p>
<p>[32] WikiBooks, <em>Serial programming/8250 uART programming</em>, <a hr=
ef=3D"http://en.wikibooks.org/wiki/Serial_Programming/%20%20%20%20%20%20825=
0_UART_Programming">http://en.wikibooks.org/wiki/Serial_Programming/
      8250_UART_Programming</a>,</p>
<p>[33] Intel, <em>Intel 64 and iA-32 architectures software developer=E2=
=80=99s manual vol. 3A</em>, <a href=3D"http://www.intel.com/content/www/us=
/en/architecture-and-technology/64-ia-32-architectures-software-developer-v=
ol-3a-part-1-manual.html/">http://www.intel.com/content/
www/us/en/architecture-and-technology/64-ia-32-architectures-software-devel=
oper-vol-3a-part-1-manual.html/</a>,</p>
<p>[34] NASM, <em>Multi-line macros</em>, <a href=3D"http://www.nasm.us/doc=
/nasmdoc4.html#section-4.3">http://www.nasm.us/doc/nasmdoc4.html#section-4.=
3</a>,</p>
<p>[35] SIGOPS, <em>i386 interrupt handling</em>, <a href=3D"http://www.acm=
.uiuc.edu/sigops/roll_your_own/i386/irq.html">http://www.acm.uiuc.edu/sigop=
s/roll_your_own/i386/irq.html</a>,</p>
<p>[36] Andries Brouwer, <em>Keyboard scancodes</em>, <a href=3D"http://www=
.win.tue.nl/">http://www.win.tue.nl/</a>,</p>
<p>[37] Steve Chamberlain, <em>Using ld, the gNU linker</em>, <a href=3D"ht=
tp://www.math.utah.edu/docs/info/ld_toc.html">http://www.math.utah.edu/docs=
/info/ld_toc.html</a>,</p>
<p>[38] OSDev, <em>Page frame allocation</em>, <a href=3D"http://wiki.osdev=
.org/Page_Frame_Allocation">http://wiki.osdev.org/Page_Frame_Allocation</a>=
,</p>
<p>[39] OSDev, <em>Programmable interval timer</em>, <a href=3D"http://wiki=
.osdev.org/Programmable_Interval_Timer">http://wiki.osdev.org/Programmable_=
Interval_Timer</a>,</p>
</div>
<div class=3D"footnotes">
<hr>
<ol>
<li id=3D"fn1"><p>The bootloader must fit into the <em>master boot record</=
em> (MBR) boot sector of a hard drive, which is only 512 bytes large.<a hre=
f=3D"https://littleosbook.github.io/#fnref1">=E2=86=A9</a></p></li>
</ol>
</div>
</div>
</div>




</body></html>
------MultipartBoundary--pTIzw0msXwU3B7ZB0SkpfFoayxkwkQKObHsTv4lWBu----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: cid:css-8d2a4cec-adcb-483a-bf78-ee3c59f4823f@mhtml.blink

@charset "utf-8";

table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode { margin: 0p=
x; padding: 0px; vertical-align: baseline; border: none; }

table.sourceCode { width: 100%; line-height: 100%; }

td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; =
color: rgb(170, 170, 170); border-right: 1px solid rgb(170, 170, 170); }

td.sourceCode { padding-left: 5px; }

code > span.kw { color: rgb(0, 112, 32); font-weight: bold; }

code > span.dt { color: rgb(144, 32, 0); }

code > span.dv { color: rgb(64, 160, 112); }

code > span.bn { color: rgb(64, 160, 112); }

code > span.fl { color: rgb(64, 160, 112); }

code > span.ch { color: rgb(64, 112, 160); }

code > span.st { color: rgb(64, 112, 160); }

code > span.co { color: rgb(96, 160, 176); font-style: italic; }

code > span.ot { color: rgb(0, 112, 32); }

code > span.al { color: rgb(255, 0, 0); font-weight: bold; }

code > span.fu { color: rgb(6, 40, 126); }

code > span.er { color: rgb(255, 0, 0); font-weight: bold; }
------MultipartBoundary--pTIzw0msXwU3B7ZB0SkpfFoayxkwkQKObHsTv4lWBu----
Content-Type: text/css
Content-Transfer-Encoding: quoted-printable
Content-Location: https://littleosbook.github.io/book.css

@charset "utf-8";

body { font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; backgro=
und: rgb(221, 221, 170); color: rgb(34, 34, 34); }

a { color: black; }

h1 a { text-decoration: none; }

h2 a { text-decoration: none; }

h3 a { text-decoration: none; }

a:visited { color: rgb(68, 68, 68); }

#TOC a { text-decoration: underline; }

.more { font-size: 0.7em; }

img.right { float: right; margin: 15px; }

#header { font-family: Courier; background: rgb(34, 34, 34); border-top-lef=
t-radius: 0.4em; border-top-right-radius: 0.4em; padding: 1em; text-align: =
center; }

#header h1 { font-size: 2.2em; color: rgb(255, 255, 255); font-weight: norm=
al; }

#header h2 { font-size: 1.5em; margin-left: 0.5em; font-weight: normal; col=
or: rgb(221, 221, 85); }

#header h3 { margin-left: 0.5em; font-weight: normal; color: rgb(221, 221, =
85); }

#wrapper { width: 50em; margin: 2em auto 0px; padding: 0px; background: rgb=
(255, 255, 255); border-radius: 0.4em; box-shadow: rgb(153, 153, 153) 0px 3=
px 7px; }

#menu { background: rgb(68, 68, 68); }

#menu ul { list-style: none; margin: 0px; text-align: center; }

#message { padding: 20px; margin: 10px 30px; border: 1px solid rgb(51, 136,=
 51); background: rgb(170, 238, 170); text-align: center; }

#content { padding: 2em; }

#content h2 { margin: 0px 0px 0.5em; color: black; font-size: 1.5em; }

#content p { line-height: 140%; }

.subheader { background: rgb(68, 136, 68); display: block; padding: 0.4em 0=
.6em 0.3em; font-weight: bold; color: white; border-bottom: 3px solid rgb(3=
4, 102, 34); position: relative; }

.subheader .pdflink { text-align: right; display: block; float: right; }

div.post { margin-bottom: 2em; }

.post h1 { margin-top: 0.2em; }

.post { color: rgb(51, 51, 51); }

.post h1 a { text-decoration: none; clear: left; display: block; color: bla=
ck; padding: 0.3em 0px; margin: 0px 0px 0.2em; border-bottom: 1px dashed rg=
b(85, 85, 85); font-weight: bold; }

.post br { margin-bottom: 10px; }

pre { background: rgb(248, 248, 248); border-style: solid; border-color: rg=
b(231, 229, 220); border-image: initial; border-width: 1px 0px 4px 6px; pad=
ding: 1em; overflow: auto; color: black; line-height: 120%; font-family: Co=
nsolas, "Courier New", Courier, mono; font-size: 12px; letter-spacing: 0px;=
 }

.figure .caption { font-style: italic; }

table thead, table tbody { font-size: 12px; }

table.has_caption { position: relative; padding-bottom: 30px; }

table.has_caption caption { position: absolute; bottom: 0px; left: 0px; }

table caption { font-style: italic; text-align: left; }

table thead { font-weight: bold; background: rgb(234, 234, 234); }

table th, table td { padding: 8px; }

table.post-list { width: 100%; border-collapse: collapse; }

table.post-list a { color: rgb(34, 102, 34); font-weight: bold; }

table.post-list th { text-align: left; }

table.post-list td, table.post-list th { padding: 0.5em 0.3em; border-botto=
m: 1px solid rgb(221, 187, 170); }

table.post-list tr:last-child td, table.post-list tr:last-child th { border=
-bottom: 0px; }

div.related { margin-bottom: 2em; }

#footer { margin-bottom: 2em; color: rgb(62, 66, 58); font-size: 0.9em; pad=
ding: 0.5em; text-align: center; }

.home_box { float: left; }

#content .home_box h2 { background: rgb(51, 51, 51); padding: 0.3em 0.5em; =
border-bottom: 3px solid rgb(102, 102, 102); margin-bottom: 0em; color: rgb=
(221, 221, 85); }

.home_box h2 a { color: rgb(255, 255, 51); margin: 0px 0.2em; }

#home_left { width: 29em; }

#home_right { width: 16em; margin-left: 1em; }

.clearfix { clear: both; }

#footer a { color: rgb(62, 66, 58); font-weight: normal; }

.announce { padding: 0px 5px 20px; }

.home_box .post h1 a { font-size: 0.7em; }

.repo { background: rgb(255, 245, 204); border: 2px solid rgb(221, 221, 170=
); padding: 0.7em 1em; font-size: 0.8em; margin: 1em 1em 0px 0px; border-ra=
dius: 0.5em; }

.repo h3 { margin: 0px 0px 0.3em; }

.repo h3 a { font-weight: bold; color: black; font-size: 1.1em; }

#github-projects.big .repo { width: 25.2em; margin: 1.2em 1em 0px 0px; disp=
lay: inline-block; float: none; vertical-align: top; }

.float-left { float: left; }

.float-right { float: right; }

a img { border: 0px; }

ul#toc { list-style: none; margin: 0px; }

ul#toc ul { list-style: none; }

ul#toc a { color: rgb(51, 51, 51); }

.book-ad a { color: rgb(34, 102, 34); font-size: 1.5em; text-decoration: no=
ne; }

h3.subtitle { margin-top: 15px; }

h3.subtitle small { color: rgb(102, 102, 102); font-size: 0.7em; padding-le=
ft: 10px; }

table.rdata { width: 95%; background: rgb(255, 255, 255); padding: 8px; bor=
der: 1px solid rgb(51, 51, 51); font-size: 1.1em; }

table.rdata tr.level { color: rgb(11, 152, 180); background: rgb(221, 238, =
255); }

table.rdata tr.even { background: rgb(238, 238, 238); }

table.rdata tr th.cmd { font-family: monospace; text-align: left; }

table.rdata tr { }

table.rdata tr th { padding: 8px; }

table.rdata tr td { padding: 15px 8px; border-left: 1px solid rgb(221, 238,=
 255); }

table.rdata tr td.no { background: rgb(255, 221, 221); }

table.rdata tr td.yes { background: rgb(221, 255, 221); }

table.rdata tr td.yes-wd { background: rgb(170, 238, 170); }

table.rdata tr td.no-wd { background: rgb(238, 170, 170); }

.moreinfo { float: right; background: rgb(238, 238, 238); padding: 4px; mar=
gin-left: 8px; margin-bottom: 10px; width: 160px; min-height: 170px; font-s=
ize: 0.9em; border: 1px solid rgb(170, 170, 170); }

.moreinfo .twitter { padding: 8px; }

.moreinfo .twitter small { margin-top: 10px; color: rgb(136, 136, 136); }

.moreinfo .twitter small a { color: rgb(136, 136, 136); }

.moreinfo .book { padding: 10px; font-size: 0.9em; }

.moreinfo img { float: right; padding-left: 10px; }

.commands-index ul { list-style-type: none; padding-left: 20px; }

.commands-index ul li { line-height: 1.5em; }

.commands-index ul li strong { display: inline-block; padding-left: 5px; ve=
rtical-align: top; width: 130px; transition: all 0.2s ease 0s; }

.commands-index ul li:hover strong { background: rgb(221, 221, 170); border=
-radius: 5px; }

.commands-index ul li small { display: inline-block; width: 560px; }

.commands-index ul li small .pagelink { display: inline-block; width: 50px;=
 }
------MultipartBoundary--pTIzw0msXwU3B7ZB0SkpfFoayxkwkQKObHsTv4lWBu----
Content-Type: image/png
Content-Transfer-Encoding: base64
Content-Location: https://littleosbook.github.io/images/boot_chain.png

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
8TLC6qUu5AAAAABJRU5ErkJggg==

------MultipartBoundary--pTIzw0msXwU3B7ZB0SkpfFoayxkwkQKObHsTv4lWBu----
Content-Type: image/png
Content-Transfer-Encoding: base64
Content-Location: https://littleosbook.github.io/images/intel_3_5_logical_to_linear.png

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
zc5IHRwcGtpcFCJ8Ktq5FM+8KNtnoX/FUdtdxnIh0SmyYT6qtwTku2TZdT/VpiTZ/ACVD0V6JYjW
cLtVoqUKVW6+WVg6tS9I9WWiLIdV7b5cIYpMQHZTusMK3WeJskyiWmZJiFvtKvDedJSQT0Jp6Wbm
r/+FnG7/xrQ+QcXGvQv3MCm/75wydGlG0OsWhKRcusQ3mj6LO8pL42uv0SGvfvrNkhbCbNZgocu7
Yen0nFGblvyZYMVNDntjt3WrYlKDy+WyZ2kos8l39bJ5q3b8tv4w4y6ujlFRUVH3B/bt2/eB4ZGR
kRBh40RgYBQqwpKDOWL6imhXkGpHMVl5UVZyBlJMHdeROUb9jDQ1IzE/7knFhja2Bm7FQ0TyCakU
xYEbT/gpIfHm9rJ1bdBdLSkykE3ntBtWDBSxhRcJZxy7JHLFvKhZq3YOHUAPCPcnKs823a2pf9Z8
JG3d1hRLc2WX94wVXdu6//3lO3rNXDPv4KvvHSQTpuSf/ImQlpU2y/KqmFSbJZHLy3IpTFCfdR75
4htLRvdZtPQf1aKOsuqZE+mSXjnIxZqQyoFRGfV8lggRVp+TeaKONjoRRfraa501wjgN4SS0VqEq
azLHuLMlbgAg5KrOFPAAVVWKso2TYp0bYpqOCsztZkRtaiclP3z5cl+abj9iYczs5waERu1d2mFI
CF0ocVq0PjbYXfLhzInzzt0Mf/2L/5WeEUoC/+O+eOjzayyjY9dZ9e9zkmWW9l5P08/P+n490e0m
5h0rbJqVxBq3Or5cUtTMcZ5lucjdJSf+N/GtU1cDe03+4T1Zk29IEGH18RcKeidIX26hM2gFP+ZS
R13IcG/dgBTJx06Gd66Lf1Go5tuxU9NFSong7sOvrHxSMUqlvVZidnmWMNBJb1Nr0gz871bmvxVC
bDpOPMqYfkjoz4zg/+w6HFq29+0V0W/fNyX4KGZ3yXnXMeNZ3LRPmGn831Eb+T/dKmxOK4tVPil5
y9Dyucz9LGZuLRibX8xam1EQYb1BUdTmzZtHjBhRUwnaWWoYRcn6ZGd+aWGujffjV7iTOm7Z2llt
uuBxPkdmJWCZAD5QZq5dZgwc7muUXMUoJYFlK87qr9HbVQGZTMYwTOfOnR95FDtsR0b8SPxEUa+M
HDmSnz5JJOvWrYuIiKjt7DJyJf8pYOdYs9v0htcglNpErVY/++yz/NzByurQoUP3q7FIo9fzZ7js
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
rkJggg==

------MultipartBoundary--pTIzw0msXwU3B7ZB0SkpfFoayxkwkQKObHsTv4lWBu----
Content-Type: image/png
Content-Transfer-Encoding: base64
Content-Location: https://littleosbook.github.io/images/intel_4_2_linear_address_translation.png

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

------MultipartBoundary--pTIzw0msXwU3B7ZB0SkpfFoayxkwkQKObHsTv4lWBu------
